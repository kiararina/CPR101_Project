commit 7e8dfbe4e408a8446ed3d82b4792e0fc8b86320b
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Mon Aug 15 01:32:01 2022 -0400

    Fixed some wording, v3.0.1
    
    Fixed typo: seperated -> separated
    Changed words to phrases for V2.
    Changed words to sentences for V3.

diff --git a/tokenizing.c b/tokenizing.c
index 1b84ae4..eed56eb 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -19,7 +19,7 @@ void tokenizing(void) {
     char* nextWord = NULL;
     int wordsCounter;
     do {
-        printf("Type a few words seperated by space (q - to quit):\n");
+        printf("Type a few words separated by space (q - to quit):\n");
 
         fgets(words, BUFFER_SIZE, stdin);
         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
@@ -48,7 +48,7 @@ void tokenizing(void) {
     char* nextPhrase = NULL;
     int phrasesCounter;
     do {
-        printf("Type a few words seperated by comma (q - to quit):\n");
+        printf("Type a few phrases separated by comma (q - to quit):\n");
 
         fgets(phrases, BUFFER_SIZE, stdin);
         phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
@@ -77,7 +77,7 @@ void tokenizing(void) {
     char* nextSentence = NULL;
     int sentencesCounter;
     do {
-        printf("Type a few words seperated by dot (q - to quit):\n");
+        printf("Type a few sentences separated by dot (q - to quit):\n");
 
         fgets(sentences, BUFFER_SIZE, stdin);
         sentences[strlen(sentences) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends

commit 6af4833fe03480fd5fb1cf7bbca4c49ea023dd8a
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Mon Aug 15 01:30:57 2022 -0400

    Added \n, v3.0.1
    
    Missing a new line in formatting, added one to get the expected output.

diff --git a/manipulating.c b/manipulating.c
index 925e182..71b405f 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -31,7 +31,7 @@ void manipulating(void) {
 		}
 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
 
-	printf("*** End of Concatenating Strings Demo ***\n");
+	printf("*** End of Concatenating Strings Demo ***\n\n");
 
 //V2
 	printf("*** Start of Comparing Strings Demo ***\n");

commit 05fd4d77d9d8b90d4e909cb58bef17bcb3b0ce68
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Mon Aug 15 01:30:00 2022 -0400

    Updating main.c to V3
    
    Changed version to reflect final version of project.

diff --git a/main.c b/main.c
index 70aeeb7..ed37418 100644
--- a/main.c
+++ b/main.c
@@ -1,6 +1,6 @@
 // MAIN 
 /*
-Author: BB01, 03/08/2022, CPR101, Final Project
+Author: BB01, 03/08/2022, CPR101, Final Project V3
 main.c : MAIN
 Purpose: Main Function used to prompt user for which various options.
 */

commit de158c0e58d4ab3314761cf52bb1fd03cce17ff4
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Mon Aug 15 01:29:33 2022 -0400

    Fixing capitals, v3.0.1
    
    Capitalized start, copying, and copy.

diff --git a/fundamentals.c b/fundamentals.c
index e3f533c..439038b 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -58,7 +58,7 @@ void fundamentals(void) {
 
     
     //V3
-    printf("*** start of copying Strings Demo ***\n"); 
+    printf("*** Start of Copying Strings Demo ***\n"); 
     char destination [BUFFER_SIZE]; 
     char source[BUFFER_SIZE]; 
     do {
@@ -81,5 +81,5 @@ void fundamentals(void) {
         }
         //loops till user enter q
     } while (strcmp (source, "q") != 0); 
-    printf("*** End of copying Strings Demo ***\n\n");
+    printf("*** End of Copying Strings Demo ***\n\n");
 }
\ No newline at end of file

commit d6b05fba1879928ff1427213da0e635c4bfa51f4
Merge: 6010491 392ff3a
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Sun Aug 14 22:20:49 2022 -0400

    Merge pull request #11 from kiararina/tokenizing_v3
    
    Tokenizing v3 final update

commit 392ff3a97de42b82af7901d5efbbce867979effb
Author: jt-tn <jasontn91@gmail.com>
Date:   Sun Aug 14 22:19:37 2022 -0400

    Update tokenizing-git-log.txt

diff --git a/tokenizing-git-log.txt b/tokenizing-git-log.txt
index ce553d5..287c8a7 100644
--- a/tokenizing-git-log.txt
+++ b/tokenizing-git-log.txt
@@ -1,3 +1,8626 @@
+commit b4865c3d183df4dfc091ff317cba85a88d517427
+Author: jt-tn <jasontn91@gmail.com>
+Date:   Sun Aug 14 22:17:40 2022 -0400
+
+    tokenizing v3 fixed
+
+diff --git a/tokenizing-git-log.txt b/tokenizing-git-log.txt
+index 7bb5209..ce553d5 100644
+--- a/tokenizing-git-log.txt
++++ b/tokenizing-git-log.txt
+@@ -904,9 +904,9 @@ index 0000000..07d1cd7
+ +Comments are for programmers who will maintain the code in the future. 
+ +Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+ +Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+-+--------------------------------------------------------------------------------
+++---------------------------------------------------------------------------------
+ +Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+-+--------------------------------------------------------------------------------
+++---------------------------------------------------------------------------------
+ +
+ +Organisation of Comments
+ +Program comments 
+
+commit ddf5966bcc817b43a1b2fecb08c4ff09df54a6d4
+Author: jt-tn <jasontn91@gmail.com>
+Date:   Sun Aug 14 18:04:01 2022 -0400
+
+    Update tokenizing.c
+
+diff --git a/tokenizing.c b/tokenizing.c
+index f5beb9e..1b84ae4 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -50,7 +50,7 @@ void tokenizing(void) {
+     do {
+         printf("Type a few words seperated by comma (q - to quit):\n");
+ 
+-        fgets(phrases, BUFFER_SIZE, stdin); 
++        fgets(phrases, BUFFER_SIZE, stdin);
+         phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+@@ -59,7 +59,7 @@ void tokenizing(void) {
+ 
+     //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of phrases being tokenized 
+             while (nextPhrase) {
+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                printf("Phrase #%d is \'%s\'\n", phrasesCounter++, nextPhrase);
+                 nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+             }
+         }
+@@ -71,28 +71,28 @@ void tokenizing(void) {
+ 
+ 
+     // V3
+-    /* Delimiter is now a single period (".") */
++    /* Delimiter is now a single dot (".") */
+     printf("*** Start of Tokenizing Sentences Demo ***\n");
+     char sentences[BUFFER_SIZE];
+     char* nextSentence = NULL;
+     int sentencesCounter;
+     do {
+-        printf("Type a few words seperated by comma (q - to quit):\n");
++        printf("Type a few words seperated by dot (q - to quit):\n");
+ 
+-        fgets(sentences, BUFFER_SIZE, stdin); 
++        fgets(sentences, BUFFER_SIZE, stdin);
+         sentences[strlen(sentences) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if ((strcmp(sentences, "q") != 0)) { // only executes if user did not input 'q'
+-            nextSentence = strtok(sentences, "."); // use a period as the delimiter to know when to split the string into tokens
++            nextSentence = strtok(sentences, "."); // use a dot as the delimiter to know when to split the string into tokens
+             sentencesCounter = 1; // intialize sentencesCounter to 1, and start counting from 1 to keep track of how many sentences are being tokenized
+ 
+     //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of sentences being tokenized 
+             while (nextSentence) {
+-                printf("Word #%d is \'%s\'\n", sentencesCounter++, nextSentence); 
++                printf("Sentence #%d is \'%s\'\n", sentencesCounter++, nextSentence);
+                 nextSentence = strtok(NULL, "."); // when the next value of the string reads as null, we break out of the loop
+             }
+         }
+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++    } while (strcmp(sentences, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Sentences Demo ***\n\n");
+ 
+
+commit 7e2fb09bfa9e3c6a5415ac9669fd212cbc7b0af7
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Fri Aug 12 14:22:38 2022 -0400
+
+    tokenizing.c v3
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 67fa08e..f5beb9e 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -5,7 +5,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+ 
+ 
+-// TOKENIZING MODULE SOURCE
++//TOKENIZING MODULE SOURCE
+ #define _CRT_SECURE_NO_WARNINGS
+ #define BUFFER_SIZE 300
+ #include "tokenizing.h"
+
+commit dd246d275a3b9a1fd1be0609a5a726db8381abde
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Fri Aug 12 14:21:36 2022 -0400
+
+    Update tokenizing.c
+
+diff --git a/tokenizing.c b/tokenizing.c
+index ae26066..67fa08e 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 11/08/2022, CPR101, Final Project V3
+ [tokenizing.c] : [tokenizing]
+ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+@@ -11,7 +11,6 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ #include "tokenizing.h"
+ 
+ 
+-
+ void tokenizing(void) {
+ 
+     // V1
+@@ -40,9 +39,11 @@ void tokenizing(void) {
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+ 
+ 
++
++
+     // V2
+     /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-    printf("*** Start of Tokenizing Words Demo ***\n");
++    printf("*** Start of Tokenizing Phrases Demo ***\n");
+     char phrases[BUFFER_SIZE];
+     char* nextPhrase = NULL;
+     int phrasesCounter;
+@@ -56,7 +57,7 @@ void tokenizing(void) {
+             nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+             phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+ 
+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of phrases being tokenized 
+             while (nextPhrase) {
+                 printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+                 nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+@@ -64,7 +65,41 @@ void tokenizing(void) {
+         }
+     } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
++    printf("*** End of Tokenizing Phrases Demo ***\n\n");
++
++
++
++
++    // V3
++    /* Delimiter is now a single period (".") */
++    printf("*** Start of Tokenizing Sentences Demo ***\n");
++    char sentences[BUFFER_SIZE];
++    char* nextSentence = NULL;
++    int sentencesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(sentences, BUFFER_SIZE, stdin); 
++        sentences[strlen(sentences) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(sentences, "q") != 0)) { // only executes if user did not input 'q'
++            nextSentence = strtok(sentences, "."); // use a period as the delimiter to know when to split the string into tokens
++            sentencesCounter = 1; // intialize sentencesCounter to 1, and start counting from 1 to keep track of how many sentences are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of sentences being tokenized 
++            while (nextSentence) {
++                printf("Word #%d is \'%s\'\n", sentencesCounter++, nextSentence); 
++                nextSentence = strtok(NULL, "."); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Sentences Demo ***\n\n");
++
++
++
++
++
+ }
+ 
+ 
+
+commit ade615136b67a44a1c986034b1ce8c45b1f10a01
+Merge: faa99c8 443688d
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Fri Aug 12 12:04:26 2022 -0400
+
+    Merge pull request #2 from kiararina/manipulating
+    
+    Update manipulating.c for version 3.
+
+commit 443688d725f580de26b30951bc73c5f4420cbd78
+Author: krpm <25734153+kiararina@users.noreply.github.com>
+Date:   Fri Aug 12 10:23:30 2022 -0400
+
+    Update to version 3
+
+diff --git a/manipulating_git_log.txt b/manipulating_git_log.txt
+new file mode 100644
+index 0000000..05aa537
+--- /dev/null
++++ b/manipulating_git_log.txt
+@@ -0,0 +1,1587 @@
++commit e14f5c429efccb7dc63749da2a425659ad905631
++Author: krpm <25734153+kiararina@users.noreply.github.com>
++Date:   Fri Aug 12 08:37:11 2022 -0400
++
++    Update manipulating.c for version 3.
++    
++    Added a section for checking the occurrence of 2nd string in 1st string.
++
++diff --git a/manipulating.c b/manipulating.c
++index 9193243..925e182 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
++ 
++ // V1
++ void manipulating(void) {
++-/* Purpose: This function concatenates 2 input strings */
+++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
++ 
++ 	printf("*** Start of Concatenating Strings Demo ***\n");
++ 	char string1[BUFFER_SIZE];
++@@ -56,4 +56,27 @@ void manipulating(void) {
++ 		}
++ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++ 	printf("*** End of Comparing Strings Demo ***\n\n");
+++
+++
+++//V3
+++	printf("*** Start of Searching Strings Demo ***\n");
+++	char haystack[BUFFER_SIZE];
+++	char needle[BUFFER_SIZE];
+++	char* occurence = NULL;
+++	do {
+++		printf("Type the string (q - to quit):\n");
+++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
+++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
+++			printf("Type the substring:\n");
+++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
+++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
+++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
+++			if (occurence)							// If found, return the position where 2nd string occurs
+++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
+++			else						
+++				printf("Not found\n");				
+++		}
+++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Searching Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 23:04:40 2022 -0400
++
++    Adding git logs
++    
++    Version 2 Git Logs
++    $ git --no-pager log -p > "module-git-log.txt"
++
++diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
++new file mode 100644
++index 0000000..7bb5209
++--- /dev/null
+++++ b/manipulating-git-log.txt
++@@ -0,0 +1,1345 @@
+++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+++Merge: 6361388 c3a8316
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Tue Aug 9 22:49:17 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit 63613886b8f1ecccb62538d6d4b7905425a16358
+++Merge: 0626d2e c0f7dc8
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Tue Aug 9 22:47:37 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+++Merge: 9d98950 c0f7dc8
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 22:46:28 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+++Merge: fd97b97 a2a1bf4
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Tue Aug 9 22:44:47 2022 -0400
+++
+++    Merge pull request #1 from kiararina/converting
+++    
+++    Recovering lost commits up to converting.c
+++
+++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+++Merge: cee497d fd97b97
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Tue Aug 9 22:44:00 2022 -0400
+++
+++    Merge branch 'main' into converting
+++
+++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:23:44 2022 -0400
+++
+++    tokenizing.c v2 corrected
+++    
+++    Corrected a previous error, now both v1 and v2 are within the same function name
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 6332b6d..ae26066 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ 
+++ 
+++ 
++++void tokenizing(void) {
+++ 
+++-/*
+++-// V1
+++-//void tokenizing(void) {
+++-
++++    // V1
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char words[BUFFER_SIZE];
+++     char* nextWord = NULL;
+++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++     do {
+++         printf("Type a few words seperated by space (q - to quit):\n");
+++ 
+++-        fgets(words, BUFFER_SIZE, stdin); 
++++        fgets(words, BUFFER_SIZE, stdin);
+++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++ 
+++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ 
+++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++             while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++             }
+++-       }
++++        }
+++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++ 
+++     printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-*/
+++ 
+++ 
+++-// V2
+++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++-void tokenizing(void) {
+++-
++++    // V2
++++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char phrases[BUFFER_SIZE];
+++     char* nextPhrase = NULL;
+++
+++commit 23f162166b815502c16ac1456d8f9be87b799f26
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:09:02 2022 -0400
+++
+++    Update tokenizing.c to V2
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index edc3184..6332b6d 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++ [tokenizing.c] : [tokenizing]
+++ Purpose: [This function takes a user inputted string and tokenizes it]
+++ */
+++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ #include "tokenizing.h"
+++ 
+++ 
+++-int main(void) {
+++-    tokenizing();
+++-    return 0;
+++-}
+++ 
+++ 
++++/*
+++ // V1
+++-void tokenizing(void) {
++++//void tokenizing(void) {
+++ 
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char words[BUFFER_SIZE];
+++@@ -34,16 +31,46 @@ void tokenizing(void) {
+++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++ 
+++-        
+++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++             while (nextWord) {
+++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++             }
+++-        }
++++       }
+++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++ 
+++     printf("*** End of Tokenizing Words Demo ***\n\n");
+++ }
++++*/
++++
++++
++++// V2
++++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char phrases[BUFFER_SIZE];
++++    char* nextPhrase = NULL;
++++    int phrasesCounter;
++++    do {
++++        printf("Type a few words seperated by comma (q - to quit):\n");
++++
++++        fgets(phrases, BUFFER_SIZE, stdin); 
++++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++++            while (nextPhrase) {
++++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++++            }
++++        }
++++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
+++ 
+++ 
+++
+++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:06:55 2022 -0400
+++
+++    V1
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 417d34a..edc3184 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,80 +1,49 @@
+++-/*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++-[tokenizing.c] : [tokenizing]
+++-Purpose: [This function takes a user inputted string and tokenizes it]
+++-*/
+++-
+++-
+++-// TOKENIZING MODULE SOURCE
+++-#define _CRT_SECURE_NO_WARNINGS
+++-#define BUFFER_SIZE 300
+++-#include "tokenizing.h"
+++-
+++-
+++-int main(void) {
+++-    tokenizing();
+++-    return 0;
+++-}
+++-
+++-
+++-/*
+++-// V1
+++-//void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char words[BUFFER_SIZE];
+++-    char* nextWord = NULL;
+++-    int wordsCounter;
+++-    do {
+++-        printf("Type a few words seperated by space (q - to quit):\n");
+++-
+++-        fgets(words, BUFFER_SIZE, stdin); 
+++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++-            while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++-            }
+++-       }
+++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-*/
+++-
+++-
+++-// V2
+++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++-void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char phrases[BUFFER_SIZE];
+++-    char* nextPhrase = NULL;
+++-    int phrasesCounter;
+++-    do {
+++-        printf("Type a few words seperated by comma (q - to quit):\n");
+++-
+++-        fgets(phrases, BUFFER_SIZE, stdin); 
+++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++-            while (nextPhrase) {
+++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++-            }
+++-        }
+++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-
+++-
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++
++++int main(void) {
++++    tokenizing();
++++    return 0;
++++}
++++
++++
++++// V1
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++        
++++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++        }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++
+++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+++Author: CRYPTO43 <singharshjot07@gmail.com>
+++Date:   Tue Aug 9 17:12:27 2022 -0400
+++
+++    first commit
+++
+++diff --git a/fundamentals.c b/fundamentals.c
+++new file mode 100644
+++index 0000000..cd7cd9f
+++--- /dev/null
++++++ b/fundamentals.c
+++@@ -0,0 +1,63 @@
++++/*
++++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++++fundamentals.c : indexing
++++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++++*/
++++
++++
++++// FUNDAMENTALS MODULE SOURCE 
++++#define _CRT_SECURE_NO_WARNINGS 
++++#define BUFFER_SIZE 80
++++#define NUM_INPUT_SIZE 10 
++++#include "fundamentals.h"
++++
++++
++++void main(void) {
++++
++++// V1
++++    printf("*** start of Indexing Strings Demo ***\n"); 
++++    char buffer1[BUFFER_SIZE]; 
++++    char numInput[NUM_INPUT_SIZE]; 
++++    size_t position; 
++++    do {
++++        printf("Type not empty string (q - to quit): \n"); 
++++        fgets (buffer1, BUFFER_SIZE, stdin); 
++++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp (buffer1, "q") != 0) { 
++++            printf("Type the character position within the string: \n"); 
++++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++++            position = atoi (numInput); // Converts entered string to integer.
++++
++++            // Checks if converted integer is larger then string length and assigns max position if true.
++++            if (position >= strlen (buffer1)) { 
++++                position = strlen (buffer1) - 1; 
++++                printf("Too big... Position reduced to max. availbale\n");
++++            }
++++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++++        }
++++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++++    printf("*** End of Indexing Strings Demo ***\n\n");
++++
++++
++++
++++    // V2 
++++    printf("*** Start of Measuring Strings Demo ***\n"); 
++++    char buffer2[BUFFER_SIZE]; 
++++    do { 
++++        printf("Type a string (q - to quit):\n"); 
++++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp(buffer2, "q") != 0) 
++++            printf("The length of \'%s\' is %d characters\n", 
++++            buffer2, (int)strlen(buffer2)); 
++++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++++        
++++        printf("*** End of Measuring Strings Demo ***\n\n");
++++}
++++
++++ 
+++\ No newline at end of file
+++diff --git a/fundamentals.h b/fundamentals.h
+++new file mode 100644
+++index 0000000..383cccc
+++--- /dev/null
++++++ b/fundamentals.h
+++@@ -0,0 +1,12 @@
++++// FUNDAMENTALS MODULE HEADER 
++++#ifndef _FUNDAMENTALS_H_
++++#define _FUNDAMENTALS_H_
++++
++++#include <stdio.h> 
++++#include <stdlib.h> 
++++#include <string.h>
++++
++++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++++void main(void);
++++
++++#endif
+++\ No newline at end of file
+++
+++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 16:17:34 2022 -0400
+++
+++    Add files via upload
+++    
+++    Version 2
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 65d1c20..417d34a 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,42 +1,80 @@
+++-/*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++-[tokenizing.c] : [tokenizing]
+++-Purpose: [This function takes a user inputted string and tokenizes it]
+++-*/
+++-
+++-
+++-// TOKENIZING MODULE SOURCE
+++-#define _CRT_SECURE_NO_WARNINGS
+++-#define BUFFER_SIZE 300
+++-#include "tokenizing.h"
+++-
+++-// V1
+++-void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char words[BUFFER_SIZE];
+++-    char* nextWord = NULL;
+++-    int wordsCounter;
+++-    do {
+++-        printf("Type a few words seperated by space (q - to quit):\n");
+++-
+++-        fgets(words, BUFFER_SIZE, stdin); 
+++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-        
+++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++-            while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++-            }
+++-        }
+++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-
+++-
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++
++++int main(void) {
++++    tokenizing();
++++    return 0;
++++}
++++
++++
++++/*
++++// V1
++++//void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++       }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++*/
++++
++++
++++// V2
++++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char phrases[BUFFER_SIZE];
++++    char* nextPhrase = NULL;
++++    int phrasesCounter;
++++    do {
++++        printf("Type a few words seperated by comma (q - to quit):\n");
++++
++++        fgets(phrases, BUFFER_SIZE, stdin); 
++++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++++            while (nextPhrase) {
++++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++++            }
++++        }
++++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++diff --git a/tokenizing.h b/tokenizing.h
+++index c00f3cb..7899cc2 100644
+++--- a/tokenizing.h
++++++ b/tokenizing.h
+++@@ -1,10 +1,10 @@
+++-// Tokenization header file
+++-#ifndef _TOKENIZING_H_
+++-#define _TOKENIZING_H_
+++-
+++-#include <stdio.h>
+++-#include <string.h>
+++-
+++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++-
++++// Tokenization header file
++++#ifndef _TOKENIZING_H_
++++#define _TOKENIZING_H_
++++
++++#include <stdio.h>
++++#include <string.h>
++++
++++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++++
+++ #endif
+++\ No newline at end of file
+++
+++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Mon Aug 8 15:47:34 2022 -0400
+++
+++    Version 2
+++    
+++    Version 2
+++
+++diff --git a/converting.c b/converting.c
+++index c5a0775..df23173 100644
+++--- a/converting.c
++++++ b/converting.c
+++@@ -1,6 +1,6 @@
+++ // CONVERTING MODULE SOURCE
+++ /*
+++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+++ converting.c : CONVERTING
+++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++ */
+++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+++ // strings and convert a string to an integer value.
+++ #include "converting.h"
+++ 
+++-// V1
+++ void converting(void) {
++++	// V1
+++ 	// Display beginning message
+++ 	printf("*** Start of Converting Strings to int Demo ***\n");
+++ 
+++@@ -38,6 +38,30 @@ void converting(void) {
+++ 		}
+++ 	} while (strcmp(intString, "q") != 0);
+++ 
+++-	// Display ending message and exit module.
++++	// Display ending message for int demo
+++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++++
++++	// V2
++++	printf("*** Start of Converting Strings to double Demo ***\n");
++++
++++	char	doubleString[BUFFER_SIZE];
++++	double	doubleNumber;
++++
++++	do {
++++		// Prompt user for entry, replacing the new line read by 
++++		// fgets with a null terminator
++++		printf("Type an double numeric string (q - to quit):\n");
++++		fgets(doubleString, BUFFER_SIZE, stdin);
++++		doubleString[strlen(doubleString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.  
++++		if ((strcmp(doubleString, "q") != 0)) {
++++
++++			// Convert user entry from numeric string to a double, then display it
++++			doubleNumber = atof(doubleString);
++++			printf("Converted number is %f\n", doubleNumber);
++++		}
++++	} while (strcmp(doubleString, "q") != 0);
++++
++++	printf("*** End of Converting Strings to double Demo ***\n\n");
+++ }
+++
+++commit e25ade313038da86c407f85f5c00586ba6b37a1b
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Mon Aug 8 15:05:20 2022 -0400
+++
+++    Update README.md
+++
+++diff --git a/README.md b/README.md
+++index 28e7c31..f1ff45d 100644
+++--- a/README.md
++++++ b/README.md
+++@@ -1,5 +1,8 @@
+++ # CPR101_Project
+++ CPR101 Final Project
++++
+++ Section: NAA
++++
+++ Group 1
++++
+++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+++
+++commit a3e1e5ae394af27b186e61562b7167819c90ea13
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Mon Aug 8 15:01:47 2022 -0400
+++
+++    Create README.md
+++
+++diff --git a/README.md b/README.md
+++new file mode 100644
+++index 0000000..28e7c31
+++--- /dev/null
++++++ b/README.md
+++@@ -0,0 +1,5 @@
++++# CPR101_Project
++++CPR101 Final Project
++++Section: NAA
++++Group 1
++++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+++
+++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Mon Aug 8 13:58:05 2022 -0400
+++
+++    Update converting.c
+++    
+++    Version 2
+++
+++diff --git a/converting.c b/converting.c
+++index c5a0775..df23173 100644
+++--- a/converting.c
++++++ b/converting.c
+++@@ -1,6 +1,6 @@
+++ // CONVERTING MODULE SOURCE
+++ /*
+++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+++ converting.c : CONVERTING
+++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++ */
+++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+++ // strings and convert a string to an integer value.
+++ #include "converting.h"
+++ 
+++-// V1
+++ void converting(void) {
++++	// V1
+++ 	// Display beginning message
+++ 	printf("*** Start of Converting Strings to int Demo ***\n");
+++ 
+++@@ -38,6 +38,30 @@ void converting(void) {
+++ 		}
+++ 	} while (strcmp(intString, "q") != 0);
+++ 
+++-	// Display ending message and exit module.
++++	// Display ending message for int demo
+++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++++
++++	// V2
++++	printf("*** Start of Converting Strings to double Demo ***\n");
++++
++++	char	doubleString[BUFFER_SIZE];
++++	double	doubleNumber;
++++
++++	do {
++++		// Prompt user for entry, replacing the new line read by 
++++		// fgets with a null terminator
++++		printf("Type an double numeric string (q - to quit):\n");
++++		fgets(doubleString, BUFFER_SIZE, stdin);
++++		doubleString[strlen(doubleString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.  
++++		if ((strcmp(doubleString, "q") != 0)) {
++++
++++			// Convert user entry from numeric string to a double, then display it
++++			doubleNumber = atof(doubleString);
++++			printf("Converted number is %f\n", doubleNumber);
++++		}
++++	} while (strcmp(doubleString, "q") != 0);
++++
++++	printf("*** End of Converting Strings to double Demo ***\n\n");
+++ }
+++
+++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Mon Aug 8 13:43:58 2022 -0400
+++
+++    Update manipulating.c
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 953e516..9193243 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -41,7 +41,7 @@ void manipulating(void) {
+++ 	do {
+++ 		printf("Type the 1st string to compare (q - to quit):\n");
+++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++ 			printf("Type the 2nd string to compare:\n");
+++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++
+++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Mon Aug 8 12:51:35 2022 -0400
+++
+++    Version 2
+++    
+++    Updated main for version 2
+++
+++diff --git a/main.c b/main.c
+++index 755b397..70aeeb7 100644
+++--- a/main.c
++++++ b/main.c
+++@@ -1,6 +1,6 @@
+++ // MAIN 
+++ /*
+++-Author: BB01, 03/08/2022, CPR101, Final Project V1
++++Author: BB01, 03/08/2022, CPR101, Final Project
+++ main.c : MAIN
+++ Purpose: Main Function used to prompt user for which various options.
+++ */
+++
+++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+++Author: kiararina <kiararina.pelenio@upou.edu.ph>
+++Date:   Mon Aug 8 09:38:48 2022 -0500
+++
+++    Version 2
+++    
+++    Added version 2 codes
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 9bde2d2..953e516 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+++ manipulating.c : Manipulating
+++ Purpose: This program manipulates input strings
+++ */
+++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+++ #include "manipulating.h" 
+++ /* Contains function prototypes and library declarations */
+++ 
++++// V1
+++ void manipulating(void) {
+++ /* Purpose: This function concatenates 2 input strings */
+++ 
+++@@ -19,16 +20,40 @@ void manipulating(void) {
+++ 
+++ 	do {
+++ 		printf("Type the 1st string (q - to quit):\n");
+++-		fgets(string1, BUFFER_SIZE, stdin);
+++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+++ 
+++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++ 			printf("Type the 2nd string:\n");
+++-			fgets(string2, BUFFER_SIZE, stdin);
++++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++ 			strcat(string1, string2);
+++ 			printf("Concatenated string is \'%s\'\n", string1);
+++ 		}
+++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++ 
+++ 	printf("*** End of Concatenating Strings Demo ***\n");
++++
++++//V2
++++	printf("*** Start of Comparing Strings Demo ***\n");
++++	char compare1[BUFFER_SIZE];
++++	char compare2[BUFFER_SIZE];
++++	int result;
++++	do {
++++		printf("Type the 1st string to compare (q - to quit):\n");
++++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++++			printf("Type the 2nd string to compare:\n");
++++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++++			if (result < 0)
++++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++++			else if (result == 0)
++++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++++			else
++++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++++		}
++++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++++	printf("*** End of Comparing Strings Demo ***\n\n");
+++ }
+++\ No newline at end of file
+++
+++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+++Author: kiararina <kiararina.pelenio@upou.edu.ph>
+++Date:   Thu Aug 4 15:34:34 2022 -0500
+++
+++    Update manipulating.c
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 748c895..9bde2d2 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++ manipulating.c : Manipulating
+++ Purpose: This program manipulates input strings
+++ */
+++
+++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Thu Aug 4 16:30:00 2022 -0400
+++
+++    Version 1
+++
+++diff --git a/Programming Comments.docx b/Programming Comments.docx
+++new file mode 100644
+++index 0000000..07d1cd7
+++--- /dev/null
++++++ b/Programming Comments.docx	
+++@@ -0,0 +1,110 @@
++++                        Commenting Program Source Code
++++--------------------------------------------------------------------------------
++++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++++--------------------------------------------------------------------------------
++++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++++Comments are for programmers who will maintain the code in the future. 
++++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++++--------------------------------------------------------------------------------
++++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++++--------------------------------------------------------------------------------
++++
++++Organisation of Comments
++++Program comments 
++++ -  appear at the beginning of a source file.
++++/* 
++++Author: Name, email, ID, Date written, Course, Project
++++[executable filename] : [title of program]
++++Purpose: [what this program does, what problem does it solve?]
++++*/
++++
++++Function comments
++++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++++/*
++++Purpose: [what this function does, what problem does it solve?]
++++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++++*/
++++
++++Inline code comments
++++Your comment must say something different than explaining the code itself. 
++++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++++c = a + b;  // c stores total of assignment and test marks respectively.
++++
++++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++++cryptic = C + code; 		// explain this line's purpose in the program
++++crypticly = C + moreCode;	// explain this line's purpose in the program
++++
++++Longer code comments
++++Sometimes comments need more space than would fit inline. 
++++cryptic = C + code;
++++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++++moreCrypticly = C + moreCode;	
++++
++++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++++// this comment explains the purpose of the next line of code  
++++cryptic = C + code;
++++ 		
++++// this comment explains the purpose of the next line of code  
++++moreCrypticly = C + moreCode;	
++++		
++++
++++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++++
++++Structures
++++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++++// [what the structure accomplishes]
++++e.g. 
++++// compute factorial	
++++// prompt user until value within range 1  -  100 is input
++++Code Samples
++++printf("Type a few words separated by space(q - to quit):\n");
++++gets(words);
++++while (strcmp(words, "q") != 0) 
++++{
++++    word = strtok(words, " ");
++++    w_counter = 1;
++++    while (word) 
++++    {
++++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++++        word = strtok(NULL, " ");
++++    }
++++    printf("Type a few words separated by space(q - to quit):\n");
++++    gets(words);
++++}
++++
++++ the first while continues until the 'words' variable is equal to "q". What is it for?
++++ there is another while {structure} ... what does it do?
++++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++++ // keep looping until pointer is NULL
++++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++++ This technique is even more important at the end of a series nested structures, e.g.
++++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++++
++++
++++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++++
++++while (TRUE) // a comment explains why there is no exit condition here
++++{
++++ 	. . .
++++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++++. . .
++++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++++   // --------- *****      make it visually obvious that this is an exit from the structure
++++. . .
++++}
+++diff --git a/converting.c b/converting.c
+++new file mode 100644
+++index 0000000..c5a0775
+++--- /dev/null
++++++ b/converting.c
+++@@ -0,0 +1,43 @@
++++// CONVERTING MODULE SOURCE
++++/*
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++converting.c : CONVERTING
++++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++++*/
++++
++++#define	_CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 80
++++
++++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++++// strings and convert a string to an integer value.
++++#include "converting.h"
++++
++++// V1
++++void converting(void) {
++++	// Display beginning message
++++	printf("*** Start of Converting Strings to int Demo ***\n");
++++
++++	// Declare variables
++++	char	intString[BUFFER_SIZE];
++++	int		intNumber;
++++
++++	do {
++++		// Prompt user for entry
++++		printf("Type an int numeric string (q - to quit):\n");
++++		fgets(intString, BUFFER_SIZE, stdin);
++++		intString[strlen(intString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.
++++		if (strcmp(intString, "q") != 0) {
++++
++++			// Convert user entry from string to integer value.
++++			intNumber = atoi(intString);
++++
++++			// Display converted number.
++++			printf("Converted number is %d\n", intNumber);
++++		}
++++	} while (strcmp(intString, "q") != 0);
++++
++++	// Display ending message and exit module.
++++	printf("*** End of Converting Strings to int Demo ***\n\n");
++++}
+++diff --git a/converting.h b/converting.h
+++new file mode 100644
+++index 0000000..03c62a3
+++--- /dev/null
++++++ b/converting.h
+++@@ -0,0 +1,18 @@
++++// CONVERTING MODULE HEADER
++++#ifndef _CONVERTING_H_
++++#define _CONVERTING_H_
++++
++++// Libraries
++++#include <stdio.h>
++++#include <string.h>
++++#include <stdlib.h>
++++
++++
++++/////////////////////////
++++// Prototype  Function //
++++/////////////////////////
++++
++++// Function used to apply conversions
++++void converting(void);
++++
++++#endif
+++diff --git a/fundamentals.c b/fundamentals.c
+++new file mode 100644
+++index 0000000..95c9f23
+++--- /dev/null
++++++ b/fundamentals.c
+++@@ -0,0 +1,43 @@
++++/*
++++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++++fundamentals.c : indexing
++++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++++*/
++++
++++
++++// FUNDAMENTALS MODULE SOURCE 
++++#define _CRT_SECURE_NO_WARNINGS 
++++#define BUFFER_SIZE 80
++++#define NUM_INPUT_SIZE 10 
++++#include "fundamentals.h"
++++
++++
++++void fundamentals(void) {
++++
++++// V1
++++    printf("*** start of Indexing Strings Demo ***\n"); 
++++    char buffer1[BUFFER_SIZE]; 
++++    char numInput[NUM_INPUT_SIZE]; 
++++    size_t position; 
++++    do {
++++        printf("Type not empty string (q - to quit): \n"); 
++++        fgets (buffer1, BUFFER_SIZE, stdin); 
++++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp (buffer1, "q") != 0) { 
++++            printf("Type the character position within the string: \n"); 
++++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++++            position = atoi (numInput); // Converts entered string to integer.
++++
++++            // Checks if converted integer is larger then string length and assigns max position if true.
++++            if (position >= strlen (buffer1)) { 
++++                position = strlen (buffer1) - 1; 
++++                printf("Too big... Position reduced to max. availbale\n");
++++            }
++++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++++        }
++++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++++    printf("*** End of Indexing Strings Demo ***\n\n");
++++}
+++\ No newline at end of file
+++diff --git a/fundamentals.h b/fundamentals.h
+++new file mode 100644
+++index 0000000..0433660
+++--- /dev/null
++++++ b/fundamentals.h
+++@@ -0,0 +1,12 @@
++++// FUNDAMENTALS MODULE HEADER 
++++#ifndef _FUNDAMENTALS_H_
++++#define _FUNDAMENTALS_H_
++++
++++#include <stdio.h> 
++++#include <stdlib.h> 
++++#include <string.h>
++++
++++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++++void fundamentals(void);
++++
++++#endif
+++\ No newline at end of file
+++diff --git a/main.c b/main.c
+++new file mode 100644
+++index 0000000..755b397
+++--- /dev/null
++++++ b/main.c
+++@@ -0,0 +1,58 @@
++++// MAIN 
++++/*
++++Author: BB01, 03/08/2022, CPR101, Final Project V1
++++main.c : MAIN
++++Purpose: Main Function used to prompt user for which various options.
++++*/
++++
++++// Include all necessary modules
++++#define _CRT_SECURE_NO_WARNINGS
++++#include "fundamentals.h"
++++#include "manipulating.h"
++++#include "converting.h"
++++#include "tokenizing.h"
++++
++++int main(void) {
++++	// Declare variables
++++	char buff[10];
++++
++++	// Open menu for user
++++	do {
++++		// Display menu options
++++		printf("1 - Fundamentals\n");
++++		printf("2 - Manipulation\n");
++++		printf("3 - Converting\n");
++++		printf("4 - Tokenizing\n");
++++		printf("0 - Exit\n");
++++		
++++		// Prompt user for input
++++		printf("Which module to run? \n");
++++		fgets(buff, 10, stdin);
++++
++++		// Analyze user entry and match selection
++++		switch (buff[0])
++++		{
++++		case '1': 
++++			// Call for fundamentals module
++++			fundamentals();
++++			break;
++++
++++		case '2': 
++++			// Call for manipulating module
++++			manipulating();
++++			break;
++++
++++		case '3': 
++++			// Call for converting module
++++			converting();
++++			break;
++++
++++		case '4': 
++++			// Call for tokenizing module
++++			tokenizing();
++++			break;
++++		}
++++	} while (buff[0] != '0');
++++	
++++	return 0;
++++}
+++\ No newline at end of file
+++diff --git a/manipulating.c b/manipulating.c
+++new file mode 100644
+++index 0000000..748c895
+++--- /dev/null
++++++ b/manipulating.c
+++@@ -0,0 +1,34 @@
++++/*
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++++manipulating.c : Manipulating
++++Purpose: This program manipulates input strings
++++*/
++++
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 80
++++
++++#include "manipulating.h" 
++++/* Contains function prototypes and library declarations */
++++
++++void manipulating(void) {
++++/* Purpose: This function concatenates 2 input strings */
++++
++++	printf("*** Start of Concatenating Strings Demo ***\n");
++++	char string1[BUFFER_SIZE];
++++	char string2[BUFFER_SIZE];
++++
++++	do {
++++		printf("Type the 1st string (q - to quit):\n");
++++		fgets(string1, BUFFER_SIZE, stdin);
++++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++++
++++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++++			printf("Type the 2nd string:\n");
++++			fgets(string2, BUFFER_SIZE, stdin);
++++			strcat(string1, string2);
++++			printf("Concatenated string is \'%s\'\n", string1);
++++		}
++++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++++
++++	printf("*** End of Concatenating Strings Demo ***\n");
++++}
+++\ No newline at end of file
+++diff --git a/manipulating.h b/manipulating.h
+++new file mode 100644
+++index 0000000..8a8f926
+++--- /dev/null
++++++ b/manipulating.h
+++@@ -0,0 +1,11 @@
++++//MANIPULATING MODULE HEADER
++++#ifndef _MANIPULATING_H_
++++#define _MANIPULATING_H_
++++
++++#include <stdio.h>		// For input/output and printing
++++#include <string.h>		// For string manipulation functions
++++
++++void manipulating(void);
++++/* Purpose: This function concatenates 2 input strings */
++++
++++#endif
+++diff --git a/tokenizing.c b/tokenizing.c
+++new file mode 100644
+++index 0000000..65d1c20
+++--- /dev/null
++++++ b/tokenizing.c
+++@@ -0,0 +1,42 @@
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++// V1
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++        
++++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++        }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++diff --git a/tokenizing.h b/tokenizing.h
+++new file mode 100644
+++index 0000000..c00f3cb
+++--- /dev/null
++++++ b/tokenizing.h
+++@@ -0,0 +1,10 @@
++++// Tokenization header file
++++#ifndef _TOKENIZING_H_
++++#define _TOKENIZING_H_
++++
++++#include <stdio.h>
++++#include <string.h>
++++
++++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++++
++++#endif
+++\ No newline at end of file
+++
+++commit f914d3afae4107c77728b3df4d39502c962ba74b
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Thu Aug 4 15:48:50 2022 -0400
+++
+++    Initial commit
+++
+++diff --git a/.gitattributes b/.gitattributes
+++new file mode 100644
+++index 0000000..dfe0770
+++--- /dev/null
++++++ b/.gitattributes
+++@@ -0,0 +1,2 @@
++++# Auto detect text files and perform LF normalization
++++* text=auto
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
+
+commit e14f5c429efccb7dc63749da2a425659ad905631
+Author: krpm <25734153+kiararina@users.noreply.github.com>
+Date:   Fri Aug 12 08:37:11 2022 -0400
+
+    Update manipulating.c for version 3.
+    
+    Added a section for checking the occurrence of 2nd string in 1st string.
+
+diff --git a/manipulating.c b/manipulating.c
+index 9193243..925e182 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
+ 
+ // V1
+ void manipulating(void) {
+-/* Purpose: This function concatenates 2 input strings */
++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
+ 
+ 	printf("*** Start of Concatenating Strings Demo ***\n");
+ 	char string1[BUFFER_SIZE];
+@@ -56,4 +56,27 @@ void manipulating(void) {
+ 		}
+ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+ 	printf("*** End of Comparing Strings Demo ***\n\n");
++
++
++//V3
++	printf("*** Start of Searching Strings Demo ***\n");
++	char haystack[BUFFER_SIZE];
++	char needle[BUFFER_SIZE];
++	char* occurence = NULL;
++	do {
++		printf("Type the string (q - to quit):\n");
++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
++			printf("Type the substring:\n");
++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
++			if (occurence)							// If found, return the position where 2nd string occurs
++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
++			else						
++				printf("Not found\n");				
++		}
++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Searching Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 23:04:40 2022 -0400
+
+    Adding git logs
+    
+    Version 2 Git Logs
+    $ git --no-pager log -p > "module-git-log.txt"
+
+diff --git a/converting-git-log.txt b/converting-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/converting-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/fundamentals-git-log.txt b/fundamentals-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/fundamentals-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/main-git-log.txt b/main-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/main-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/manipulating-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/tokenizing-git-log.txt b/tokenizing-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/tokenizing-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+
 commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
 Merge: 6361388 c3a8316
 Author: rsaguros <rsaguros1@myseneca.ca>
@@ -904,9 +9527,9 @@ index 0000000..07d1cd7
 +Comments are for programmers who will maintain the code in the future. 
 +Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
 +Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
-+---------------------------------------------------------------------------------
++--------------------------------------------------------------------------------
 +Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
-+---------------------------------------------------------------------------------
++--------------------------------------------------------------------------------
 +
 +Organisation of Comments
 +Program comments 

commit b4865c3d183df4dfc091ff317cba85a88d517427
Author: jt-tn <jasontn91@gmail.com>
Date:   Sun Aug 14 22:17:40 2022 -0400

    tokenizing v3 fixed

diff --git a/tokenizing-git-log.txt b/tokenizing-git-log.txt
index 7bb5209..ce553d5 100644
--- a/tokenizing-git-log.txt
+++ b/tokenizing-git-log.txt
@@ -904,9 +904,9 @@ index 0000000..07d1cd7
 +Comments are for programmers who will maintain the code in the future. 
 +Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
 +Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
-+--------------------------------------------------------------------------------
++---------------------------------------------------------------------------------
 +Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
-+--------------------------------------------------------------------------------
++---------------------------------------------------------------------------------
 +
 +Organisation of Comments
 +Program comments 

commit 60104917117433e20ca827187dc59aab415f242e
Merge: 81d2c67 ddf5966
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Sun Aug 14 21:56:48 2022 -0400

    Merge pull request #10 from kiararina/tokenizing_v3
    
    Updating tokenizing.c

commit ddf5966bcc817b43a1b2fecb08c4ff09df54a6d4
Author: jt-tn <jasontn91@gmail.com>
Date:   Sun Aug 14 18:04:01 2022 -0400

    Update tokenizing.c

diff --git a/tokenizing.c b/tokenizing.c
index f5beb9e..1b84ae4 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -50,7 +50,7 @@ void tokenizing(void) {
     do {
         printf("Type a few words seperated by comma (q - to quit):\n");
 
-        fgets(phrases, BUFFER_SIZE, stdin); 
+        fgets(phrases, BUFFER_SIZE, stdin);
         phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
 
         if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
@@ -59,7 +59,7 @@ void tokenizing(void) {
 
     //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of phrases being tokenized 
             while (nextPhrase) {
-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+                printf("Phrase #%d is \'%s\'\n", phrasesCounter++, nextPhrase);
                 nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
             }
         }
@@ -71,28 +71,28 @@ void tokenizing(void) {
 
 
     // V3
-    /* Delimiter is now a single period (".") */
+    /* Delimiter is now a single dot (".") */
     printf("*** Start of Tokenizing Sentences Demo ***\n");
     char sentences[BUFFER_SIZE];
     char* nextSentence = NULL;
     int sentencesCounter;
     do {
-        printf("Type a few words seperated by comma (q - to quit):\n");
+        printf("Type a few words seperated by dot (q - to quit):\n");
 
-        fgets(sentences, BUFFER_SIZE, stdin); 
+        fgets(sentences, BUFFER_SIZE, stdin);
         sentences[strlen(sentences) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
 
         if ((strcmp(sentences, "q") != 0)) { // only executes if user did not input 'q'
-            nextSentence = strtok(sentences, "."); // use a period as the delimiter to know when to split the string into tokens
+            nextSentence = strtok(sentences, "."); // use a dot as the delimiter to know when to split the string into tokens
             sentencesCounter = 1; // intialize sentencesCounter to 1, and start counting from 1 to keep track of how many sentences are being tokenized
 
     //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of sentences being tokenized 
             while (nextSentence) {
-                printf("Word #%d is \'%s\'\n", sentencesCounter++, nextSentence); 
+                printf("Sentence #%d is \'%s\'\n", sentencesCounter++, nextSentence);
                 nextSentence = strtok(NULL, "."); // when the next value of the string reads as null, we break out of the loop
             }
         }
-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+    } while (strcmp(sentences, "q") != 0); // breaks the loop if user inputs 'q' as the only character
 
     printf("*** End of Tokenizing Sentences Demo ***\n\n");
 

commit 81d2c67287c19da8ef64349fb1284e21fb32f81b
Merge: b4d18c0 7c7bb4e
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Sun Aug 14 15:35:21 2022 -0400

    Merge pull request #9 from kiararina/CRYPTO43-patch-2
    
    V3

commit 7c7bb4e1ce7dbbb736e80279677f81cde56fee83
Author: CRYPTO43 <76517672+CRYPTO43@users.noreply.github.com>
Date:   Sun Aug 14 15:32:57 2022 -0400

    V3

diff --git a/fundamentals-git-log.txt b/fundamentals-git-log.txt
index 7bb5209..38b0cb6 100644
Binary files a/fundamentals-git-log.txt and b/fundamentals-git-log.txt differ
diff --git a/fundamentals.c b/fundamentals.c
index 7aeadfe..e3f533c 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -1,57 +1,85 @@
-/*
-Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
-fundamentals.c : indexing
-Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
-*/
-
-
-// FUNDAMENTALS MODULE SOURCE 
-#define _CRT_SECURE_NO_WARNINGS 
-#define BUFFER_SIZE 80
-#define NUM_INPUT_SIZE 10 
-#include "fundamentals.h"
-
-void fundamentals(void) {
-// V1
-    printf("*** start of Indexing Strings Demo ***\n"); 
-    char buffer1[BUFFER_SIZE]; 
-    char numInput[NUM_INPUT_SIZE]; 
-    size_t position; 
-    do {
-        printf("Type not empty string (q - to quit): \n"); 
-        fgets (buffer1, BUFFER_SIZE, stdin); 
-        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
-
-        // checks if entered string is not equals to 'q'.
-        if (strcmp (buffer1, "q") != 0) { 
-            printf("Type the character position within the string: \n"); 
-            fgets (numInput, NUM_INPUT_SIZE, stdin); 
-            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
-            position = atoi (numInput); // Converts entered string to integer.
-
-            // Checks if converted integer is larger then string length and assigns max position if true.
-            if (position >= strlen (buffer1)) { 
-                position = strlen (buffer1) - 1; 
-                printf("Too big... Position reduced to max. availbale\n");
-            }
-            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
-        }
-    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
-    printf("*** End of Indexing Strings Demo ***\n\n");
-
-    // V2 
-    printf("*** Start of Measuring Strings Demo ***\n"); 
-    char buffer2[BUFFER_SIZE]; 
-    do { 
-        printf("Type a string (q - to quit):\n"); 
-        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
-        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
-
-        // checks if entered string is not equals to 'q'.
-        if (strcmp(buffer2, "q") != 0) 
-            printf("The length of \'%s\' is %d characters\n", 
-            buffer2, (int)strlen(buffer2)); 
-        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
-        
-        printf("*** End of Measuring Strings Demo ***\n\n");
+/*
+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+fundamentals.c : indexing
+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+*/
+
+
+// FUNDAMENTALS MODULE SOURCE 
+#define _CRT_SECURE_NO_WARNINGS 
+#define BUFFER_SIZE 80
+#define NUM_INPUT_SIZE 10 
+#include "fundamentals.h"
+
+void fundamentals(void) {
+// V1
+    printf("*** start of Indexing Strings Demo ***\n"); 
+    char buffer1[BUFFER_SIZE]; 
+    char numInput[NUM_INPUT_SIZE]; 
+    size_t position; 
+    do {
+        printf("Type not empty string (q - to quit): \n"); 
+        fgets (buffer1, BUFFER_SIZE, stdin); 
+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+
+        // checks if entered string is not equals to 'q'.
+        if (strcmp (buffer1, "q") != 0) { 
+            printf("Type the character position within the string: \n"); 
+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+            position = atoi (numInput); // Converts entered string to integer.
+
+            // Checks if converted integer is larger then string length and assigns max position if true.
+            if (position >= strlen (buffer1)) { 
+                position = strlen (buffer1) - 1; 
+                printf("Too big... Position reduced to max. availbale\n");
+            }
+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+        }
+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+    printf("*** End of Indexing Strings Demo ***\n\n");
+
+    // V2 
+    printf("*** Start of Measuring Strings Demo ***\n"); 
+    char buffer2[BUFFER_SIZE]; 
+    do { 
+        printf("Type a string (q - to quit):\n"); 
+        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+
+        // checks if entered string is not equals to 'q'.
+        if (strcmp(buffer2, "q") != 0) {
+            printf("The length of \'%s\' is %d characters\n", 
+            buffer2, (int)strlen(buffer2)); 
+        }
+    } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+    printf("*** End of Measuring Strings Demo ***\n\n");
+
+
+    
+    //V3
+    printf("*** start of copying Strings Demo ***\n"); 
+    char destination [BUFFER_SIZE]; 
+    char source[BUFFER_SIZE]; 
+    do {
+
+        //Replaces first element of destination with null terminator
+        destination [0] = '\0'; 
+
+        printf("Destination string is reset to empty\n"); 
+        printf("Type the source string (q - to quit): \n"); 
+        fgets (source, BUFFER_SIZE, stdin);
+
+        //Replaces user entered new line with null terminator
+        source[strlen (source) - 1] = '\0'; 
+
+        if (strcmp (source, "q") != 0) {
+
+            //copies string from source to destination
+            strcpy (destination, source); 
+            printf("New destination string is \'%s\'\n", destination);
+        }
+        //loops till user enter q
+    } while (strcmp (source, "q") != 0); 
+    printf("*** End of copying Strings Demo ***\n\n");
 }
\ No newline at end of file
diff --git a/fundamentals.h b/fundamentals.h
index 0433660..6b2f92f 100644
--- a/fundamentals.h
+++ b/fundamentals.h
@@ -1,12 +1,14 @@
-// FUNDAMENTALS MODULE HEADER 
-#ifndef _FUNDAMENTALS_H_
-#define _FUNDAMENTALS_H_
-
-#include <stdio.h> 
-#include <stdlib.h> 
-#include <string.h>
-
-//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
-void fundamentals(void);
-
+// FUNDAMENTALS MODULE HEADER 
+#ifndef _FUNDAMENTALS_H_
+#define _FUNDAMENTALS_H_
+
+#include <stdio.h> 
+#include <stdlib.h> 
+#include <string.h>
+
+//V1  Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+//V2  Takes non-empty string and gives the number of characters as output
+//V3  Takes non-empty string and copies it to a new string 
+void fundamentals(void);
+
 #endif
\ No newline at end of file

commit b4d18c0fdb4038e7ed6544527174b8ac019ab37c
Merge: e2321eb b8d767f
Author: kiararina <25734153+kiararina@users.noreply.github.com>
Date:   Sat Aug 13 10:09:24 2022 -0400

    Merge pull request #3 from kiararina/converting_v3
    
    Converting v3

commit e2321ebd7b32813cfb391a8f9c9e7bc66aabb7dd
Merge: ade6151 7e2fb09
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Fri Aug 12 15:13:51 2022 -0400

    Merge pull request #4 from kiararina/tokenizing_v3
    
    Tokenizing v3

commit 7e2fb09bfa9e3c6a5415ac9669fd212cbc7b0af7
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Fri Aug 12 14:22:38 2022 -0400

    tokenizing.c v3

diff --git a/tokenizing.c b/tokenizing.c
index 67fa08e..f5beb9e 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -5,7 +5,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
 */
 
 
-// TOKENIZING MODULE SOURCE
+//TOKENIZING MODULE SOURCE
 #define _CRT_SECURE_NO_WARNINGS
 #define BUFFER_SIZE 300
 #include "tokenizing.h"

commit dd246d275a3b9a1fd1be0609a5a726db8381abde
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Fri Aug 12 14:21:36 2022 -0400

    Update tokenizing.c

diff --git a/tokenizing.c b/tokenizing.c
index ae26066..67fa08e 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,5 +1,5 @@
 /*
-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 11/08/2022, CPR101, Final Project V3
 [tokenizing.c] : [tokenizing]
 Purpose: [This function takes a user inputted string and tokenizes it]
 */
@@ -11,7 +11,6 @@ Purpose: [This function takes a user inputted string and tokenizes it]
 #include "tokenizing.h"
 
 
-
 void tokenizing(void) {
 
     // V1
@@ -40,9 +39,11 @@ void tokenizing(void) {
     printf("*** End of Tokenizing Words Demo ***\n\n");
 
 
+
+
     // V2
     /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-    printf("*** Start of Tokenizing Words Demo ***\n");
+    printf("*** Start of Tokenizing Phrases Demo ***\n");
     char phrases[BUFFER_SIZE];
     char* nextPhrase = NULL;
     int phrasesCounter;
@@ -56,7 +57,7 @@ void tokenizing(void) {
             nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
             phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
 
-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of phrases being tokenized 
             while (nextPhrase) {
                 printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
                 nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
@@ -64,7 +65,41 @@ void tokenizing(void) {
         }
     } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
 
-    printf("*** End of Tokenizing Words Demo ***\n\n");
+    printf("*** End of Tokenizing Phrases Demo ***\n\n");
+
+
+
+
+    // V3
+    /* Delimiter is now a single period (".") */
+    printf("*** Start of Tokenizing Sentences Demo ***\n");
+    char sentences[BUFFER_SIZE];
+    char* nextSentence = NULL;
+    int sentencesCounter;
+    do {
+        printf("Type a few words seperated by comma (q - to quit):\n");
+
+        fgets(sentences, BUFFER_SIZE, stdin); 
+        sentences[strlen(sentences) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+
+        if ((strcmp(sentences, "q") != 0)) { // only executes if user did not input 'q'
+            nextSentence = strtok(sentences, "."); // use a period as the delimiter to know when to split the string into tokens
+            sentencesCounter = 1; // intialize sentencesCounter to 1, and start counting from 1 to keep track of how many sentences are being tokenized
+
+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of sentences being tokenized 
+            while (nextSentence) {
+                printf("Word #%d is \'%s\'\n", sentencesCounter++, nextSentence); 
+                nextSentence = strtok(NULL, "."); // when the next value of the string reads as null, we break out of the loop
+            }
+        }
+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+
+    printf("*** End of Tokenizing Sentences Demo ***\n\n");
+
+
+
+
+
 }
 
 

commit b8d767f3b6d0c407835d0c65df3b8a41ed9505d6
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Fri Aug 12 14:19:12 2022 -0400

    Updating to version 3.

diff --git a/converting-git-log.txt b/converting-git-log.txt
index 7bb5209..b4de4b0 100644
--- a/converting-git-log.txt
+++ b/converting-git-log.txt
@@ -1,3 +1,12704 @@
+commit 285c5525d1092e24bd2bd8735f5ff1b8012d6be9
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Fri Aug 12 14:15:57 2022 -0400
+
+    Renaming to keep consistent with other files.
+    
+    Changed _ to - to be consistent with the other git logs.  Replaced old one with new.
+
+diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
+index 7bb5209..05aa537 100644
+--- a/manipulating-git-log.txt
++++ b/manipulating-git-log.txt
+@@ -1,748 +1,1414 @@
+-commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+-Merge: 6361388 c3a8316
+-Author: rsaguros <rsaguros1@myseneca.ca>
+-Date:   Tue Aug 9 22:49:17 2022 -0400
+-
+-    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+-
+-commit 63613886b8f1ecccb62538d6d4b7905425a16358
+-Merge: 0626d2e c0f7dc8
+-Author: rsaguros <rsaguros1@myseneca.ca>
+-Date:   Tue Aug 9 22:47:37 2022 -0400
+-
+-    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++commit e14f5c429efccb7dc63749da2a425659ad905631
++Author: krpm <25734153+kiararina@users.noreply.github.com>
++Date:   Fri Aug 12 08:37:11 2022 -0400
+ 
+-commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+-Merge: 9d98950 c0f7dc8
+-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-Date:   Tue Aug 9 22:46:28 2022 -0400
+-
+-    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+-
+-commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+-Merge: fd97b97 a2a1bf4
+-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-Date:   Tue Aug 9 22:44:47 2022 -0400
+-
+-    Merge pull request #1 from kiararina/converting
++    Update manipulating.c for version 3.
+     
+-    Recovering lost commits up to converting.c
+-
+-commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+-Merge: cee497d fd97b97
+-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-Date:   Tue Aug 9 22:44:00 2022 -0400
+-
+-    Merge branch 'main' into converting
++    Added a section for checking the occurrence of 2nd string in 1st string.
+ 
+-commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-Date:   Tue Aug 9 19:23:44 2022 -0400
+-
+-    tokenizing.c v2 corrected
+-    
+-    Corrected a previous error, now both v1 and v2 are within the same function name
+-
+-diff --git a/tokenizing.c b/tokenizing.c
+-index 6332b6d..ae26066 100644
+---- a/tokenizing.c
+-+++ b/tokenizing.c
+-@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+- 
+- 
+- 
+-+void tokenizing(void) {
+- 
+--/*
+--// V1
+--//void tokenizing(void) {
+--
+-+    // V1
+-     printf("*** Start of Tokenizing Words Demo ***\n");
+-     char words[BUFFER_SIZE];
+-     char* nextWord = NULL;
+-@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+-     do {
+-         printf("Type a few words seperated by space (q - to quit):\n");
+- 
+--        fgets(words, BUFFER_SIZE, stdin); 
+-+        fgets(words, BUFFER_SIZE, stdin);
+-         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+- 
+-         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+- 
+-     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-             while (nextWord) {
+--                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+-                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-             }
+--       }
+-+        }
+-     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+- 
+-     printf("*** End of Tokenizing Words Demo ***\n\n");
+--}
+--*/
+- 
+- 
+--// V2
+--/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+--void tokenizing(void) {
+--
+-+    // V2
+-+    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-     printf("*** Start of Tokenizing Words Demo ***\n");
+-     char phrases[BUFFER_SIZE];
+-     char* nextPhrase = NULL;
+-
+-commit 23f162166b815502c16ac1456d8f9be87b799f26
+-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-Date:   Tue Aug 9 19:09:02 2022 -0400
+-
+-    Update tokenizing.c to V2
+-
+-diff --git a/tokenizing.c b/tokenizing.c
+-index edc3184..6332b6d 100644
+---- a/tokenizing.c
+-+++ b/tokenizing.c
+-@@ -1,5 +1,5 @@
+- /*
+--Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+- [tokenizing.c] : [tokenizing]
+- Purpose: [This function takes a user inputted string and tokenizes it]
+- */
+-@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+- #include "tokenizing.h"
+- 
+- 
+--int main(void) {
+--    tokenizing();
+--    return 0;
+--}
+- 
++diff --git a/manipulating.c b/manipulating.c
++index 9193243..925e182 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
+  
+-+/*
+  // V1
+--void tokenizing(void) {
+-+//void tokenizing(void) {
+- 
+-     printf("*** Start of Tokenizing Words Demo ***\n");
+-     char words[BUFFER_SIZE];
+-@@ -34,16 +31,46 @@ void tokenizing(void) {
+-             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+- 
+--        
+--    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-+    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-             while (nextWord) {
+-                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-             }
+--        }
+-+       }
+-     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+- 
+-     printf("*** End of Tokenizing Words Demo ***\n\n");
+- }
+-+*/
+-+
+-+
+-+// V2
+-+/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-+void tokenizing(void) {
+-+
+-+    printf("*** Start of Tokenizing Words Demo ***\n");
+-+    char phrases[BUFFER_SIZE];
+-+    char* nextPhrase = NULL;
+-+    int phrasesCounter;
+-+    do {
+-+        printf("Type a few words seperated by comma (q - to quit):\n");
+-+
+-+        fgets(phrases, BUFFER_SIZE, stdin); 
+-+        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+
+-+        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-+            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-+            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+
+-+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-+            while (nextPhrase) {
+-+                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-+                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-+            }
+-+        }
+-+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+
+-+    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+}
+- 
+- 
+-
+-commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-Date:   Tue Aug 9 19:06:55 2022 -0400
+-
+-    V1
+-
+-diff --git a/tokenizing.c b/tokenizing.c
+-index 417d34a..edc3184 100644
+---- a/tokenizing.c
+-+++ b/tokenizing.c
+-@@ -1,80 +1,49 @@
+--/*
+--Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+--[tokenizing.c] : [tokenizing]
+--Purpose: [This function takes a user inputted string and tokenizes it]
+--*/
+--
+--
+--// TOKENIZING MODULE SOURCE
+--#define _CRT_SECURE_NO_WARNINGS
+--#define BUFFER_SIZE 300
+--#include "tokenizing.h"
+--
+--
+--int main(void) {
+--    tokenizing();
+--    return 0;
+--}
+--
+--
+--/*
+--// V1
+--//void tokenizing(void) {
+--
+--    printf("*** Start of Tokenizing Words Demo ***\n");
+--    char words[BUFFER_SIZE];
+--    char* nextWord = NULL;
+--    int wordsCounter;
+--    do {
+--        printf("Type a few words seperated by space (q - to quit):\n");
+--
+--        fgets(words, BUFFER_SIZE, stdin); 
+--        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+--
+--        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+--            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+--            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+--
+--    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+--            while (nextWord) {
+--                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+--                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+--            }
+--       }
+--    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+--
+--    printf("*** End of Tokenizing Words Demo ***\n\n");
+--}
+--*/
+--
+--
+--// V2
+--/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+--void tokenizing(void) {
+--
+--    printf("*** Start of Tokenizing Words Demo ***\n");
+--    char phrases[BUFFER_SIZE];
+--    char* nextPhrase = NULL;
+--    int phrasesCounter;
+--    do {
+--        printf("Type a few words seperated by comma (q - to quit):\n");
+--
+--        fgets(phrases, BUFFER_SIZE, stdin); 
+--        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+--
+--        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+--            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+--            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+--
+--    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+--            while (nextPhrase) {
+--                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+--                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+--            }
+--        }
+--    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+--
+--    printf("*** End of Tokenizing Words Demo ***\n\n");
+--}
+--
+--
+-+/*
+-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-+[tokenizing.c] : [tokenizing]
+-+Purpose: [This function takes a user inputted string and tokenizes it]
+-+*/
+-+
+-+
+-+// TOKENIZING MODULE SOURCE
+-+#define _CRT_SECURE_NO_WARNINGS
+-+#define BUFFER_SIZE 300
+-+#include "tokenizing.h"
+-+
+-+
+-+int main(void) {
+-+    tokenizing();
+-+    return 0;
+-+}
+-+
+-+
+-+// V1
+-+void tokenizing(void) {
+-+
+-+    printf("*** Start of Tokenizing Words Demo ***\n");
+-+    char words[BUFFER_SIZE];
+-+    char* nextWord = NULL;
+-+    int wordsCounter;
+-+    do {
+-+        printf("Type a few words seperated by space (q - to quit):\n");
+-+
+-+        fgets(words, BUFFER_SIZE, stdin); 
+-+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+
+-+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+
+-+        
+-+    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-+            while (nextWord) {
+-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+            }
+-+        }
+-+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+
+-+    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+}
+-+
+-+
+-
+-commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+-Author: CRYPTO43 <singharshjot07@gmail.com>
+-Date:   Tue Aug 9 17:12:27 2022 -0400
+-
+-    first commit
+-
+-diff --git a/fundamentals.c b/fundamentals.c
+-new file mode 100644
+-index 0000000..cd7cd9f
+---- /dev/null
+-+++ b/fundamentals.c
+-@@ -0,0 +1,63 @@
+-+/*
+-+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+-+fundamentals.c : indexing
+-+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+-+*/
+-+
+-+
+-+// FUNDAMENTALS MODULE SOURCE 
+-+#define _CRT_SECURE_NO_WARNINGS 
+-+#define BUFFER_SIZE 80
+-+#define NUM_INPUT_SIZE 10 
+-+#include "fundamentals.h"
+-+
+-+
+-+void main(void) {
+-+
+-+// V1
+-+    printf("*** start of Indexing Strings Demo ***\n"); 
+-+    char buffer1[BUFFER_SIZE]; 
+-+    char numInput[NUM_INPUT_SIZE]; 
+-+    size_t position; 
+-+    do {
+-+        printf("Type not empty string (q - to quit): \n"); 
+-+        fgets (buffer1, BUFFER_SIZE, stdin); 
+-+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+-+
+-+        // checks if entered string is not equals to 'q'.
+-+        if (strcmp (buffer1, "q") != 0) { 
+-+            printf("Type the character position within the string: \n"); 
+-+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+-+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+-+            position = atoi (numInput); // Converts entered string to integer.
+-+
+-+            // Checks if converted integer is larger then string length and assigns max position if true.
+-+            if (position >= strlen (buffer1)) { 
+-+                position = strlen (buffer1) - 1; 
+-+                printf("Too big... Position reduced to max. availbale\n");
+-+            }
+-+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+-+        }
+-+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+-+    printf("*** End of Indexing Strings Demo ***\n\n");
+-+
+-+
+-+
+-+    // V2 
+-+    printf("*** Start of Measuring Strings Demo ***\n"); 
+-+    char buffer2[BUFFER_SIZE]; 
+-+    do { 
+-+        printf("Type a string (q - to quit):\n"); 
+-+        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+-+        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+-+
+-+        // checks if entered string is not equals to 'q'.
+-+        if (strcmp(buffer2, "q") != 0) 
+-+            printf("The length of \'%s\' is %d characters\n", 
+-+            buffer2, (int)strlen(buffer2)); 
+-+        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+-+        
+-+        printf("*** End of Measuring Strings Demo ***\n\n");
+-+}
+-+
+-+ 
+-\ No newline at end of file
+-diff --git a/fundamentals.h b/fundamentals.h
+-new file mode 100644
+-index 0000000..383cccc
+---- /dev/null
+-+++ b/fundamentals.h
+-@@ -0,0 +1,12 @@
+-+// FUNDAMENTALS MODULE HEADER 
+-+#ifndef _FUNDAMENTALS_H_
+-+#define _FUNDAMENTALS_H_
+-+
+-+#include <stdio.h> 
+-+#include <stdlib.h> 
+-+#include <string.h>
+-+
+-+//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+-+void main(void);
+-+
+-+#endif
+-\ No newline at end of file
+-
+-commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-Date:   Tue Aug 9 16:17:34 2022 -0400
+-
+-    Add files via upload
+-    
+-    Version 2
+-
+-diff --git a/tokenizing.c b/tokenizing.c
+-index 65d1c20..417d34a 100644
+---- a/tokenizing.c
+-+++ b/tokenizing.c
+-@@ -1,42 +1,80 @@
+--/*
+--Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+--[tokenizing.c] : [tokenizing]
+--Purpose: [This function takes a user inputted string and tokenizes it]
+--*/
+--
+--
+--// TOKENIZING MODULE SOURCE
+--#define _CRT_SECURE_NO_WARNINGS
+--#define BUFFER_SIZE 300
+--#include "tokenizing.h"
+--
+--// V1
+--void tokenizing(void) {
+--
+--    printf("*** Start of Tokenizing Words Demo ***\n");
+--    char words[BUFFER_SIZE];
+--    char* nextWord = NULL;
+--    int wordsCounter;
+--    do {
+--        printf("Type a few words seperated by space (q - to quit):\n");
+--
+--        fgets(words, BUFFER_SIZE, stdin); 
+--        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+--
+--        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+--            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+--            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+--
+--        
+--    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+--            while (nextWord) {
+--                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+--                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+--            }
+--        }
+--    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+--
+--    printf("*** End of Tokenizing Words Demo ***\n\n");
+--}
+--
+--
+-+/*
+-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-+[tokenizing.c] : [tokenizing]
+-+Purpose: [This function takes a user inputted string and tokenizes it]
+-+*/
+-+
+-+
+-+// TOKENIZING MODULE SOURCE
+-+#define _CRT_SECURE_NO_WARNINGS
+-+#define BUFFER_SIZE 300
+-+#include "tokenizing.h"
+-+
+-+
+-+int main(void) {
+-+    tokenizing();
+-+    return 0;
+-+}
+-+
+-+
+-+/*
+-+// V1
+-+//void tokenizing(void) {
+-+
+-+    printf("*** Start of Tokenizing Words Demo ***\n");
+-+    char words[BUFFER_SIZE];
+-+    char* nextWord = NULL;
+-+    int wordsCounter;
+-+    do {
+-+        printf("Type a few words seperated by space (q - to quit):\n");
+-+
+-+        fgets(words, BUFFER_SIZE, stdin); 
+-+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+
+-+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+
+-+    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-+            while (nextWord) {
+-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+            }
+-+       }
+-+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+
+-+    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+}
+-+*/
+-+
+-+
+-+// V2
+-+/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-+void tokenizing(void) {
+-+
+-+    printf("*** Start of Tokenizing Words Demo ***\n");
+-+    char phrases[BUFFER_SIZE];
+-+    char* nextPhrase = NULL;
+-+    int phrasesCounter;
+-+    do {
+-+        printf("Type a few words seperated by comma (q - to quit):\n");
+-+
+-+        fgets(phrases, BUFFER_SIZE, stdin); 
+-+        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+
+-+        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-+            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-+            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+
+-+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-+            while (nextPhrase) {
+-+                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-+                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-+            }
+-+        }
+-+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+
+-+    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+}
+-+
+-+
+-diff --git a/tokenizing.h b/tokenizing.h
+-index c00f3cb..7899cc2 100644
+---- a/tokenizing.h
+-+++ b/tokenizing.h
+-@@ -1,10 +1,10 @@
+--// Tokenization header file
+--#ifndef _TOKENIZING_H_
+--#define _TOKENIZING_H_
+--
+--#include <stdio.h>
+--#include <string.h>
+--
+--void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+--
+-+// Tokenization header file
+-+#ifndef _TOKENIZING_H_
+-+#define _TOKENIZING_H_
+-+
+-+#include <stdio.h>
+-+#include <string.h>
+-+
+-+void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-+
+- #endif
+-\ No newline at end of file
+-
+-commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+-Author: rsaguros <rsaguros1@myseneca.ca>
+-Date:   Mon Aug 8 15:47:34 2022 -0400
+-
+-    Version 2
+-    
+-    Version 2
+-
+-diff --git a/converting.c b/converting.c
+-index c5a0775..df23173 100644
+---- a/converting.c
+-+++ b/converting.c
+-@@ -1,6 +1,6 @@
+- // CONVERTING MODULE SOURCE
+- /*
+--Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+-+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+- converting.c : CONVERTING
+- Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+- */
+-@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+- // strings and convert a string to an integer value.
+- #include "converting.h"
+- 
+--// V1
+- void converting(void) {
+-+	// V1
+- 	// Display beginning message
+- 	printf("*** Start of Converting Strings to int Demo ***\n");
++ void manipulating(void) {
++-/* Purpose: This function concatenates 2 input strings */
+++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
+  
+-@@ -38,6 +38,30 @@ void converting(void) {
++ 	printf("*** Start of Concatenating Strings Demo ***\n");
++ 	char string1[BUFFER_SIZE];
++@@ -56,4 +56,27 @@ void manipulating(void) {
+  		}
+- 	} while (strcmp(intString, "q") != 0);
+- 
+--	// Display ending message and exit module.
+-+	// Display ending message for int demo
+- 	printf("*** End of Converting Strings to int Demo ***\n\n");
++ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++ 	printf("*** End of Comparing Strings Demo ***\n\n");
+ +
+-+	// V2
+-+	printf("*** Start of Converting Strings to double Demo ***\n");
+-+
+-+	char	doubleString[BUFFER_SIZE];
+-+	double	doubleNumber;
+ +
+++//V3
+++	printf("*** Start of Searching Strings Demo ***\n");
+++	char haystack[BUFFER_SIZE];
+++	char needle[BUFFER_SIZE];
+++	char* occurence = NULL;
+ +	do {
+-+		// Prompt user for entry, replacing the new line read by 
+-+		// fgets with a null terminator
+-+		printf("Type an double numeric string (q - to quit):\n");
+-+		fgets(doubleString, BUFFER_SIZE, stdin);
+-+		doubleString[strlen(doubleString) - 1] = '\0';
+-+
+-+		// Check user input, exit if 'q' was entered.  
+-+		if ((strcmp(doubleString, "q") != 0)) {
+-+
+-+			// Convert user entry from numeric string to a double, then display it
+-+			doubleNumber = atof(doubleString);
+-+			printf("Converted number is %f\n", doubleNumber);
+++		printf("Type the string (q - to quit):\n");
+++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
+++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
+++			printf("Type the substring:\n");
+++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
+++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
+++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
+++			if (occurence)							// If found, return the position where 2nd string occurs
+++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
+++			else						
+++				printf("Not found\n");				
+ +		}
+-+	} while (strcmp(doubleString, "q") != 0);
+-+
+-+	printf("*** End of Converting Strings to double Demo ***\n\n");
+++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Searching Strings Demo ***\n\n");
+  }
++\ No newline at end of file
+ 
+-commit e25ade313038da86c407f85f5c00586ba6b37a1b
+-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-Date:   Mon Aug 8 15:05:20 2022 -0400
+-
+-    Update README.md
+-
+-diff --git a/README.md b/README.md
+-index 28e7c31..f1ff45d 100644
+---- a/README.md
+-+++ b/README.md
+-@@ -1,5 +1,8 @@
+- # CPR101_Project
+- CPR101 Final Project
+-+
+- Section: NAA
+-+
+- Group 1
+-+
+- Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+-
+-commit a3e1e5ae394af27b186e61562b7167819c90ea13
+-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-Date:   Mon Aug 8 15:01:47 2022 -0400
+-
+-    Create README.md
+-
+-diff --git a/README.md b/README.md
+-new file mode 100644
+-index 0000000..28e7c31
+---- /dev/null
+-+++ b/README.md
+-@@ -0,0 +1,5 @@
+-+# CPR101_Project
+-+CPR101 Final Project
+-+Section: NAA
+-+Group 1
+-+Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+-
+-commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
+ Author: rsaguros <rsaguros1@myseneca.ca>
+-Date:   Mon Aug 8 13:58:05 2022 -0400
++Date:   Tue Aug 9 23:04:40 2022 -0400
+ 
+-    Update converting.c
++    Adding git logs
+     
+-    Version 2
++    Version 2 Git Logs
++    $ git --no-pager log -p > "module-git-log.txt"
+ 
+-diff --git a/converting.c b/converting.c
+-index c5a0775..df23173 100644
+---- a/converting.c
+-+++ b/converting.c
+-@@ -1,6 +1,6 @@
+- // CONVERTING MODULE SOURCE
+- /*
+--Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+-+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+- converting.c : CONVERTING
+- Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+- */
+-@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+- // strings and convert a string to an integer value.
+- #include "converting.h"
+- 
+--// V1
+- void converting(void) {
+-+	// V1
+- 	// Display beginning message
+- 	printf("*** Start of Converting Strings to int Demo ***\n");
+- 
+-@@ -38,6 +38,30 @@ void converting(void) {
+- 		}
+- 	} while (strcmp(intString, "q") != 0);
+- 
+--	// Display ending message and exit module.
+-+	// Display ending message for int demo
+- 	printf("*** End of Converting Strings to int Demo ***\n\n");
+-+
+-+	// V2
+-+	printf("*** Start of Converting Strings to double Demo ***\n");
+-+
+-+	char	doubleString[BUFFER_SIZE];
+-+	double	doubleNumber;
+-+
+-+	do {
+-+		// Prompt user for entry, replacing the new line read by 
+-+		// fgets with a null terminator
+-+		printf("Type an double numeric string (q - to quit):\n");
+-+		fgets(doubleString, BUFFER_SIZE, stdin);
+-+		doubleString[strlen(doubleString) - 1] = '\0';
+-+
+-+		// Check user input, exit if 'q' was entered.  
+-+		if ((strcmp(doubleString, "q") != 0)) {
+-+
+-+			// Convert user entry from numeric string to a double, then display it
+-+			doubleNumber = atof(doubleString);
+-+			printf("Converted number is %f\n", doubleNumber);
+-+		}
+-+	} while (strcmp(doubleString, "q") != 0);
++diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
++new file mode 100644
++index 0000000..7bb5209
++--- /dev/null
+++++ b/manipulating-git-log.txt
++@@ -0,0 +1,1345 @@
+++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+++Merge: 6361388 c3a8316
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Tue Aug 9 22:49:17 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit 63613886b8f1ecccb62538d6d4b7905425a16358
+++Merge: 0626d2e c0f7dc8
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Tue Aug 9 22:47:37 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+++Merge: 9d98950 c0f7dc8
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 22:46:28 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+++Merge: fd97b97 a2a1bf4
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Tue Aug 9 22:44:47 2022 -0400
+++
+++    Merge pull request #1 from kiararina/converting
+++    
+++    Recovering lost commits up to converting.c
+++
+++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+++Merge: cee497d fd97b97
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Tue Aug 9 22:44:00 2022 -0400
+++
+++    Merge branch 'main' into converting
+++
+++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:23:44 2022 -0400
+++
+++    tokenizing.c v2 corrected
+++    
+++    Corrected a previous error, now both v1 and v2 are within the same function name
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 6332b6d..ae26066 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ 
+++ 
+++ 
++++void tokenizing(void) {
+++ 
+++-/*
+++-// V1
+++-//void tokenizing(void) {
+++-
++++    // V1
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char words[BUFFER_SIZE];
+++     char* nextWord = NULL;
+++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++     do {
+++         printf("Type a few words seperated by space (q - to quit):\n");
+++ 
+++-        fgets(words, BUFFER_SIZE, stdin); 
++++        fgets(words, BUFFER_SIZE, stdin);
+++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++ 
+++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ 
+++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++             while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++             }
+++-       }
++++        }
+++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++ 
+++     printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-*/
+++ 
+++ 
+++-// V2
+++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++-void tokenizing(void) {
+++-
++++    // V2
++++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char phrases[BUFFER_SIZE];
+++     char* nextPhrase = NULL;
+++
+++commit 23f162166b815502c16ac1456d8f9be87b799f26
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:09:02 2022 -0400
+++
+++    Update tokenizing.c to V2
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index edc3184..6332b6d 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++ [tokenizing.c] : [tokenizing]
+++ Purpose: [This function takes a user inputted string and tokenizes it]
+++ */
+++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ #include "tokenizing.h"
+++ 
+++ 
+++-int main(void) {
+++-    tokenizing();
+++-    return 0;
+++-}
+++ 
+++ 
++++/*
+++ // V1
+++-void tokenizing(void) {
++++//void tokenizing(void) {
+++ 
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char words[BUFFER_SIZE];
+++@@ -34,16 +31,46 @@ void tokenizing(void) {
+++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++ 
+++-        
+++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++             while (nextWord) {
+++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++             }
+++-        }
++++       }
+++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++ 
+++     printf("*** End of Tokenizing Words Demo ***\n\n");
+++ }
++++*/
++++
++++
++++// V2
++++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char phrases[BUFFER_SIZE];
++++    char* nextPhrase = NULL;
++++    int phrasesCounter;
++++    do {
++++        printf("Type a few words seperated by comma (q - to quit):\n");
++++
++++        fgets(phrases, BUFFER_SIZE, stdin); 
++++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++++            while (nextPhrase) {
++++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++++            }
++++        }
++++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
+++ 
+++ 
+ +
+-+	printf("*** End of Converting Strings to double Demo ***\n\n");
+- }
+++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:06:55 2022 -0400
+++
+++    V1
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 417d34a..edc3184 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,80 +1,49 @@
+++-/*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++-[tokenizing.c] : [tokenizing]
+++-Purpose: [This function takes a user inputted string and tokenizes it]
+++-*/
+++-
+++-
+++-// TOKENIZING MODULE SOURCE
+++-#define _CRT_SECURE_NO_WARNINGS
+++-#define BUFFER_SIZE 300
+++-#include "tokenizing.h"
+++-
+++-
+++-int main(void) {
+++-    tokenizing();
+++-    return 0;
+++-}
+++-
+++-
+++-/*
+++-// V1
+++-//void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char words[BUFFER_SIZE];
+++-    char* nextWord = NULL;
+++-    int wordsCounter;
+++-    do {
+++-        printf("Type a few words seperated by space (q - to quit):\n");
+++-
+++-        fgets(words, BUFFER_SIZE, stdin); 
+++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++-            while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++-            }
+++-       }
+++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-*/
+++-
+++-
+++-// V2
+++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++-void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char phrases[BUFFER_SIZE];
+++-    char* nextPhrase = NULL;
+++-    int phrasesCounter;
+++-    do {
+++-        printf("Type a few words seperated by comma (q - to quit):\n");
+++-
+++-        fgets(phrases, BUFFER_SIZE, stdin); 
+++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++-            while (nextPhrase) {
+++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++-            }
+++-        }
+++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-
+++-
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++
++++int main(void) {
++++    tokenizing();
++++    return 0;
++++}
++++
++++
++++// V1
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++        
++++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++        }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++
+++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+++Author: CRYPTO43 <singharshjot07@gmail.com>
+++Date:   Tue Aug 9 17:12:27 2022 -0400
+++
+++    first commit
+++
+++diff --git a/fundamentals.c b/fundamentals.c
+++new file mode 100644
+++index 0000000..cd7cd9f
+++--- /dev/null
++++++ b/fundamentals.c
+++@@ -0,0 +1,63 @@
++++/*
++++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++++fundamentals.c : indexing
++++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++++*/
++++
++++
++++// FUNDAMENTALS MODULE SOURCE 
++++#define _CRT_SECURE_NO_WARNINGS 
++++#define BUFFER_SIZE 80
++++#define NUM_INPUT_SIZE 10 
++++#include "fundamentals.h"
++++
++++
++++void main(void) {
++++
++++// V1
++++    printf("*** start of Indexing Strings Demo ***\n"); 
++++    char buffer1[BUFFER_SIZE]; 
++++    char numInput[NUM_INPUT_SIZE]; 
++++    size_t position; 
++++    do {
++++        printf("Type not empty string (q - to quit): \n"); 
++++        fgets (buffer1, BUFFER_SIZE, stdin); 
++++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp (buffer1, "q") != 0) { 
++++            printf("Type the character position within the string: \n"); 
++++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++++            position = atoi (numInput); // Converts entered string to integer.
++++
++++            // Checks if converted integer is larger then string length and assigns max position if true.
++++            if (position >= strlen (buffer1)) { 
++++                position = strlen (buffer1) - 1; 
++++                printf("Too big... Position reduced to max. availbale\n");
++++            }
++++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++++        }
++++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++++    printf("*** End of Indexing Strings Demo ***\n\n");
++++
++++
++++
++++    // V2 
++++    printf("*** Start of Measuring Strings Demo ***\n"); 
++++    char buffer2[BUFFER_SIZE]; 
++++    do { 
++++        printf("Type a string (q - to quit):\n"); 
++++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp(buffer2, "q") != 0) 
++++            printf("The length of \'%s\' is %d characters\n", 
++++            buffer2, (int)strlen(buffer2)); 
++++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++++        
++++        printf("*** End of Measuring Strings Demo ***\n\n");
++++}
++++
++++ 
+++\ No newline at end of file
+++diff --git a/fundamentals.h b/fundamentals.h
+++new file mode 100644
+++index 0000000..383cccc
+++--- /dev/null
++++++ b/fundamentals.h
+++@@ -0,0 +1,12 @@
++++// FUNDAMENTALS MODULE HEADER 
++++#ifndef _FUNDAMENTALS_H_
++++#define _FUNDAMENTALS_H_
++++
++++#include <stdio.h> 
++++#include <stdlib.h> 
++++#include <string.h>
++++
++++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++++void main(void);
++++
++++#endif
+++\ No newline at end of file
+++
+++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 16:17:34 2022 -0400
+++
+++    Add files via upload
+++    
+++    Version 2
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 65d1c20..417d34a 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,42 +1,80 @@
+++-/*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++-[tokenizing.c] : [tokenizing]
+++-Purpose: [This function takes a user inputted string and tokenizes it]
+++-*/
+++-
+++-
+++-// TOKENIZING MODULE SOURCE
+++-#define _CRT_SECURE_NO_WARNINGS
+++-#define BUFFER_SIZE 300
+++-#include "tokenizing.h"
+++-
+++-// V1
+++-void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char words[BUFFER_SIZE];
+++-    char* nextWord = NULL;
+++-    int wordsCounter;
+++-    do {
+++-        printf("Type a few words seperated by space (q - to quit):\n");
+++-
+++-        fgets(words, BUFFER_SIZE, stdin); 
+++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-        
+++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++-            while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++-            }
+++-        }
+++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-
+++-
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++
++++int main(void) {
++++    tokenizing();
++++    return 0;
++++}
++++
++++
++++/*
++++// V1
++++//void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++       }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++*/
++++
++++
++++// V2
++++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char phrases[BUFFER_SIZE];
++++    char* nextPhrase = NULL;
++++    int phrasesCounter;
++++    do {
++++        printf("Type a few words seperated by comma (q - to quit):\n");
++++
++++        fgets(phrases, BUFFER_SIZE, stdin); 
++++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++++            while (nextPhrase) {
++++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++++            }
++++        }
++++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++diff --git a/tokenizing.h b/tokenizing.h
+++index c00f3cb..7899cc2 100644
+++--- a/tokenizing.h
++++++ b/tokenizing.h
+++@@ -1,10 +1,10 @@
+++-// Tokenization header file
+++-#ifndef _TOKENIZING_H_
+++-#define _TOKENIZING_H_
+++-
+++-#include <stdio.h>
+++-#include <string.h>
+++-
+++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++-
++++// Tokenization header file
++++#ifndef _TOKENIZING_H_
++++#define _TOKENIZING_H_
++++
++++#include <stdio.h>
++++#include <string.h>
++++
++++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++++
+++ #endif
+++\ No newline at end of file
+++
+++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Mon Aug 8 15:47:34 2022 -0400
+++
+++    Version 2
+++    
+++    Version 2
+++
+++diff --git a/converting.c b/converting.c
+++index c5a0775..df23173 100644
+++--- a/converting.c
++++++ b/converting.c
+++@@ -1,6 +1,6 @@
+++ // CONVERTING MODULE SOURCE
+++ /*
+++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+++ converting.c : CONVERTING
+++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++ */
+++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+++ // strings and convert a string to an integer value.
+++ #include "converting.h"
+++ 
+++-// V1
+++ void converting(void) {
++++	// V1
+++ 	// Display beginning message
+++ 	printf("*** Start of Converting Strings to int Demo ***\n");
+++ 
+++@@ -38,6 +38,30 @@ void converting(void) {
+++ 		}
+++ 	} while (strcmp(intString, "q") != 0);
+++ 
+++-	// Display ending message and exit module.
++++	// Display ending message for int demo
+++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++++
++++	// V2
++++	printf("*** Start of Converting Strings to double Demo ***\n");
++++
++++	char	doubleString[BUFFER_SIZE];
++++	double	doubleNumber;
++++
++++	do {
++++		// Prompt user for entry, replacing the new line read by 
++++		// fgets with a null terminator
++++		printf("Type an double numeric string (q - to quit):\n");
++++		fgets(doubleString, BUFFER_SIZE, stdin);
++++		doubleString[strlen(doubleString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.  
++++		if ((strcmp(doubleString, "q") != 0)) {
++++
++++			// Convert user entry from numeric string to a double, then display it
++++			doubleNumber = atof(doubleString);
++++			printf("Converted number is %f\n", doubleNumber);
++++		}
++++	} while (strcmp(doubleString, "q") != 0);
++++
++++	printf("*** End of Converting Strings to double Demo ***\n\n");
+++ }
+++
+++commit e25ade313038da86c407f85f5c00586ba6b37a1b
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Mon Aug 8 15:05:20 2022 -0400
+++
+++    Update README.md
+++
+++diff --git a/README.md b/README.md
+++index 28e7c31..f1ff45d 100644
+++--- a/README.md
++++++ b/README.md
+++@@ -1,5 +1,8 @@
+++ # CPR101_Project
+++ CPR101 Final Project
++++
+++ Section: NAA
++++
+++ Group 1
++++
+++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+++
+++commit a3e1e5ae394af27b186e61562b7167819c90ea13
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Mon Aug 8 15:01:47 2022 -0400
+++
+++    Create README.md
+++
+++diff --git a/README.md b/README.md
+++new file mode 100644
+++index 0000000..28e7c31
+++--- /dev/null
++++++ b/README.md
+++@@ -0,0 +1,5 @@
++++# CPR101_Project
++++CPR101 Final Project
++++Section: NAA
++++Group 1
++++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+++
+++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Mon Aug 8 13:58:05 2022 -0400
+++
+++    Update converting.c
+++    
+++    Version 2
+++
+++diff --git a/converting.c b/converting.c
+++index c5a0775..df23173 100644
+++--- a/converting.c
++++++ b/converting.c
+++@@ -1,6 +1,6 @@
+++ // CONVERTING MODULE SOURCE
+++ /*
+++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+++ converting.c : CONVERTING
+++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++ */
+++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+++ // strings and convert a string to an integer value.
+++ #include "converting.h"
+++ 
+++-// V1
+++ void converting(void) {
++++	// V1
+++ 	// Display beginning message
+++ 	printf("*** Start of Converting Strings to int Demo ***\n");
+++ 
+++@@ -38,6 +38,30 @@ void converting(void) {
+++ 		}
+++ 	} while (strcmp(intString, "q") != 0);
+++ 
+++-	// Display ending message and exit module.
++++	// Display ending message for int demo
+++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++++
++++	// V2
++++	printf("*** Start of Converting Strings to double Demo ***\n");
++++
++++	char	doubleString[BUFFER_SIZE];
++++	double	doubleNumber;
++++
++++	do {
++++		// Prompt user for entry, replacing the new line read by 
++++		// fgets with a null terminator
++++		printf("Type an double numeric string (q - to quit):\n");
++++		fgets(doubleString, BUFFER_SIZE, stdin);
++++		doubleString[strlen(doubleString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.  
++++		if ((strcmp(doubleString, "q") != 0)) {
++++
++++			// Convert user entry from numeric string to a double, then display it
++++			doubleNumber = atof(doubleString);
++++			printf("Converted number is %f\n", doubleNumber);
++++		}
++++	} while (strcmp(doubleString, "q") != 0);
++++
++++	printf("*** End of Converting Strings to double Demo ***\n\n");
+++ }
+++
+++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Mon Aug 8 13:43:58 2022 -0400
+++
+++    Update manipulating.c
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 953e516..9193243 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -41,7 +41,7 @@ void manipulating(void) {
+++ 	do {
+++ 		printf("Type the 1st string to compare (q - to quit):\n");
+++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++ 			printf("Type the 2nd string to compare:\n");
+++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++
+++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Mon Aug 8 12:51:35 2022 -0400
+++
+++    Version 2
+++    
+++    Updated main for version 2
+++
+++diff --git a/main.c b/main.c
+++index 755b397..70aeeb7 100644
+++--- a/main.c
++++++ b/main.c
+++@@ -1,6 +1,6 @@
+++ // MAIN 
+++ /*
+++-Author: BB01, 03/08/2022, CPR101, Final Project V1
++++Author: BB01, 03/08/2022, CPR101, Final Project
+++ main.c : MAIN
+++ Purpose: Main Function used to prompt user for which various options.
+++ */
+++
+++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+++Author: kiararina <kiararina.pelenio@upou.edu.ph>
+++Date:   Mon Aug 8 09:38:48 2022 -0500
+++
+++    Version 2
+++    
+++    Added version 2 codes
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 9bde2d2..953e516 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+++ manipulating.c : Manipulating
+++ Purpose: This program manipulates input strings
+++ */
+++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+++ #include "manipulating.h" 
+++ /* Contains function prototypes and library declarations */
+++ 
++++// V1
+++ void manipulating(void) {
+++ /* Purpose: This function concatenates 2 input strings */
+++ 
+++@@ -19,16 +20,40 @@ void manipulating(void) {
+++ 
+++ 	do {
+++ 		printf("Type the 1st string (q - to quit):\n");
+++-		fgets(string1, BUFFER_SIZE, stdin);
+++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+++ 
+++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++ 			printf("Type the 2nd string:\n");
+++-			fgets(string2, BUFFER_SIZE, stdin);
++++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++ 			strcat(string1, string2);
+++ 			printf("Concatenated string is \'%s\'\n", string1);
+++ 		}
+++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++ 
+++ 	printf("*** End of Concatenating Strings Demo ***\n");
++++
++++//V2
++++	printf("*** Start of Comparing Strings Demo ***\n");
++++	char compare1[BUFFER_SIZE];
++++	char compare2[BUFFER_SIZE];
++++	int result;
++++	do {
++++		printf("Type the 1st string to compare (q - to quit):\n");
++++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++++			printf("Type the 2nd string to compare:\n");
++++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++++			if (result < 0)
++++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++++			else if (result == 0)
++++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++++			else
++++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++++		}
++++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++++	printf("*** End of Comparing Strings Demo ***\n\n");
+++ }
+++\ No newline at end of file
+++
+++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+++Author: kiararina <kiararina.pelenio@upou.edu.ph>
+++Date:   Thu Aug 4 15:34:34 2022 -0500
+++
+++    Update manipulating.c
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 748c895..9bde2d2 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++ manipulating.c : Manipulating
+++ Purpose: This program manipulates input strings
+++ */
+++
+++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Thu Aug 4 16:30:00 2022 -0400
+++
+++    Version 1
+++
+++diff --git a/Programming Comments.docx b/Programming Comments.docx
+++new file mode 100644
+++index 0000000..07d1cd7
+++--- /dev/null
++++++ b/Programming Comments.docx	
+++@@ -0,0 +1,110 @@
++++                        Commenting Program Source Code
++++--------------------------------------------------------------------------------
++++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++++--------------------------------------------------------------------------------
++++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++++Comments are for programmers who will maintain the code in the future. 
++++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++++--------------------------------------------------------------------------------
++++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++++--------------------------------------------------------------------------------
++++
++++Organisation of Comments
++++Program comments 
++++ -  appear at the beginning of a source file.
++++/* 
++++Author: Name, email, ID, Date written, Course, Project
++++[executable filename] : [title of program]
++++Purpose: [what this program does, what problem does it solve?]
++++*/
++++
++++Function comments
++++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++++/*
++++Purpose: [what this function does, what problem does it solve?]
++++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++++*/
++++
++++Inline code comments
++++Your comment must say something different than explaining the code itself. 
++++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++++c = a + b;  // c stores total of assignment and test marks respectively.
++++
++++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++++cryptic = C + code; 		// explain this line's purpose in the program
++++crypticly = C + moreCode;	// explain this line's purpose in the program
++++
++++Longer code comments
++++Sometimes comments need more space than would fit inline. 
++++cryptic = C + code;
++++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++++moreCrypticly = C + moreCode;	
++++
++++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++++// this comment explains the purpose of the next line of code  
++++cryptic = C + code;
++++ 		
++++// this comment explains the purpose of the next line of code  
++++moreCrypticly = C + moreCode;	
++++		
++++
++++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++++
++++Structures
++++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++++// [what the structure accomplishes]
++++e.g. 
++++// compute factorial	
++++// prompt user until value within range 1  -  100 is input
++++Code Samples
++++printf("Type a few words separated by space(q - to quit):\n");
++++gets(words);
++++while (strcmp(words, "q") != 0) 
++++{
++++    word = strtok(words, " ");
++++    w_counter = 1;
++++    while (word) 
++++    {
++++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++++        word = strtok(NULL, " ");
++++    }
++++    printf("Type a few words separated by space(q - to quit):\n");
++++    gets(words);
++++}
++++
++++ the first while continues until the 'words' variable is equal to "q". What is it for?
++++ there is another while {structure} ... what does it do?
++++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++++ // keep looping until pointer is NULL
++++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++++ This technique is even more important at the end of a series nested structures, e.g.
++++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++++
++++
++++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++++
++++while (TRUE) // a comment explains why there is no exit condition here
++++{
++++ 	. . .
++++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++++. . .
++++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++++   // --------- *****      make it visually obvious that this is an exit from the structure
++++. . .
++++}
+++diff --git a/converting.c b/converting.c
+++new file mode 100644
+++index 0000000..c5a0775
+++--- /dev/null
++++++ b/converting.c
+++@@ -0,0 +1,43 @@
++++// CONVERTING MODULE SOURCE
++++/*
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++converting.c : CONVERTING
++++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++++*/
++++
++++#define	_CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 80
++++
++++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++++// strings and convert a string to an integer value.
++++#include "converting.h"
++++
++++// V1
++++void converting(void) {
++++	// Display beginning message
++++	printf("*** Start of Converting Strings to int Demo ***\n");
++++
++++	// Declare variables
++++	char	intString[BUFFER_SIZE];
++++	int		intNumber;
++++
++++	do {
++++		// Prompt user for entry
++++		printf("Type an int numeric string (q - to quit):\n");
++++		fgets(intString, BUFFER_SIZE, stdin);
++++		intString[strlen(intString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.
++++		if (strcmp(intString, "q") != 0) {
++++
++++			// Convert user entry from string to integer value.
++++			intNumber = atoi(intString);
++++
++++			// Display converted number.
++++			printf("Converted number is %d\n", intNumber);
++++		}
++++	} while (strcmp(intString, "q") != 0);
++++
++++	// Display ending message and exit module.
++++	printf("*** End of Converting Strings to int Demo ***\n\n");
++++}
+++diff --git a/converting.h b/converting.h
+++new file mode 100644
+++index 0000000..03c62a3
+++--- /dev/null
++++++ b/converting.h
+++@@ -0,0 +1,18 @@
++++// CONVERTING MODULE HEADER
++++#ifndef _CONVERTING_H_
++++#define _CONVERTING_H_
++++
++++// Libraries
++++#include <stdio.h>
++++#include <string.h>
++++#include <stdlib.h>
++++
++++
++++/////////////////////////
++++// Prototype  Function //
++++/////////////////////////
++++
++++// Function used to apply conversions
++++void converting(void);
++++
++++#endif
+++diff --git a/fundamentals.c b/fundamentals.c
+++new file mode 100644
+++index 0000000..95c9f23
+++--- /dev/null
++++++ b/fundamentals.c
+++@@ -0,0 +1,43 @@
++++/*
++++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++++fundamentals.c : indexing
++++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++++*/
++++
++++
++++// FUNDAMENTALS MODULE SOURCE 
++++#define _CRT_SECURE_NO_WARNINGS 
++++#define BUFFER_SIZE 80
++++#define NUM_INPUT_SIZE 10 
++++#include "fundamentals.h"
++++
++++
++++void fundamentals(void) {
++++
++++// V1
++++    printf("*** start of Indexing Strings Demo ***\n"); 
++++    char buffer1[BUFFER_SIZE]; 
++++    char numInput[NUM_INPUT_SIZE]; 
++++    size_t position; 
++++    do {
++++        printf("Type not empty string (q - to quit): \n"); 
++++        fgets (buffer1, BUFFER_SIZE, stdin); 
++++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp (buffer1, "q") != 0) { 
++++            printf("Type the character position within the string: \n"); 
++++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++++            position = atoi (numInput); // Converts entered string to integer.
++++
++++            // Checks if converted integer is larger then string length and assigns max position if true.
++++            if (position >= strlen (buffer1)) { 
++++                position = strlen (buffer1) - 1; 
++++                printf("Too big... Position reduced to max. availbale\n");
++++            }
++++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++++        }
++++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++++    printf("*** End of Indexing Strings Demo ***\n\n");
++++}
+++\ No newline at end of file
+++diff --git a/fundamentals.h b/fundamentals.h
+++new file mode 100644
+++index 0000000..0433660
+++--- /dev/null
++++++ b/fundamentals.h
+++@@ -0,0 +1,12 @@
++++// FUNDAMENTALS MODULE HEADER 
++++#ifndef _FUNDAMENTALS_H_
++++#define _FUNDAMENTALS_H_
++++
++++#include <stdio.h> 
++++#include <stdlib.h> 
++++#include <string.h>
++++
++++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++++void fundamentals(void);
++++
++++#endif
+++\ No newline at end of file
+++diff --git a/main.c b/main.c
+++new file mode 100644
+++index 0000000..755b397
+++--- /dev/null
++++++ b/main.c
+++@@ -0,0 +1,58 @@
++++// MAIN 
++++/*
++++Author: BB01, 03/08/2022, CPR101, Final Project V1
++++main.c : MAIN
++++Purpose: Main Function used to prompt user for which various options.
++++*/
++++
++++// Include all necessary modules
++++#define _CRT_SECURE_NO_WARNINGS
++++#include "fundamentals.h"
++++#include "manipulating.h"
++++#include "converting.h"
++++#include "tokenizing.h"
++++
++++int main(void) {
++++	// Declare variables
++++	char buff[10];
++++
++++	// Open menu for user
++++	do {
++++		// Display menu options
++++		printf("1 - Fundamentals\n");
++++		printf("2 - Manipulation\n");
++++		printf("3 - Converting\n");
++++		printf("4 - Tokenizing\n");
++++		printf("0 - Exit\n");
++++		
++++		// Prompt user for input
++++		printf("Which module to run? \n");
++++		fgets(buff, 10, stdin);
++++
++++		// Analyze user entry and match selection
++++		switch (buff[0])
++++		{
++++		case '1': 
++++			// Call for fundamentals module
++++			fundamentals();
++++			break;
++++
++++		case '2': 
++++			// Call for manipulating module
++++			manipulating();
++++			break;
++++
++++		case '3': 
++++			// Call for converting module
++++			converting();
++++			break;
++++
++++		case '4': 
++++			// Call for tokenizing module
++++			tokenizing();
++++			break;
++++		}
++++	} while (buff[0] != '0');
++++	
++++	return 0;
++++}
+++\ No newline at end of file
+++diff --git a/manipulating.c b/manipulating.c
+++new file mode 100644
+++index 0000000..748c895
+++--- /dev/null
++++++ b/manipulating.c
+++@@ -0,0 +1,34 @@
++++/*
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++++manipulating.c : Manipulating
++++Purpose: This program manipulates input strings
++++*/
++++
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 80
++++
++++#include "manipulating.h" 
++++/* Contains function prototypes and library declarations */
++++
++++void manipulating(void) {
++++/* Purpose: This function concatenates 2 input strings */
++++
++++	printf("*** Start of Concatenating Strings Demo ***\n");
++++	char string1[BUFFER_SIZE];
++++	char string2[BUFFER_SIZE];
++++
++++	do {
++++		printf("Type the 1st string (q - to quit):\n");
++++		fgets(string1, BUFFER_SIZE, stdin);
++++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++++
++++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++++			printf("Type the 2nd string:\n");
++++			fgets(string2, BUFFER_SIZE, stdin);
++++			strcat(string1, string2);
++++			printf("Concatenated string is \'%s\'\n", string1);
++++		}
++++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++++
++++	printf("*** End of Concatenating Strings Demo ***\n");
++++}
+++\ No newline at end of file
+++diff --git a/manipulating.h b/manipulating.h
+++new file mode 100644
+++index 0000000..8a8f926
+++--- /dev/null
++++++ b/manipulating.h
+++@@ -0,0 +1,11 @@
++++//MANIPULATING MODULE HEADER
++++#ifndef _MANIPULATING_H_
++++#define _MANIPULATING_H_
++++
++++#include <stdio.h>		// For input/output and printing
++++#include <string.h>		// For string manipulation functions
++++
++++void manipulating(void);
++++/* Purpose: This function concatenates 2 input strings */
++++
++++#endif
+++diff --git a/tokenizing.c b/tokenizing.c
+++new file mode 100644
+++index 0000000..65d1c20
+++--- /dev/null
++++++ b/tokenizing.c
+++@@ -0,0 +1,42 @@
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++// V1
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++        
++++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++        }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++diff --git a/tokenizing.h b/tokenizing.h
+++new file mode 100644
+++index 0000000..c00f3cb
+++--- /dev/null
++++++ b/tokenizing.h
+++@@ -0,0 +1,10 @@
++++// Tokenization header file
++++#ifndef _TOKENIZING_H_
++++#define _TOKENIZING_H_
++++
++++#include <stdio.h>
++++#include <string.h>
++++
++++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++++
++++#endif
+++\ No newline at end of file
+++
+++commit f914d3afae4107c77728b3df4d39502c962ba74b
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Thu Aug 4 15:48:50 2022 -0400
+++
+++    Initial commit
+++
+++diff --git a/.gitattributes b/.gitattributes
+++new file mode 100644
+++index 0000000..dfe0770
+++--- /dev/null
++++++ b/.gitattributes
+++@@ -0,0 +1,2 @@
++++# Auto detect text files and perform LF normalization
++++* text=auto
+ 
+ commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+ Author: krpm <mungcalrina@gmail.com>
+@@ -764,27 +1430,6 @@ index 953e516..9193243 100644
+  			printf("Type the 2nd string to compare:\n");
+  			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 
+-commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+-Author: krpm <mungcalrina@gmail.com>
+-Date:   Mon Aug 8 12:51:35 2022 -0400
+-
+-    Version 2
+-    
+-    Updated main for version 2
+-
+-diff --git a/main.c b/main.c
+-index 755b397..70aeeb7 100644
+---- a/main.c
+-+++ b/main.c
+-@@ -1,6 +1,6 @@
+- // MAIN 
+- /*
+--Author: BB01, 03/08/2022, CPR101, Final Project V1
+-+Author: BB01, 03/08/2022, CPR101, Final Project
+- main.c : MAIN
+- Purpose: Main Function used to prompt user for which various options.
+- */
+-
+ commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+ Author: kiararina <kiararina.pelenio@upou.edu.ph>
+ Date:   Mon Aug 8 09:38:48 2022 -0500
+@@ -882,329 +1527,6 @@ Date:   Thu Aug 4 16:30:00 2022 -0400
+ 
+     Version 1
+ 
+-diff --git a/Programming Comments.docx b/Programming Comments.docx
+-new file mode 100644
+-index 0000000..07d1cd7
+---- /dev/null
+-+++ b/Programming Comments.docx	
+-@@ -0,0 +1,110 @@
+-+                        Commenting Program Source Code
+-+--------------------------------------------------------------------------------
+-+Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+-+--------------------------------------------------------------------------------
+-+In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+-+Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+-+Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+-+Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+-+Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+-+You know you have good comments if you delete all the code and what's left still makes sense as a program.
+-+Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+-+75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+-+Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+-+Comments are for programmers who will maintain the code in the future. 
+-+Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+-+Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+-+--------------------------------------------------------------------------------
+-+Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+-+--------------------------------------------------------------------------------
+-+
+-+Organisation of Comments
+-+Program comments 
+-+ -  appear at the beginning of a source file.
+-+/* 
+-+Author: Name, email, ID, Date written, Course, Project
+-+[executable filename] : [title of program]
+-+Purpose: [what this program does, what problem does it solve?]
+-+*/
+-+
+-+Function comments
+-+The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+-+/*
+-+Purpose: [what this function does, what problem does it solve?]
+-+Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+-+Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+-+Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+-+*/
+-+
+-+Inline code comments
+-+Your comment must say something different than explaining the code itself. 
+-+c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+-+Ideally, variable names should be self-explanatory. When they are not, comments are required.
+-+c = a + b;  // c stores total of assignment and test marks respectively.
+-+
+-+Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+-+cryptic = C + code; 		// explain this line's purpose in the program
+-+crypticly = C + moreCode;	// explain this line's purpose in the program
+-+
+-+Longer code comments
+-+Sometimes comments need more space than would fit inline. 
+-+cryptic = C + code;
+-+// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+-+moreCrypticly = C + moreCode;	
+-+
+-+Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+-+// this comment explains the purpose of the next line of code  
+-+cryptic = C + code;
+-+ 		
+-+// this comment explains the purpose of the next line of code  
+-+moreCrypticly = C + moreCode;	
+-+		
+-+
+-+Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+-+
+-+Structures
+-+Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+-+// [what the structure accomplishes]
+-+e.g. 
+-+// compute factorial	
+-+// prompt user until value within range 1  -  100 is input
+-+Code Samples
+-+printf("Type a few words separated by space(q - to quit):\n");
+-+gets(words);
+-+while (strcmp(words, "q") != 0) 
+-+{
+-+    word = strtok(words, " ");
+-+    w_counter = 1;
+-+    while (word) 
+-+    {
+-+        printf("Word #%d is \'%s\'\n", w_counter++, word);
+-+        word = strtok(NULL, " ");
+-+    }
+-+    printf("Type a few words separated by space(q - to quit):\n");
+-+    gets(words);
+-+}
+-+
+-+ the first while continues until the 'words' variable is equal to "q". What is it for?
+-+ there is another while {structure} ... what does it do?
+-+ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+-+ // keep looping until pointer is NULL
+-+This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+-+ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+-+ This technique is even more important at the end of a series nested structures, e.g.
+-+      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+-+   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+-+} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+-+
+-+
+-+Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+-+
+-+while (TRUE) // a comment explains why there is no exit condition here
+-+{
+-+ 	. . .
+-+   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+-+   // --------- ********   make it visually obvious that this causes another iteration of the structure
+-+. . .
+-+   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+-+   // --------- *****      make it visually obvious that this is an exit from the structure
+-+. . .
+-+}
+-diff --git a/converting.c b/converting.c
+-new file mode 100644
+-index 0000000..c5a0775
+---- /dev/null
+-+++ b/converting.c
+-@@ -0,0 +1,43 @@
+-+// CONVERTING MODULE SOURCE
+-+/*
+-+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+-+converting.c : CONVERTING
+-+Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+-+*/
+-+
+-+#define	_CRT_SECURE_NO_WARNINGS
+-+#define BUFFER_SIZE 80
+-+
+-+// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+-+// strings and convert a string to an integer value.
+-+#include "converting.h"
+-+
+-+// V1
+-+void converting(void) {
+-+	// Display beginning message
+-+	printf("*** Start of Converting Strings to int Demo ***\n");
+-+
+-+	// Declare variables
+-+	char	intString[BUFFER_SIZE];
+-+	int		intNumber;
+-+
+-+	do {
+-+		// Prompt user for entry
+-+		printf("Type an int numeric string (q - to quit):\n");
+-+		fgets(intString, BUFFER_SIZE, stdin);
+-+		intString[strlen(intString) - 1] = '\0';
+-+
+-+		// Check user input, exit if 'q' was entered.
+-+		if (strcmp(intString, "q") != 0) {
+-+
+-+			// Convert user entry from string to integer value.
+-+			intNumber = atoi(intString);
+-+
+-+			// Display converted number.
+-+			printf("Converted number is %d\n", intNumber);
+-+		}
+-+	} while (strcmp(intString, "q") != 0);
+-+
+-+	// Display ending message and exit module.
+-+	printf("*** End of Converting Strings to int Demo ***\n\n");
+-+}
+-diff --git a/converting.h b/converting.h
+-new file mode 100644
+-index 0000000..03c62a3
+---- /dev/null
+-+++ b/converting.h
+-@@ -0,0 +1,18 @@
+-+// CONVERTING MODULE HEADER
+-+#ifndef _CONVERTING_H_
+-+#define _CONVERTING_H_
+-+
+-+// Libraries
+-+#include <stdio.h>
+-+#include <string.h>
+-+#include <stdlib.h>
+-+
+-+
+-+/////////////////////////
+-+// Prototype  Function //
+-+/////////////////////////
+-+
+-+// Function used to apply conversions
+-+void converting(void);
+-+
+-+#endif
+-diff --git a/fundamentals.c b/fundamentals.c
+-new file mode 100644
+-index 0000000..95c9f23
+---- /dev/null
+-+++ b/fundamentals.c
+-@@ -0,0 +1,43 @@
+-+/*
+-+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+-+fundamentals.c : indexing
+-+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+-+*/
+-+
+-+
+-+// FUNDAMENTALS MODULE SOURCE 
+-+#define _CRT_SECURE_NO_WARNINGS 
+-+#define BUFFER_SIZE 80
+-+#define NUM_INPUT_SIZE 10 
+-+#include "fundamentals.h"
+-+
+-+
+-+void fundamentals(void) {
+-+
+-+// V1
+-+    printf("*** start of Indexing Strings Demo ***\n"); 
+-+    char buffer1[BUFFER_SIZE]; 
+-+    char numInput[NUM_INPUT_SIZE]; 
+-+    size_t position; 
+-+    do {
+-+        printf("Type not empty string (q - to quit): \n"); 
+-+        fgets (buffer1, BUFFER_SIZE, stdin); 
+-+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+-+
+-+        // checks if entered string is not equals to 'q'.
+-+        if (strcmp (buffer1, "q") != 0) { 
+-+            printf("Type the character position within the string: \n"); 
+-+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+-+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+-+            position = atoi (numInput); // Converts entered string to integer.
+-+
+-+            // Checks if converted integer is larger then string length and assigns max position if true.
+-+            if (position >= strlen (buffer1)) { 
+-+                position = strlen (buffer1) - 1; 
+-+                printf("Too big... Position reduced to max. availbale\n");
+-+            }
+-+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+-+        }
+-+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+-+    printf("*** End of Indexing Strings Demo ***\n\n");
+-+}
+-\ No newline at end of file
+-diff --git a/fundamentals.h b/fundamentals.h
+-new file mode 100644
+-index 0000000..0433660
+---- /dev/null
+-+++ b/fundamentals.h
+-@@ -0,0 +1,12 @@
+-+// FUNDAMENTALS MODULE HEADER 
+-+#ifndef _FUNDAMENTALS_H_
+-+#define _FUNDAMENTALS_H_
+-+
+-+#include <stdio.h> 
+-+#include <stdlib.h> 
+-+#include <string.h>
+-+
+-+//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+-+void fundamentals(void);
+-+
+-+#endif
+-\ No newline at end of file
+-diff --git a/main.c b/main.c
+-new file mode 100644
+-index 0000000..755b397
+---- /dev/null
+-+++ b/main.c
+-@@ -0,0 +1,58 @@
+-+// MAIN 
+-+/*
+-+Author: BB01, 03/08/2022, CPR101, Final Project V1
+-+main.c : MAIN
+-+Purpose: Main Function used to prompt user for which various options.
+-+*/
+-+
+-+// Include all necessary modules
+-+#define _CRT_SECURE_NO_WARNINGS
+-+#include "fundamentals.h"
+-+#include "manipulating.h"
+-+#include "converting.h"
+-+#include "tokenizing.h"
+-+
+-+int main(void) {
+-+	// Declare variables
+-+	char buff[10];
+-+
+-+	// Open menu for user
+-+	do {
+-+		// Display menu options
+-+		printf("1 - Fundamentals\n");
+-+		printf("2 - Manipulation\n");
+-+		printf("3 - Converting\n");
+-+		printf("4 - Tokenizing\n");
+-+		printf("0 - Exit\n");
+-+		
+-+		// Prompt user for input
+-+		printf("Which module to run? \n");
+-+		fgets(buff, 10, stdin);
+-+
+-+		// Analyze user entry and match selection
+-+		switch (buff[0])
+-+		{
+-+		case '1': 
+-+			// Call for fundamentals module
+-+			fundamentals();
+-+			break;
+-+
+-+		case '2': 
+-+			// Call for manipulating module
+-+			manipulating();
+-+			break;
+-+
+-+		case '3': 
+-+			// Call for converting module
+-+			converting();
+-+			break;
+-+
+-+		case '4': 
+-+			// Call for tokenizing module
+-+			tokenizing();
+-+			break;
+-+		}
+-+	} while (buff[0] != '0');
+-+	
+-+	return 0;
+-+}
+-\ No newline at end of file
+ diff --git a/manipulating.c b/manipulating.c
+ new file mode 100644
+ index 0000000..748c895
+@@ -1263,83 +1585,3 @@ index 0000000..8a8f926
+ +/* Purpose: This function concatenates 2 input strings */
+ +
+ +#endif
+-diff --git a/tokenizing.c b/tokenizing.c
+-new file mode 100644
+-index 0000000..65d1c20
+---- /dev/null
+-+++ b/tokenizing.c
+-@@ -0,0 +1,42 @@
+-+/*
+-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-+[tokenizing.c] : [tokenizing]
+-+Purpose: [This function takes a user inputted string and tokenizes it]
+-+*/
+-+
+-+
+-+// TOKENIZING MODULE SOURCE
+-+#define _CRT_SECURE_NO_WARNINGS
+-+#define BUFFER_SIZE 300
+-+#include "tokenizing.h"
+-+
+-+// V1
+-+void tokenizing(void) {
+-+
+-+    printf("*** Start of Tokenizing Words Demo ***\n");
+-+    char words[BUFFER_SIZE];
+-+    char* nextWord = NULL;
+-+    int wordsCounter;
+-+    do {
+-+        printf("Type a few words seperated by space (q - to quit):\n");
+-+
+-+        fgets(words, BUFFER_SIZE, stdin); 
+-+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+
+-+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+
+-+        
+-+    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-+            while (nextWord) {
+-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+            }
+-+        }
+-+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+
+-+    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+}
+-+
+-+
+-diff --git a/tokenizing.h b/tokenizing.h
+-new file mode 100644
+-index 0000000..c00f3cb
+---- /dev/null
+-+++ b/tokenizing.h
+-@@ -0,0 +1,10 @@
+-+// Tokenization header file
+-+#ifndef _TOKENIZING_H_
+-+#define _TOKENIZING_H_
+-+
+-+#include <stdio.h>
+-+#include <string.h>
+-+
+-+void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-+
+-+#endif
+-\ No newline at end of file
+-
+-commit f914d3afae4107c77728b3df4d39502c962ba74b
+-Author: krpm <mungcalrina@gmail.com>
+-Date:   Thu Aug 4 15:48:50 2022 -0400
+-
+-    Initial commit
+-
+-diff --git a/.gitattributes b/.gitattributes
+-new file mode 100644
+-index 0000000..dfe0770
+---- /dev/null
+-+++ b/.gitattributes
+-@@ -0,0 +1,2 @@
+-+# Auto detect text files and perform LF normalization
+-+* text=auto
+diff --git a/manipulating_git_log.txt b/manipulating_git_log.txt
+deleted file mode 100644
+index 05aa537..0000000
+--- a/manipulating_git_log.txt
++++ /dev/null
+@@ -1,1587 +0,0 @@
+-commit e14f5c429efccb7dc63749da2a425659ad905631
+-Author: krpm <25734153+kiararina@users.noreply.github.com>
+-Date:   Fri Aug 12 08:37:11 2022 -0400
+-
+-    Update manipulating.c for version 3.
+-    
+-    Added a section for checking the occurrence of 2nd string in 1st string.
+-
+-diff --git a/manipulating.c b/manipulating.c
+-index 9193243..925e182 100644
+---- a/manipulating.c
+-+++ b/manipulating.c
+-@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
+- 
+- // V1
+- void manipulating(void) {
+--/* Purpose: This function concatenates 2 input strings */
+-+/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
+- 
+- 	printf("*** Start of Concatenating Strings Demo ***\n");
+- 	char string1[BUFFER_SIZE];
+-@@ -56,4 +56,27 @@ void manipulating(void) {
+- 		}
+- 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+- 	printf("*** End of Comparing Strings Demo ***\n\n");
+-+
+-+
+-+//V3
+-+	printf("*** Start of Searching Strings Demo ***\n");
+-+	char haystack[BUFFER_SIZE];
+-+	char needle[BUFFER_SIZE];
+-+	char* occurence = NULL;
+-+	do {
+-+		printf("Type the string (q - to quit):\n");
+-+		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
+-+		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
+-+		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
+-+			printf("Type the substring:\n");
+-+			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
+-+			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
+-+			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
+-+			if (occurence)							// If found, return the position where 2nd string occurs
+-+				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
+-+			else						
+-+				printf("Not found\n");				
+-+		}
+-+	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
+-+	printf("*** End of Searching Strings Demo ***\n\n");
+- }
+-\ No newline at end of file
+-
+-commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
+-Author: rsaguros <rsaguros1@myseneca.ca>
+-Date:   Tue Aug 9 23:04:40 2022 -0400
+-
+-    Adding git logs
+-    
+-    Version 2 Git Logs
+-    $ git --no-pager log -p > "module-git-log.txt"
+-
+-diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
+-new file mode 100644
+-index 0000000..7bb5209
+---- /dev/null
+-+++ b/manipulating-git-log.txt
+-@@ -0,0 +1,1345 @@
+-+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+-+Merge: 6361388 c3a8316
+-+Author: rsaguros <rsaguros1@myseneca.ca>
+-+Date:   Tue Aug 9 22:49:17 2022 -0400
+-+
+-+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+-+
+-+commit 63613886b8f1ecccb62538d6d4b7905425a16358
+-+Merge: 0626d2e c0f7dc8
+-+Author: rsaguros <rsaguros1@myseneca.ca>
+-+Date:   Tue Aug 9 22:47:37 2022 -0400
+-+
+-+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+-+
+-+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+-+Merge: 9d98950 c0f7dc8
+-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-+Date:   Tue Aug 9 22:46:28 2022 -0400
+-+
+-+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+-+
+-+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+-+Merge: fd97b97 a2a1bf4
+-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-+Date:   Tue Aug 9 22:44:47 2022 -0400
+-+
+-+    Merge pull request #1 from kiararina/converting
+-+    
+-+    Recovering lost commits up to converting.c
+-+
+-+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+-+Merge: cee497d fd97b97
+-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-+Date:   Tue Aug 9 22:44:00 2022 -0400
+-+
+-+    Merge branch 'main' into converting
+-+
+-+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-+Date:   Tue Aug 9 19:23:44 2022 -0400
+-+
+-+    tokenizing.c v2 corrected
+-+    
+-+    Corrected a previous error, now both v1 and v2 are within the same function name
+-+
+-+diff --git a/tokenizing.c b/tokenizing.c
+-+index 6332b6d..ae26066 100644
+-+--- a/tokenizing.c
+-++++ b/tokenizing.c
+-+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+-+ 
+-+ 
+-+ 
+-++void tokenizing(void) {
+-+ 
+-+-/*
+-+-// V1
+-+-//void tokenizing(void) {
+-+-
+-++    // V1
+-+     printf("*** Start of Tokenizing Words Demo ***\n");
+-+     char words[BUFFER_SIZE];
+-+     char* nextWord = NULL;
+-+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+-+     do {
+-+         printf("Type a few words seperated by space (q - to quit):\n");
+-+ 
+-+-        fgets(words, BUFFER_SIZE, stdin); 
+-++        fgets(words, BUFFER_SIZE, stdin);
+-+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+ 
+-+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+-+ 
+-+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-+             while (nextWord) {
+-+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+-+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+             }
+-+-       }
+-++        }
+-+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+ 
+-+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-+-}
+-+-*/
+-+ 
+-+ 
+-+-// V2
+-+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-+-void tokenizing(void) {
+-+-
+-++    // V2
+-++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-+     printf("*** Start of Tokenizing Words Demo ***\n");
+-+     char phrases[BUFFER_SIZE];
+-+     char* nextPhrase = NULL;
+-+
+-+commit 23f162166b815502c16ac1456d8f9be87b799f26
+-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-+Date:   Tue Aug 9 19:09:02 2022 -0400
+-+
+-+    Update tokenizing.c to V2
+-+
+-+diff --git a/tokenizing.c b/tokenizing.c
+-+index edc3184..6332b6d 100644
+-+--- a/tokenizing.c
+-++++ b/tokenizing.c
+-+@@ -1,5 +1,5 @@
+-+ /*
+-+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-+ [tokenizing.c] : [tokenizing]
+-+ Purpose: [This function takes a user inputted string and tokenizes it]
+-+ */
+-+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+-+ #include "tokenizing.h"
+-+ 
+-+ 
+-+-int main(void) {
+-+-    tokenizing();
+-+-    return 0;
+-+-}
+-+ 
+-+ 
+-++/*
+-+ // V1
+-+-void tokenizing(void) {
+-++//void tokenizing(void) {
+-+ 
+-+     printf("*** Start of Tokenizing Words Demo ***\n");
+-+     char words[BUFFER_SIZE];
+-+@@ -34,16 +31,46 @@ void tokenizing(void) {
+-+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+ 
+-+-        
+-+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-+             while (nextWord) {
+-+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+             }
+-+-        }
+-++       }
+-+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+ 
+-+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-+ }
+-++*/
+-++
+-++
+-++// V2
+-++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-++void tokenizing(void) {
+-++
+-++    printf("*** Start of Tokenizing Words Demo ***\n");
+-++    char phrases[BUFFER_SIZE];
+-++    char* nextPhrase = NULL;
+-++    int phrasesCounter;
+-++    do {
+-++        printf("Type a few words seperated by comma (q - to quit):\n");
+-++
+-++        fgets(phrases, BUFFER_SIZE, stdin); 
+-++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-++
+-++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-++
+-++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-++            while (nextPhrase) {
+-++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-++            }
+-++        }
+-++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-++
+-++    printf("*** End of Tokenizing Words Demo ***\n\n");
+-++}
+-+ 
+-+ 
+-+
+-+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-+Date:   Tue Aug 9 19:06:55 2022 -0400
+-+
+-+    V1
+-+
+-+diff --git a/tokenizing.c b/tokenizing.c
+-+index 417d34a..edc3184 100644
+-+--- a/tokenizing.c
+-++++ b/tokenizing.c
+-+@@ -1,80 +1,49 @@
+-+-/*
+-+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-+-[tokenizing.c] : [tokenizing]
+-+-Purpose: [This function takes a user inputted string and tokenizes it]
+-+-*/
+-+-
+-+-
+-+-// TOKENIZING MODULE SOURCE
+-+-#define _CRT_SECURE_NO_WARNINGS
+-+-#define BUFFER_SIZE 300
+-+-#include "tokenizing.h"
+-+-
+-+-
+-+-int main(void) {
+-+-    tokenizing();
+-+-    return 0;
+-+-}
+-+-
+-+-
+-+-/*
+-+-// V1
+-+-//void tokenizing(void) {
+-+-
+-+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-+-    char words[BUFFER_SIZE];
+-+-    char* nextWord = NULL;
+-+-    int wordsCounter;
+-+-    do {
+-+-        printf("Type a few words seperated by space (q - to quit):\n");
+-+-
+-+-        fgets(words, BUFFER_SIZE, stdin); 
+-+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+-
+-+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+-
+-+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-+-            while (nextWord) {
+-+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+-            }
+-+-       }
+-+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+-
+-+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+-}
+-+-*/
+-+-
+-+-
+-+-// V2
+-+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-+-void tokenizing(void) {
+-+-
+-+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-+-    char phrases[BUFFER_SIZE];
+-+-    char* nextPhrase = NULL;
+-+-    int phrasesCounter;
+-+-    do {
+-+-        printf("Type a few words seperated by comma (q - to quit):\n");
+-+-
+-+-        fgets(phrases, BUFFER_SIZE, stdin); 
+-+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+-
+-+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+-
+-+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-+-            while (nextPhrase) {
+-+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-+-            }
+-+-        }
+-+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+-
+-+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+-}
+-+-
+-+-
+-++/*
+-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-++[tokenizing.c] : [tokenizing]
+-++Purpose: [This function takes a user inputted string and tokenizes it]
+-++*/
+-++
+-++
+-++// TOKENIZING MODULE SOURCE
+-++#define _CRT_SECURE_NO_WARNINGS
+-++#define BUFFER_SIZE 300
+-++#include "tokenizing.h"
+-++
+-++
+-++int main(void) {
+-++    tokenizing();
+-++    return 0;
+-++}
+-++
+-++
+-++// V1
+-++void tokenizing(void) {
+-++
+-++    printf("*** Start of Tokenizing Words Demo ***\n");
+-++    char words[BUFFER_SIZE];
+-++    char* nextWord = NULL;
+-++    int wordsCounter;
+-++    do {
+-++        printf("Type a few words seperated by space (q - to quit):\n");
+-++
+-++        fgets(words, BUFFER_SIZE, stdin); 
+-++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-++
+-++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-++
+-++        
+-++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-++            while (nextWord) {
+-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-++            }
+-++        }
+-++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-++
+-++    printf("*** End of Tokenizing Words Demo ***\n\n");
+-++}
+-++
+-++
+-+
+-+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+-+Author: CRYPTO43 <singharshjot07@gmail.com>
+-+Date:   Tue Aug 9 17:12:27 2022 -0400
+-+
+-+    first commit
+-+
+-+diff --git a/fundamentals.c b/fundamentals.c
+-+new file mode 100644
+-+index 0000000..cd7cd9f
+-+--- /dev/null
+-++++ b/fundamentals.c
+-+@@ -0,0 +1,63 @@
+-++/*
+-++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+-++fundamentals.c : indexing
+-++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+-++*/
+-++
+-++
+-++// FUNDAMENTALS MODULE SOURCE 
+-++#define _CRT_SECURE_NO_WARNINGS 
+-++#define BUFFER_SIZE 80
+-++#define NUM_INPUT_SIZE 10 
+-++#include "fundamentals.h"
+-++
+-++
+-++void main(void) {
+-++
+-++// V1
+-++    printf("*** start of Indexing Strings Demo ***\n"); 
+-++    char buffer1[BUFFER_SIZE]; 
+-++    char numInput[NUM_INPUT_SIZE]; 
+-++    size_t position; 
+-++    do {
+-++        printf("Type not empty string (q - to quit): \n"); 
+-++        fgets (buffer1, BUFFER_SIZE, stdin); 
+-++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+-++
+-++        // checks if entered string is not equals to 'q'.
+-++        if (strcmp (buffer1, "q") != 0) { 
+-++            printf("Type the character position within the string: \n"); 
+-++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+-++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+-++            position = atoi (numInput); // Converts entered string to integer.
+-++
+-++            // Checks if converted integer is larger then string length and assigns max position if true.
+-++            if (position >= strlen (buffer1)) { 
+-++                position = strlen (buffer1) - 1; 
+-++                printf("Too big... Position reduced to max. availbale\n");
+-++            }
+-++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+-++        }
+-++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+-++    printf("*** End of Indexing Strings Demo ***\n\n");
+-++
+-++
+-++
+-++    // V2 
+-++    printf("*** Start of Measuring Strings Demo ***\n"); 
+-++    char buffer2[BUFFER_SIZE]; 
+-++    do { 
+-++        printf("Type a string (q - to quit):\n"); 
+-++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+-++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+-++
+-++        // checks if entered string is not equals to 'q'.
+-++        if (strcmp(buffer2, "q") != 0) 
+-++            printf("The length of \'%s\' is %d characters\n", 
+-++            buffer2, (int)strlen(buffer2)); 
+-++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+-++        
+-++        printf("*** End of Measuring Strings Demo ***\n\n");
+-++}
+-++
+-++ 
+-+\ No newline at end of file
+-+diff --git a/fundamentals.h b/fundamentals.h
+-+new file mode 100644
+-+index 0000000..383cccc
+-+--- /dev/null
+-++++ b/fundamentals.h
+-+@@ -0,0 +1,12 @@
+-++// FUNDAMENTALS MODULE HEADER 
+-++#ifndef _FUNDAMENTALS_H_
+-++#define _FUNDAMENTALS_H_
+-++
+-++#include <stdio.h> 
+-++#include <stdlib.h> 
+-++#include <string.h>
+-++
+-++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+-++void main(void);
+-++
+-++#endif
+-+\ No newline at end of file
+-+
+-+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+-+Date:   Tue Aug 9 16:17:34 2022 -0400
+-+
+-+    Add files via upload
+-+    
+-+    Version 2
+-+
+-+diff --git a/tokenizing.c b/tokenizing.c
+-+index 65d1c20..417d34a 100644
+-+--- a/tokenizing.c
+-++++ b/tokenizing.c
+-+@@ -1,42 +1,80 @@
+-+-/*
+-+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-+-[tokenizing.c] : [tokenizing]
+-+-Purpose: [This function takes a user inputted string and tokenizes it]
+-+-*/
+-+-
+-+-
+-+-// TOKENIZING MODULE SOURCE
+-+-#define _CRT_SECURE_NO_WARNINGS
+-+-#define BUFFER_SIZE 300
+-+-#include "tokenizing.h"
+-+-
+-+-// V1
+-+-void tokenizing(void) {
+-+-
+-+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-+-    char words[BUFFER_SIZE];
+-+-    char* nextWord = NULL;
+-+-    int wordsCounter;
+-+-    do {
+-+-        printf("Type a few words seperated by space (q - to quit):\n");
+-+-
+-+-        fgets(words, BUFFER_SIZE, stdin); 
+-+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-+-
+-+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-+-
+-+-        
+-+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-+-            while (nextWord) {
+-+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-+-            }
+-+-        }
+-+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-+-
+-+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-+-}
+-+-
+-+-
+-++/*
+-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-++[tokenizing.c] : [tokenizing]
+-++Purpose: [This function takes a user inputted string and tokenizes it]
+-++*/
+-++
+-++
+-++// TOKENIZING MODULE SOURCE
+-++#define _CRT_SECURE_NO_WARNINGS
+-++#define BUFFER_SIZE 300
+-++#include "tokenizing.h"
+-++
+-++
+-++int main(void) {
+-++    tokenizing();
+-++    return 0;
+-++}
+-++
+-++
+-++/*
+-++// V1
+-++//void tokenizing(void) {
+-++
+-++    printf("*** Start of Tokenizing Words Demo ***\n");
+-++    char words[BUFFER_SIZE];
+-++    char* nextWord = NULL;
+-++    int wordsCounter;
+-++    do {
+-++        printf("Type a few words seperated by space (q - to quit):\n");
+-++
+-++        fgets(words, BUFFER_SIZE, stdin); 
+-++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-++
+-++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-++
+-++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-++            while (nextWord) {
+-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-++            }
+-++       }
+-++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-++
+-++    printf("*** End of Tokenizing Words Demo ***\n\n");
+-++}
+-++*/
+-++
+-++
+-++// V2
+-++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-++void tokenizing(void) {
+-++
+-++    printf("*** Start of Tokenizing Words Demo ***\n");
+-++    char phrases[BUFFER_SIZE];
+-++    char* nextPhrase = NULL;
+-++    int phrasesCounter;
+-++    do {
+-++        printf("Type a few words seperated by comma (q - to quit):\n");
+-++
+-++        fgets(phrases, BUFFER_SIZE, stdin); 
+-++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-++
+-++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-++
+-++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-++            while (nextPhrase) {
+-++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-++            }
+-++        }
+-++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-++
+-++    printf("*** End of Tokenizing Words Demo ***\n\n");
+-++}
+-++
+-++
+-+diff --git a/tokenizing.h b/tokenizing.h
+-+index c00f3cb..7899cc2 100644
+-+--- a/tokenizing.h
+-++++ b/tokenizing.h
+-+@@ -1,10 +1,10 @@
+-+-// Tokenization header file
+-+-#ifndef _TOKENIZING_H_
+-+-#define _TOKENIZING_H_
+-+-
+-+-#include <stdio.h>
+-+-#include <string.h>
+-+-
+-+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-+-
+-++// Tokenization header file
+-++#ifndef _TOKENIZING_H_
+-++#define _TOKENIZING_H_
+-++
+-++#include <stdio.h>
+-++#include <string.h>
+-++
+-++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-++
+-+ #endif
+-+\ No newline at end of file
+-+
+-+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+-+Author: rsaguros <rsaguros1@myseneca.ca>
+-+Date:   Mon Aug 8 15:47:34 2022 -0400
+-+
+-+    Version 2
+-+    
+-+    Version 2
+-+
+-+diff --git a/converting.c b/converting.c
+-+index c5a0775..df23173 100644
+-+--- a/converting.c
+-++++ b/converting.c
+-+@@ -1,6 +1,6 @@
+-+ // CONVERTING MODULE SOURCE
+-+ /*
+-+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+-++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+-+ converting.c : CONVERTING
+-+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+-+ */
+-+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+-+ // strings and convert a string to an integer value.
+-+ #include "converting.h"
+-+ 
+-+-// V1
+-+ void converting(void) {
+-++	// V1
+-+ 	// Display beginning message
+-+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+-+ 
+-+@@ -38,6 +38,30 @@ void converting(void) {
+-+ 		}
+-+ 	} while (strcmp(intString, "q") != 0);
+-+ 
+-+-	// Display ending message and exit module.
+-++	// Display ending message for int demo
+-+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+-++
+-++	// V2
+-++	printf("*** Start of Converting Strings to double Demo ***\n");
+-++
+-++	char	doubleString[BUFFER_SIZE];
+-++	double	doubleNumber;
+-++
+-++	do {
+-++		// Prompt user for entry, replacing the new line read by 
+-++		// fgets with a null terminator
+-++		printf("Type an double numeric string (q - to quit):\n");
+-++		fgets(doubleString, BUFFER_SIZE, stdin);
+-++		doubleString[strlen(doubleString) - 1] = '\0';
+-++
+-++		// Check user input, exit if 'q' was entered.  
+-++		if ((strcmp(doubleString, "q") != 0)) {
+-++
+-++			// Convert user entry from numeric string to a double, then display it
+-++			doubleNumber = atof(doubleString);
+-++			printf("Converted number is %f\n", doubleNumber);
+-++		}
+-++	} while (strcmp(doubleString, "q") != 0);
+-++
+-++	printf("*** End of Converting Strings to double Demo ***\n\n");
+-+ }
+-+
+-+commit e25ade313038da86c407f85f5c00586ba6b37a1b
+-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-+Date:   Mon Aug 8 15:05:20 2022 -0400
+-+
+-+    Update README.md
+-+
+-+diff --git a/README.md b/README.md
+-+index 28e7c31..f1ff45d 100644
+-+--- a/README.md
+-++++ b/README.md
+-+@@ -1,5 +1,8 @@
+-+ # CPR101_Project
+-+ CPR101 Final Project
+-++
+-+ Section: NAA
+-++
+-+ Group 1
+-++
+-+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+-+
+-+commit a3e1e5ae394af27b186e61562b7167819c90ea13
+-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+-+Date:   Mon Aug 8 15:01:47 2022 -0400
+-+
+-+    Create README.md
+-+
+-+diff --git a/README.md b/README.md
+-+new file mode 100644
+-+index 0000000..28e7c31
+-+--- /dev/null
+-++++ b/README.md
+-+@@ -0,0 +1,5 @@
+-++# CPR101_Project
+-++CPR101 Final Project
+-++Section: NAA
+-++Group 1
+-++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+-+
+-+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+-+Author: rsaguros <rsaguros1@myseneca.ca>
+-+Date:   Mon Aug 8 13:58:05 2022 -0400
+-+
+-+    Update converting.c
+-+    
+-+    Version 2
+-+
+-+diff --git a/converting.c b/converting.c
+-+index c5a0775..df23173 100644
+-+--- a/converting.c
+-++++ b/converting.c
+-+@@ -1,6 +1,6 @@
+-+ // CONVERTING MODULE SOURCE
+-+ /*
+-+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+-++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+-+ converting.c : CONVERTING
+-+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+-+ */
+-+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+-+ // strings and convert a string to an integer value.
+-+ #include "converting.h"
+-+ 
+-+-// V1
+-+ void converting(void) {
+-++	// V1
+-+ 	// Display beginning message
+-+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+-+ 
+-+@@ -38,6 +38,30 @@ void converting(void) {
+-+ 		}
+-+ 	} while (strcmp(intString, "q") != 0);
+-+ 
+-+-	// Display ending message and exit module.
+-++	// Display ending message for int demo
+-+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+-++
+-++	// V2
+-++	printf("*** Start of Converting Strings to double Demo ***\n");
+-++
+-++	char	doubleString[BUFFER_SIZE];
+-++	double	doubleNumber;
+-++
+-++	do {
+-++		// Prompt user for entry, replacing the new line read by 
+-++		// fgets with a null terminator
+-++		printf("Type an double numeric string (q - to quit):\n");
+-++		fgets(doubleString, BUFFER_SIZE, stdin);
+-++		doubleString[strlen(doubleString) - 1] = '\0';
+-++
+-++		// Check user input, exit if 'q' was entered.  
+-++		if ((strcmp(doubleString, "q") != 0)) {
+-++
+-++			// Convert user entry from numeric string to a double, then display it
+-++			doubleNumber = atof(doubleString);
+-++			printf("Converted number is %f\n", doubleNumber);
+-++		}
+-++	} while (strcmp(doubleString, "q") != 0);
+-++
+-++	printf("*** End of Converting Strings to double Demo ***\n\n");
+-+ }
+-+
+-+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+-+Author: krpm <mungcalrina@gmail.com>
+-+Date:   Mon Aug 8 13:43:58 2022 -0400
+-+
+-+    Update manipulating.c
+-+
+-+diff --git a/manipulating.c b/manipulating.c
+-+index 953e516..9193243 100644
+-+--- a/manipulating.c
+-++++ b/manipulating.c
+-+@@ -41,7 +41,7 @@ void manipulating(void) {
+-+ 	do {
+-+ 		printf("Type the 1st string to compare (q - to quit):\n");
+-+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+-++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+-+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+-+ 			printf("Type the 2nd string to compare:\n");
+-+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+-+
+-+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+-+Author: krpm <mungcalrina@gmail.com>
+-+Date:   Mon Aug 8 12:51:35 2022 -0400
+-+
+-+    Version 2
+-+    
+-+    Updated main for version 2
+-+
+-+diff --git a/main.c b/main.c
+-+index 755b397..70aeeb7 100644
+-+--- a/main.c
+-++++ b/main.c
+-+@@ -1,6 +1,6 @@
+-+ // MAIN 
+-+ /*
+-+-Author: BB01, 03/08/2022, CPR101, Final Project V1
+-++Author: BB01, 03/08/2022, CPR101, Final Project
+-+ main.c : MAIN
+-+ Purpose: Main Function used to prompt user for which various options.
+-+ */
+-+
+-+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+-+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+-+Date:   Mon Aug 8 09:38:48 2022 -0500
+-+
+-+    Version 2
+-+    
+-+    Added version 2 codes
+-+
+-+diff --git a/manipulating.c b/manipulating.c
+-+index 9bde2d2..953e516 100644
+-+--- a/manipulating.c
+-++++ b/manipulating.c
+-+@@ -1,5 +1,5 @@
+-+ /*
+-+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+-++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+-+ manipulating.c : Manipulating
+-+ Purpose: This program manipulates input strings
+-+ */
+-+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+-+ #include "manipulating.h" 
+-+ /* Contains function prototypes and library declarations */
+-+ 
+-++// V1
+-+ void manipulating(void) {
+-+ /* Purpose: This function concatenates 2 input strings */
+-+ 
+-+@@ -19,16 +20,40 @@ void manipulating(void) {
+-+ 
+-+ 	do {
+-+ 		printf("Type the 1st string (q - to quit):\n");
+-+-		fgets(string1, BUFFER_SIZE, stdin);
+-+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+-++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+-++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+-+ 
+-+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+-+ 			printf("Type the 2nd string:\n");
+-+-			fgets(string2, BUFFER_SIZE, stdin);
+-++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+-+ 			strcat(string1, string2);
+-+ 			printf("Concatenated string is \'%s\'\n", string1);
+-+ 		}
+-+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+-+ 
+-+ 	printf("*** End of Concatenating Strings Demo ***\n");
+-++
+-++//V2
+-++	printf("*** Start of Comparing Strings Demo ***\n");
+-++	char compare1[BUFFER_SIZE];
+-++	char compare2[BUFFER_SIZE];
+-++	int result;
+-++	do {
+-++		printf("Type the 1st string to compare (q - to quit):\n");
+-++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+-++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+-++			printf("Type the 2nd string to compare:\n");
+-++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+-++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+-++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+-++			if (result < 0)
+-++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+-++			else if (result == 0)
+-++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+-++			else
+-++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+-++		}
+-++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+-++	printf("*** End of Comparing Strings Demo ***\n\n");
+-+ }
+-+\ No newline at end of file
+-+
+-+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+-+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+-+Date:   Thu Aug 4 15:34:34 2022 -0500
+-+
+-+    Update manipulating.c
+-+
+-+diff --git a/manipulating.c b/manipulating.c
+-+index 748c895..9bde2d2 100644
+-+--- a/manipulating.c
+-++++ b/manipulating.c
+-+@@ -1,5 +1,5 @@
+-+ /*
+-+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+-++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+-+ manipulating.c : Manipulating
+-+ Purpose: This program manipulates input strings
+-+ */
+-+
+-+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+-+Author: krpm <mungcalrina@gmail.com>
+-+Date:   Thu Aug 4 16:30:00 2022 -0400
+-+
+-+    Version 1
+-+
+-+diff --git a/Programming Comments.docx b/Programming Comments.docx
+-+new file mode 100644
+-+index 0000000..07d1cd7
+-+--- /dev/null
+-++++ b/Programming Comments.docx	
+-+@@ -0,0 +1,110 @@
+-++                        Commenting Program Source Code
+-++--------------------------------------------------------------------------------
+-++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+-++--------------------------------------------------------------------------------
+-++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+-++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+-++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+-++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+-++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+-++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+-++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+-++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+-++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+-++Comments are for programmers who will maintain the code in the future. 
+-++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+-++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+-++--------------------------------------------------------------------------------
+-++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+-++--------------------------------------------------------------------------------
+-++
+-++Organisation of Comments
+-++Program comments 
+-++ -  appear at the beginning of a source file.
+-++/* 
+-++Author: Name, email, ID, Date written, Course, Project
+-++[executable filename] : [title of program]
+-++Purpose: [what this program does, what problem does it solve?]
+-++*/
+-++
+-++Function comments
+-++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+-++/*
+-++Purpose: [what this function does, what problem does it solve?]
+-++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+-++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+-++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+-++*/
+-++
+-++Inline code comments
+-++Your comment must say something different than explaining the code itself. 
+-++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+-++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+-++c = a + b;  // c stores total of assignment and test marks respectively.
+-++
+-++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+-++cryptic = C + code; 		// explain this line's purpose in the program
+-++crypticly = C + moreCode;	// explain this line's purpose in the program
+-++
+-++Longer code comments
+-++Sometimes comments need more space than would fit inline. 
+-++cryptic = C + code;
+-++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+-++moreCrypticly = C + moreCode;	
+-++
+-++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+-++// this comment explains the purpose of the next line of code  
+-++cryptic = C + code;
+-++ 		
+-++// this comment explains the purpose of the next line of code  
+-++moreCrypticly = C + moreCode;	
+-++		
+-++
+-++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+-++
+-++Structures
+-++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+-++// [what the structure accomplishes]
+-++e.g. 
+-++// compute factorial	
+-++// prompt user until value within range 1  -  100 is input
+-++Code Samples
+-++printf("Type a few words separated by space(q - to quit):\n");
+-++gets(words);
+-++while (strcmp(words, "q") != 0) 
+-++{
+-++    word = strtok(words, " ");
+-++    w_counter = 1;
+-++    while (word) 
+-++    {
+-++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+-++        word = strtok(NULL, " ");
+-++    }
+-++    printf("Type a few words separated by space(q - to quit):\n");
+-++    gets(words);
+-++}
+-++
+-++ the first while continues until the 'words' variable is equal to "q". What is it for?
+-++ there is another while {structure} ... what does it do?
+-++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+-++ // keep looping until pointer is NULL
+-++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+-++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+-++ This technique is even more important at the end of a series nested structures, e.g.
+-++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+-++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+-++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+-++
+-++
+-++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+-++
+-++while (TRUE) // a comment explains why there is no exit condition here
+-++{
+-++ 	. . .
+-++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+-++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+-++. . .
+-++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+-++   // --------- *****      make it visually obvious that this is an exit from the structure
+-++. . .
+-++}
+-+diff --git a/converting.c b/converting.c
+-+new file mode 100644
+-+index 0000000..c5a0775
+-+--- /dev/null
+-++++ b/converting.c
+-+@@ -0,0 +1,43 @@
+-++// CONVERTING MODULE SOURCE
+-++/*
+-++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+-++converting.c : CONVERTING
+-++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+-++*/
+-++
+-++#define	_CRT_SECURE_NO_WARNINGS
+-++#define BUFFER_SIZE 80
+-++
+-++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+-++// strings and convert a string to an integer value.
+-++#include "converting.h"
+-++
+-++// V1
+-++void converting(void) {
+-++	// Display beginning message
+-++	printf("*** Start of Converting Strings to int Demo ***\n");
+-++
+-++	// Declare variables
+-++	char	intString[BUFFER_SIZE];
+-++	int		intNumber;
+-++
+-++	do {
+-++		// Prompt user for entry
+-++		printf("Type an int numeric string (q - to quit):\n");
+-++		fgets(intString, BUFFER_SIZE, stdin);
+-++		intString[strlen(intString) - 1] = '\0';
+-++
+-++		// Check user input, exit if 'q' was entered.
+-++		if (strcmp(intString, "q") != 0) {
+-++
+-++			// Convert user entry from string to integer value.
+-++			intNumber = atoi(intString);
+-++
+-++			// Display converted number.
+-++			printf("Converted number is %d\n", intNumber);
+-++		}
+-++	} while (strcmp(intString, "q") != 0);
+-++
+-++	// Display ending message and exit module.
+-++	printf("*** End of Converting Strings to int Demo ***\n\n");
+-++}
+-+diff --git a/converting.h b/converting.h
+-+new file mode 100644
+-+index 0000000..03c62a3
+-+--- /dev/null
+-++++ b/converting.h
+-+@@ -0,0 +1,18 @@
+-++// CONVERTING MODULE HEADER
+-++#ifndef _CONVERTING_H_
+-++#define _CONVERTING_H_
+-++
+-++// Libraries
+-++#include <stdio.h>
+-++#include <string.h>
+-++#include <stdlib.h>
+-++
+-++
+-++/////////////////////////
+-++// Prototype  Function //
+-++/////////////////////////
+-++
+-++// Function used to apply conversions
+-++void converting(void);
+-++
+-++#endif
+-+diff --git a/fundamentals.c b/fundamentals.c
+-+new file mode 100644
+-+index 0000000..95c9f23
+-+--- /dev/null
+-++++ b/fundamentals.c
+-+@@ -0,0 +1,43 @@
+-++/*
+-++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+-++fundamentals.c : indexing
+-++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+-++*/
+-++
+-++
+-++// FUNDAMENTALS MODULE SOURCE 
+-++#define _CRT_SECURE_NO_WARNINGS 
+-++#define BUFFER_SIZE 80
+-++#define NUM_INPUT_SIZE 10 
+-++#include "fundamentals.h"
+-++
+-++
+-++void fundamentals(void) {
+-++
+-++// V1
+-++    printf("*** start of Indexing Strings Demo ***\n"); 
+-++    char buffer1[BUFFER_SIZE]; 
+-++    char numInput[NUM_INPUT_SIZE]; 
+-++    size_t position; 
+-++    do {
+-++        printf("Type not empty string (q - to quit): \n"); 
+-++        fgets (buffer1, BUFFER_SIZE, stdin); 
+-++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+-++
+-++        // checks if entered string is not equals to 'q'.
+-++        if (strcmp (buffer1, "q") != 0) { 
+-++            printf("Type the character position within the string: \n"); 
+-++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+-++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+-++            position = atoi (numInput); // Converts entered string to integer.
+-++
+-++            // Checks if converted integer is larger then string length and assigns max position if true.
+-++            if (position >= strlen (buffer1)) { 
+-++                position = strlen (buffer1) - 1; 
+-++                printf("Too big... Position reduced to max. availbale\n");
+-++            }
+-++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+-++        }
+-++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+-++    printf("*** End of Indexing Strings Demo ***\n\n");
+-++}
+-+\ No newline at end of file
+-+diff --git a/fundamentals.h b/fundamentals.h
+-+new file mode 100644
+-+index 0000000..0433660
+-+--- /dev/null
+-++++ b/fundamentals.h
+-+@@ -0,0 +1,12 @@
+-++// FUNDAMENTALS MODULE HEADER 
+-++#ifndef _FUNDAMENTALS_H_
+-++#define _FUNDAMENTALS_H_
+-++
+-++#include <stdio.h> 
+-++#include <stdlib.h> 
+-++#include <string.h>
+-++
+-++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+-++void fundamentals(void);
+-++
+-++#endif
+-+\ No newline at end of file
+-+diff --git a/main.c b/main.c
+-+new file mode 100644
+-+index 0000000..755b397
+-+--- /dev/null
+-++++ b/main.c
+-+@@ -0,0 +1,58 @@
+-++// MAIN 
+-++/*
+-++Author: BB01, 03/08/2022, CPR101, Final Project V1
+-++main.c : MAIN
+-++Purpose: Main Function used to prompt user for which various options.
+-++*/
+-++
+-++// Include all necessary modules
+-++#define _CRT_SECURE_NO_WARNINGS
+-++#include "fundamentals.h"
+-++#include "manipulating.h"
+-++#include "converting.h"
+-++#include "tokenizing.h"
+-++
+-++int main(void) {
+-++	// Declare variables
+-++	char buff[10];
+-++
+-++	// Open menu for user
+-++	do {
+-++		// Display menu options
+-++		printf("1 - Fundamentals\n");
+-++		printf("2 - Manipulation\n");
+-++		printf("3 - Converting\n");
+-++		printf("4 - Tokenizing\n");
+-++		printf("0 - Exit\n");
+-++		
+-++		// Prompt user for input
+-++		printf("Which module to run? \n");
+-++		fgets(buff, 10, stdin);
+-++
+-++		// Analyze user entry and match selection
+-++		switch (buff[0])
+-++		{
+-++		case '1': 
+-++			// Call for fundamentals module
+-++			fundamentals();
+-++			break;
+-++
+-++		case '2': 
+-++			// Call for manipulating module
+-++			manipulating();
+-++			break;
+-++
+-++		case '3': 
+-++			// Call for converting module
+-++			converting();
+-++			break;
+-++
+-++		case '4': 
+-++			// Call for tokenizing module
+-++			tokenizing();
+-++			break;
+-++		}
+-++	} while (buff[0] != '0');
+-++	
+-++	return 0;
+-++}
+-+\ No newline at end of file
+-+diff --git a/manipulating.c b/manipulating.c
+-+new file mode 100644
+-+index 0000000..748c895
+-+--- /dev/null
+-++++ b/manipulating.c
+-+@@ -0,0 +1,34 @@
+-++/*
+-++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+-++manipulating.c : Manipulating
+-++Purpose: This program manipulates input strings
+-++*/
+-++
+-++#define _CRT_SECURE_NO_WARNINGS
+-++#define BUFFER_SIZE 80
+-++
+-++#include "manipulating.h" 
+-++/* Contains function prototypes and library declarations */
+-++
+-++void manipulating(void) {
+-++/* Purpose: This function concatenates 2 input strings */
+-++
+-++	printf("*** Start of Concatenating Strings Demo ***\n");
+-++	char string1[BUFFER_SIZE];
+-++	char string2[BUFFER_SIZE];
+-++
+-++	do {
+-++		printf("Type the 1st string (q - to quit):\n");
+-++		fgets(string1, BUFFER_SIZE, stdin);
+-++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+-++
+-++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+-++			printf("Type the 2nd string:\n");
+-++			fgets(string2, BUFFER_SIZE, stdin);
+-++			strcat(string1, string2);
+-++			printf("Concatenated string is \'%s\'\n", string1);
+-++		}
+-++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+-++
+-++	printf("*** End of Concatenating Strings Demo ***\n");
+-++}
+-+\ No newline at end of file
+-+diff --git a/manipulating.h b/manipulating.h
+-+new file mode 100644
+-+index 0000000..8a8f926
+-+--- /dev/null
+-++++ b/manipulating.h
+-+@@ -0,0 +1,11 @@
+-++//MANIPULATING MODULE HEADER
+-++#ifndef _MANIPULATING_H_
+-++#define _MANIPULATING_H_
+-++
+-++#include <stdio.h>		// For input/output and printing
+-++#include <string.h>		// For string manipulation functions
+-++
+-++void manipulating(void);
+-++/* Purpose: This function concatenates 2 input strings */
+-++
+-++#endif
+-+diff --git a/tokenizing.c b/tokenizing.c
+-+new file mode 100644
+-+index 0000000..65d1c20
+-+--- /dev/null
+-++++ b/tokenizing.c
+-+@@ -0,0 +1,42 @@
+-++/*
+-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-++[tokenizing.c] : [tokenizing]
+-++Purpose: [This function takes a user inputted string and tokenizes it]
+-++*/
+-++
+-++
+-++// TOKENIZING MODULE SOURCE
+-++#define _CRT_SECURE_NO_WARNINGS
+-++#define BUFFER_SIZE 300
+-++#include "tokenizing.h"
+-++
+-++// V1
+-++void tokenizing(void) {
+-++
+-++    printf("*** Start of Tokenizing Words Demo ***\n");
+-++    char words[BUFFER_SIZE];
+-++    char* nextWord = NULL;
+-++    int wordsCounter;
+-++    do {
+-++        printf("Type a few words seperated by space (q - to quit):\n");
+-++
+-++        fgets(words, BUFFER_SIZE, stdin); 
+-++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-++
+-++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-++
+-++        
+-++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-++            while (nextWord) {
+-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-++            }
+-++        }
+-++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-++
+-++    printf("*** End of Tokenizing Words Demo ***\n\n");
+-++}
+-++
+-++
+-+diff --git a/tokenizing.h b/tokenizing.h
+-+new file mode 100644
+-+index 0000000..c00f3cb
+-+--- /dev/null
+-++++ b/tokenizing.h
+-+@@ -0,0 +1,10 @@
+-++// Tokenization header file
+-++#ifndef _TOKENIZING_H_
+-++#define _TOKENIZING_H_
+-++
+-++#include <stdio.h>
+-++#include <string.h>
+-++
+-++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-++
+-++#endif
+-+\ No newline at end of file
+-+
+-+commit f914d3afae4107c77728b3df4d39502c962ba74b
+-+Author: krpm <mungcalrina@gmail.com>
+-+Date:   Thu Aug 4 15:48:50 2022 -0400
+-+
+-+    Initial commit
+-+
+-+diff --git a/.gitattributes b/.gitattributes
+-+new file mode 100644
+-+index 0000000..dfe0770
+-+--- /dev/null
+-++++ b/.gitattributes
+-+@@ -0,0 +1,2 @@
+-++# Auto detect text files and perform LF normalization
+-++* text=auto
+-
+-commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+-Author: krpm <mungcalrina@gmail.com>
+-Date:   Mon Aug 8 13:43:58 2022 -0400
+-
+-    Update manipulating.c
+-
+-diff --git a/manipulating.c b/manipulating.c
+-index 953e516..9193243 100644
+---- a/manipulating.c
+-+++ b/manipulating.c
+-@@ -41,7 +41,7 @@ void manipulating(void) {
+- 	do {
+- 		printf("Type the 1st string to compare (q - to quit):\n");
+- 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+--		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+-+		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+- 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+- 			printf("Type the 2nd string to compare:\n");
+- 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+-
+-commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+-Author: kiararina <kiararina.pelenio@upou.edu.ph>
+-Date:   Mon Aug 8 09:38:48 2022 -0500
+-
+-    Version 2
+-    
+-    Added version 2 codes
+-
+-diff --git a/manipulating.c b/manipulating.c
+-index 9bde2d2..953e516 100644
+---- a/manipulating.c
+-+++ b/manipulating.c
+-@@ -1,5 +1,5 @@
+- /*
+--Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+-+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+- manipulating.c : Manipulating
+- Purpose: This program manipulates input strings
+- */
+-@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+- #include "manipulating.h" 
+- /* Contains function prototypes and library declarations */
+- 
+-+// V1
+- void manipulating(void) {
+- /* Purpose: This function concatenates 2 input strings */
+- 
+-@@ -19,16 +20,40 @@ void manipulating(void) {
+- 
+- 	do {
+- 		printf("Type the 1st string (q - to quit):\n");
+--		fgets(string1, BUFFER_SIZE, stdin);
+--		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+-+		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+-+		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+- 
+- 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+- 			printf("Type the 2nd string:\n");
+--			fgets(string2, BUFFER_SIZE, stdin);
+-+			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+- 			strcat(string1, string2);
+- 			printf("Concatenated string is \'%s\'\n", string1);
+- 		}
+- 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+- 
+- 	printf("*** End of Concatenating Strings Demo ***\n");
+-+
+-+//V2
+-+	printf("*** Start of Comparing Strings Demo ***\n");
+-+	char compare1[BUFFER_SIZE];
+-+	char compare2[BUFFER_SIZE];
+-+	int result;
+-+	do {
+-+		printf("Type the 1st string to compare (q - to quit):\n");
+-+		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-+		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+-+		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+-+			printf("Type the 2nd string to compare:\n");
+-+			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+-+			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+-+			result = strcmp(compare1, compare2);	// Compare the 2 strings
+-+			if (result < 0)
+-+				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+-+			else if (result == 0)
+-+				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+-+			else
+-+				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+-+		}
+-+	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+-+	printf("*** End of Comparing Strings Demo ***\n\n");
+- }
+-\ No newline at end of file
+-
+-commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+-Author: kiararina <kiararina.pelenio@upou.edu.ph>
+-Date:   Thu Aug 4 15:34:34 2022 -0500
+-
+-    Update manipulating.c
+-
+-diff --git a/manipulating.c b/manipulating.c
+-index 748c895..9bde2d2 100644
+---- a/manipulating.c
+-+++ b/manipulating.c
+-@@ -1,5 +1,5 @@
+- /*
+--Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+-+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+- manipulating.c : Manipulating
+- Purpose: This program manipulates input strings
+- */
+-
+-commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+-Author: krpm <mungcalrina@gmail.com>
+-Date:   Thu Aug 4 16:30:00 2022 -0400
+-
+-    Version 1
+-
+-diff --git a/manipulating.c b/manipulating.c
+-new file mode 100644
+-index 0000000..748c895
+---- /dev/null
+-+++ b/manipulating.c
+-@@ -0,0 +1,34 @@
+-+/*
+-+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+-+manipulating.c : Manipulating
+-+Purpose: This program manipulates input strings
+-+*/
+-+
+-+#define _CRT_SECURE_NO_WARNINGS
+-+#define BUFFER_SIZE 80
+-+
+-+#include "manipulating.h" 
+-+/* Contains function prototypes and library declarations */
+-+
+-+void manipulating(void) {
+-+/* Purpose: This function concatenates 2 input strings */
+-+
+-+	printf("*** Start of Concatenating Strings Demo ***\n");
+-+	char string1[BUFFER_SIZE];
+-+	char string2[BUFFER_SIZE];
+-+
+-+	do {
+-+		printf("Type the 1st string (q - to quit):\n");
+-+		fgets(string1, BUFFER_SIZE, stdin);
+-+		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+-+
+-+		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+-+			printf("Type the 2nd string:\n");
+-+			fgets(string2, BUFFER_SIZE, stdin);
+-+			strcat(string1, string2);
+-+			printf("Concatenated string is \'%s\'\n", string1);
+-+		}
+-+	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+-+
+-+	printf("*** End of Concatenating Strings Demo ***\n");
+-+}
+-\ No newline at end of file
+-diff --git a/manipulating.h b/manipulating.h
+-new file mode 100644
+-index 0000000..8a8f926
+---- /dev/null
+-+++ b/manipulating.h
+-@@ -0,0 +1,11 @@
+-+//MANIPULATING MODULE HEADER
+-+#ifndef _MANIPULATING_H_
+-+#define _MANIPULATING_H_
+-+
+-+#include <stdio.h>		// For input/output and printing
+-+#include <string.h>		// For string manipulation functions
+-+
+-+void manipulating(void);
+-+/* Purpose: This function concatenates 2 input strings */
+-+
+-+#endif
+
+commit e8242740404c7e5e308d7dabecc4d5c41b7e695b
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Fri Aug 12 14:14:56 2022 -0400
+
+    Updating converting.c to Version 3
+    
+    Version 3 adds functionality to convert a long numeric string to a long value.
+
+diff --git a/converting.c b/converting.c
+index df23173..acb6e07 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,15 +1,15 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 12/08/2022, CPR101, Final Project V3
+ converting.c : CONVERTING
+-Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++Purpose: This program converts numeric strings inputted by the user to an integer value, a double value, and a long value.
+ */
+ 
+ #define	_CRT_SECURE_NO_WARNINGS
+ #define BUFFER_SIZE 80
+ 
+ // Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+-// strings and convert a string to an integer value.
++// strings and convert a string to an integer, a double, and a long value.
+ #include "converting.h"
+ 
+ void converting(void) {
+@@ -22,10 +22,10 @@ void converting(void) {
+ 	int		intNumber;
+ 
+ 	do {
+-		// Prompt user for entry
++		// Prompt user for a integer numeric string
+ 		printf("Type an int numeric string (q - to quit):\n");
+ 		fgets(intString, BUFFER_SIZE, stdin);
+-		intString[strlen(intString) - 1] = '\0';
++		intString[strlen(intString) - 1] = '\0';	// Replace new line with null terminator
+ 
+ 		// Check user input, exit if 'q' was entered.
+ 		if (strcmp(intString, "q") != 0) {
+@@ -48,7 +48,7 @@ void converting(void) {
+ 	double	doubleNumber;
+ 
+ 	do {
+-		// Prompt user for entry, replacing the new line read by 
++		// Prompt user for a double numeric string, replacing the new line read by 
+ 		// fgets with a null terminator
+ 		printf("Type an double numeric string (q - to quit):\n");
+ 		fgets(doubleString, BUFFER_SIZE, stdin);
+@@ -63,5 +63,31 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(doubleString, "q") != 0);
+ 
++	// Display ending message for double demo
+ 	printf("*** End of Converting Strings to double Demo ***\n\n");
++
++	// V3
++	printf("*** Start of Converting Strings to long Demo ***\n");
++	
++	char	longString[BUFFER_SIZE];
++	long	longNumber;
++
++	do {
++		// Prompt user for a long numeric string, replacing the new line read by
++		// fgets with a null terminator.
++		printf("Type a long numeric string (q - to quit):\n");
++		fgets(longString, BUFFER_SIZE, stdin);
++		longString[strlen(longString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.
++		if ((strcmp(longString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a long, then display it
++			longNumber = atol(longString);
++			printf("Converted number is %ld\n", longNumber);
++		}
++	} while (strcmp(longString, "q") != 0);
++
++	// Display ending message for long demo
++	printf("*** End of Converting Strings to long Demo ***\n\n");
+ }
+
+commit ade615136b67a44a1c986034b1ce8c45b1f10a01
+Merge: faa99c8 443688d
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Fri Aug 12 12:04:26 2022 -0400
+
+    Merge pull request #2 from kiararina/manipulating
+    
+    Update manipulating.c for version 3.
+
+commit 443688d725f580de26b30951bc73c5f4420cbd78
+Author: krpm <25734153+kiararina@users.noreply.github.com>
+Date:   Fri Aug 12 10:23:30 2022 -0400
+
+    Update to version 3
+
+diff --git a/manipulating_git_log.txt b/manipulating_git_log.txt
+new file mode 100644
+index 0000000..05aa537
+--- /dev/null
++++ b/manipulating_git_log.txt
+@@ -0,0 +1,1587 @@
++commit e14f5c429efccb7dc63749da2a425659ad905631
++Author: krpm <25734153+kiararina@users.noreply.github.com>
++Date:   Fri Aug 12 08:37:11 2022 -0400
++
++    Update manipulating.c for version 3.
++    
++    Added a section for checking the occurrence of 2nd string in 1st string.
++
++diff --git a/manipulating.c b/manipulating.c
++index 9193243..925e182 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
++ 
++ // V1
++ void manipulating(void) {
++-/* Purpose: This function concatenates 2 input strings */
+++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
++ 
++ 	printf("*** Start of Concatenating Strings Demo ***\n");
++ 	char string1[BUFFER_SIZE];
++@@ -56,4 +56,27 @@ void manipulating(void) {
++ 		}
++ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++ 	printf("*** End of Comparing Strings Demo ***\n\n");
+++
+++
+++//V3
+++	printf("*** Start of Searching Strings Demo ***\n");
+++	char haystack[BUFFER_SIZE];
+++	char needle[BUFFER_SIZE];
+++	char* occurence = NULL;
+++	do {
+++		printf("Type the string (q - to quit):\n");
+++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
+++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
+++			printf("Type the substring:\n");
+++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
+++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
+++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
+++			if (occurence)							// If found, return the position where 2nd string occurs
+++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
+++			else						
+++				printf("Not found\n");				
+++		}
+++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Searching Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 23:04:40 2022 -0400
++
++    Adding git logs
++    
++    Version 2 Git Logs
++    $ git --no-pager log -p > "module-git-log.txt"
++
++diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
++new file mode 100644
++index 0000000..7bb5209
++--- /dev/null
+++++ b/manipulating-git-log.txt
++@@ -0,0 +1,1345 @@
+++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+++Merge: 6361388 c3a8316
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Tue Aug 9 22:49:17 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit 63613886b8f1ecccb62538d6d4b7905425a16358
+++Merge: 0626d2e c0f7dc8
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Tue Aug 9 22:47:37 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+++Merge: 9d98950 c0f7dc8
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 22:46:28 2022 -0400
+++
+++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+++
+++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+++Merge: fd97b97 a2a1bf4
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Tue Aug 9 22:44:47 2022 -0400
+++
+++    Merge pull request #1 from kiararina/converting
+++    
+++    Recovering lost commits up to converting.c
+++
+++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+++Merge: cee497d fd97b97
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Tue Aug 9 22:44:00 2022 -0400
+++
+++    Merge branch 'main' into converting
+++
+++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:23:44 2022 -0400
+++
+++    tokenizing.c v2 corrected
+++    
+++    Corrected a previous error, now both v1 and v2 are within the same function name
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 6332b6d..ae26066 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ 
+++ 
+++ 
++++void tokenizing(void) {
+++ 
+++-/*
+++-// V1
+++-//void tokenizing(void) {
+++-
++++    // V1
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char words[BUFFER_SIZE];
+++     char* nextWord = NULL;
+++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++     do {
+++         printf("Type a few words seperated by space (q - to quit):\n");
+++ 
+++-        fgets(words, BUFFER_SIZE, stdin); 
++++        fgets(words, BUFFER_SIZE, stdin);
+++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++ 
+++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ 
+++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++             while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++             }
+++-       }
++++        }
+++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++ 
+++     printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-*/
+++ 
+++ 
+++-// V2
+++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++-void tokenizing(void) {
+++-
++++    // V2
++++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char phrases[BUFFER_SIZE];
+++     char* nextPhrase = NULL;
+++
+++commit 23f162166b815502c16ac1456d8f9be87b799f26
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:09:02 2022 -0400
+++
+++    Update tokenizing.c to V2
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index edc3184..6332b6d 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++ [tokenizing.c] : [tokenizing]
+++ Purpose: [This function takes a user inputted string and tokenizes it]
+++ */
+++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+++ #include "tokenizing.h"
+++ 
+++ 
+++-int main(void) {
+++-    tokenizing();
+++-    return 0;
+++-}
+++ 
+++ 
++++/*
+++ // V1
+++-void tokenizing(void) {
++++//void tokenizing(void) {
+++ 
+++     printf("*** Start of Tokenizing Words Demo ***\n");
+++     char words[BUFFER_SIZE];
+++@@ -34,16 +31,46 @@ void tokenizing(void) {
+++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++ 
+++-        
+++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++             while (nextWord) {
+++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++             }
+++-        }
++++       }
+++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++ 
+++     printf("*** End of Tokenizing Words Demo ***\n\n");
+++ }
++++*/
++++
++++
++++// V2
++++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char phrases[BUFFER_SIZE];
++++    char* nextPhrase = NULL;
++++    int phrasesCounter;
++++    do {
++++        printf("Type a few words seperated by comma (q - to quit):\n");
++++
++++        fgets(phrases, BUFFER_SIZE, stdin); 
++++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++++            while (nextPhrase) {
++++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++++            }
++++        }
++++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
+++ 
+++ 
+++
+++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 19:06:55 2022 -0400
+++
+++    V1
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 417d34a..edc3184 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,80 +1,49 @@
+++-/*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++-[tokenizing.c] : [tokenizing]
+++-Purpose: [This function takes a user inputted string and tokenizes it]
+++-*/
+++-
+++-
+++-// TOKENIZING MODULE SOURCE
+++-#define _CRT_SECURE_NO_WARNINGS
+++-#define BUFFER_SIZE 300
+++-#include "tokenizing.h"
+++-
+++-
+++-int main(void) {
+++-    tokenizing();
+++-    return 0;
+++-}
+++-
+++-
+++-/*
+++-// V1
+++-//void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char words[BUFFER_SIZE];
+++-    char* nextWord = NULL;
+++-    int wordsCounter;
+++-    do {
+++-        printf("Type a few words seperated by space (q - to quit):\n");
+++-
+++-        fgets(words, BUFFER_SIZE, stdin); 
+++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++-            while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++-            }
+++-       }
+++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-*/
+++-
+++-
+++-// V2
+++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++-void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char phrases[BUFFER_SIZE];
+++-    char* nextPhrase = NULL;
+++-    int phrasesCounter;
+++-    do {
+++-        printf("Type a few words seperated by comma (q - to quit):\n");
+++-
+++-        fgets(phrases, BUFFER_SIZE, stdin); 
+++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++-            while (nextPhrase) {
+++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++-            }
+++-        }
+++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-
+++-
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++
++++int main(void) {
++++    tokenizing();
++++    return 0;
++++}
++++
++++
++++// V1
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++        
++++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++        }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++
+++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+++Author: CRYPTO43 <singharshjot07@gmail.com>
+++Date:   Tue Aug 9 17:12:27 2022 -0400
+++
+++    first commit
+++
+++diff --git a/fundamentals.c b/fundamentals.c
+++new file mode 100644
+++index 0000000..cd7cd9f
+++--- /dev/null
++++++ b/fundamentals.c
+++@@ -0,0 +1,63 @@
++++/*
++++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++++fundamentals.c : indexing
++++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++++*/
++++
++++
++++// FUNDAMENTALS MODULE SOURCE 
++++#define _CRT_SECURE_NO_WARNINGS 
++++#define BUFFER_SIZE 80
++++#define NUM_INPUT_SIZE 10 
++++#include "fundamentals.h"
++++
++++
++++void main(void) {
++++
++++// V1
++++    printf("*** start of Indexing Strings Demo ***\n"); 
++++    char buffer1[BUFFER_SIZE]; 
++++    char numInput[NUM_INPUT_SIZE]; 
++++    size_t position; 
++++    do {
++++        printf("Type not empty string (q - to quit): \n"); 
++++        fgets (buffer1, BUFFER_SIZE, stdin); 
++++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp (buffer1, "q") != 0) { 
++++            printf("Type the character position within the string: \n"); 
++++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++++            position = atoi (numInput); // Converts entered string to integer.
++++
++++            // Checks if converted integer is larger then string length and assigns max position if true.
++++            if (position >= strlen (buffer1)) { 
++++                position = strlen (buffer1) - 1; 
++++                printf("Too big... Position reduced to max. availbale\n");
++++            }
++++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++++        }
++++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++++    printf("*** End of Indexing Strings Demo ***\n\n");
++++
++++
++++
++++    // V2 
++++    printf("*** Start of Measuring Strings Demo ***\n"); 
++++    char buffer2[BUFFER_SIZE]; 
++++    do { 
++++        printf("Type a string (q - to quit):\n"); 
++++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp(buffer2, "q") != 0) 
++++            printf("The length of \'%s\' is %d characters\n", 
++++            buffer2, (int)strlen(buffer2)); 
++++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++++        
++++        printf("*** End of Measuring Strings Demo ***\n\n");
++++}
++++
++++ 
+++\ No newline at end of file
+++diff --git a/fundamentals.h b/fundamentals.h
+++new file mode 100644
+++index 0000000..383cccc
+++--- /dev/null
++++++ b/fundamentals.h
+++@@ -0,0 +1,12 @@
++++// FUNDAMENTALS MODULE HEADER 
++++#ifndef _FUNDAMENTALS_H_
++++#define _FUNDAMENTALS_H_
++++
++++#include <stdio.h> 
++++#include <stdlib.h> 
++++#include <string.h>
++++
++++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++++void main(void);
++++
++++#endif
+++\ No newline at end of file
+++
+++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+++Date:   Tue Aug 9 16:17:34 2022 -0400
+++
+++    Add files via upload
+++    
+++    Version 2
+++
+++diff --git a/tokenizing.c b/tokenizing.c
+++index 65d1c20..417d34a 100644
+++--- a/tokenizing.c
++++++ b/tokenizing.c
+++@@ -1,42 +1,80 @@
+++-/*
+++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++-[tokenizing.c] : [tokenizing]
+++-Purpose: [This function takes a user inputted string and tokenizes it]
+++-*/
+++-
+++-
+++-// TOKENIZING MODULE SOURCE
+++-#define _CRT_SECURE_NO_WARNINGS
+++-#define BUFFER_SIZE 300
+++-#include "tokenizing.h"
+++-
+++-// V1
+++-void tokenizing(void) {
+++-
+++-    printf("*** Start of Tokenizing Words Demo ***\n");
+++-    char words[BUFFER_SIZE];
+++-    char* nextWord = NULL;
+++-    int wordsCounter;
+++-    do {
+++-        printf("Type a few words seperated by space (q - to quit):\n");
+++-
+++-        fgets(words, BUFFER_SIZE, stdin); 
+++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++-
+++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++-
+++-        
+++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++-            while (nextWord) {
+++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++-            }
+++-        }
+++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++-
+++-    printf("*** End of Tokenizing Words Demo ***\n\n");
+++-}
+++-
+++-
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++
++++int main(void) {
++++    tokenizing();
++++    return 0;
++++}
++++
++++
++++/*
++++// V1
++++//void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++       }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++*/
++++
++++
++++// V2
++++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char phrases[BUFFER_SIZE];
++++    char* nextPhrase = NULL;
++++    int phrasesCounter;
++++    do {
++++        printf("Type a few words seperated by comma (q - to quit):\n");
++++
++++        fgets(phrases, BUFFER_SIZE, stdin); 
++++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++++            while (nextPhrase) {
++++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++++            }
++++        }
++++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++diff --git a/tokenizing.h b/tokenizing.h
+++index c00f3cb..7899cc2 100644
+++--- a/tokenizing.h
++++++ b/tokenizing.h
+++@@ -1,10 +1,10 @@
+++-// Tokenization header file
+++-#ifndef _TOKENIZING_H_
+++-#define _TOKENIZING_H_
+++-
+++-#include <stdio.h>
+++-#include <string.h>
+++-
+++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++-
++++// Tokenization header file
++++#ifndef _TOKENIZING_H_
++++#define _TOKENIZING_H_
++++
++++#include <stdio.h>
++++#include <string.h>
++++
++++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++++
+++ #endif
+++\ No newline at end of file
+++
+++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Mon Aug 8 15:47:34 2022 -0400
+++
+++    Version 2
+++    
+++    Version 2
+++
+++diff --git a/converting.c b/converting.c
+++index c5a0775..df23173 100644
+++--- a/converting.c
++++++ b/converting.c
+++@@ -1,6 +1,6 @@
+++ // CONVERTING MODULE SOURCE
+++ /*
+++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+++ converting.c : CONVERTING
+++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++ */
+++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+++ // strings and convert a string to an integer value.
+++ #include "converting.h"
+++ 
+++-// V1
+++ void converting(void) {
++++	// V1
+++ 	// Display beginning message
+++ 	printf("*** Start of Converting Strings to int Demo ***\n");
+++ 
+++@@ -38,6 +38,30 @@ void converting(void) {
+++ 		}
+++ 	} while (strcmp(intString, "q") != 0);
+++ 
+++-	// Display ending message and exit module.
++++	// Display ending message for int demo
+++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++++
++++	// V2
++++	printf("*** Start of Converting Strings to double Demo ***\n");
++++
++++	char	doubleString[BUFFER_SIZE];
++++	double	doubleNumber;
++++
++++	do {
++++		// Prompt user for entry, replacing the new line read by 
++++		// fgets with a null terminator
++++		printf("Type an double numeric string (q - to quit):\n");
++++		fgets(doubleString, BUFFER_SIZE, stdin);
++++		doubleString[strlen(doubleString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.  
++++		if ((strcmp(doubleString, "q") != 0)) {
++++
++++			// Convert user entry from numeric string to a double, then display it
++++			doubleNumber = atof(doubleString);
++++			printf("Converted number is %f\n", doubleNumber);
++++		}
++++	} while (strcmp(doubleString, "q") != 0);
++++
++++	printf("*** End of Converting Strings to double Demo ***\n\n");
+++ }
+++
+++commit e25ade313038da86c407f85f5c00586ba6b37a1b
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Mon Aug 8 15:05:20 2022 -0400
+++
+++    Update README.md
+++
+++diff --git a/README.md b/README.md
+++index 28e7c31..f1ff45d 100644
+++--- a/README.md
++++++ b/README.md
+++@@ -1,5 +1,8 @@
+++ # CPR101_Project
+++ CPR101 Final Project
++++
+++ Section: NAA
++++
+++ Group 1
++++
+++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+++
+++commit a3e1e5ae394af27b186e61562b7167819c90ea13
+++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+++Date:   Mon Aug 8 15:01:47 2022 -0400
+++
+++    Create README.md
+++
+++diff --git a/README.md b/README.md
+++new file mode 100644
+++index 0000000..28e7c31
+++--- /dev/null
++++++ b/README.md
+++@@ -0,0 +1,5 @@
++++# CPR101_Project
++++CPR101 Final Project
++++Section: NAA
++++Group 1
++++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+++
+++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+++Author: rsaguros <rsaguros1@myseneca.ca>
+++Date:   Mon Aug 8 13:58:05 2022 -0400
+++
+++    Update converting.c
+++    
+++    Version 2
+++
+++diff --git a/converting.c b/converting.c
+++index c5a0775..df23173 100644
+++--- a/converting.c
++++++ b/converting.c
+++@@ -1,6 +1,6 @@
+++ // CONVERTING MODULE SOURCE
+++ /*
+++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+++ converting.c : CONVERTING
+++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++ */
+++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+++ // strings and convert a string to an integer value.
+++ #include "converting.h"
+++ 
+++-// V1
+++ void converting(void) {
++++	// V1
+++ 	// Display beginning message
+++ 	printf("*** Start of Converting Strings to int Demo ***\n");
+++ 
+++@@ -38,6 +38,30 @@ void converting(void) {
+++ 		}
+++ 	} while (strcmp(intString, "q") != 0);
+++ 
+++-	// Display ending message and exit module.
++++	// Display ending message for int demo
+++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++++
++++	// V2
++++	printf("*** Start of Converting Strings to double Demo ***\n");
++++
++++	char	doubleString[BUFFER_SIZE];
++++	double	doubleNumber;
++++
++++	do {
++++		// Prompt user for entry, replacing the new line read by 
++++		// fgets with a null terminator
++++		printf("Type an double numeric string (q - to quit):\n");
++++		fgets(doubleString, BUFFER_SIZE, stdin);
++++		doubleString[strlen(doubleString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.  
++++		if ((strcmp(doubleString, "q") != 0)) {
++++
++++			// Convert user entry from numeric string to a double, then display it
++++			doubleNumber = atof(doubleString);
++++			printf("Converted number is %f\n", doubleNumber);
++++		}
++++	} while (strcmp(doubleString, "q") != 0);
++++
++++	printf("*** End of Converting Strings to double Demo ***\n\n");
+++ }
+++
+++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Mon Aug 8 13:43:58 2022 -0400
+++
+++    Update manipulating.c
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 953e516..9193243 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -41,7 +41,7 @@ void manipulating(void) {
+++ 	do {
+++ 		printf("Type the 1st string to compare (q - to quit):\n");
+++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++ 			printf("Type the 2nd string to compare:\n");
+++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++
+++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Mon Aug 8 12:51:35 2022 -0400
+++
+++    Version 2
+++    
+++    Updated main for version 2
+++
+++diff --git a/main.c b/main.c
+++index 755b397..70aeeb7 100644
+++--- a/main.c
++++++ b/main.c
+++@@ -1,6 +1,6 @@
+++ // MAIN 
+++ /*
+++-Author: BB01, 03/08/2022, CPR101, Final Project V1
++++Author: BB01, 03/08/2022, CPR101, Final Project
+++ main.c : MAIN
+++ Purpose: Main Function used to prompt user for which various options.
+++ */
+++
+++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+++Author: kiararina <kiararina.pelenio@upou.edu.ph>
+++Date:   Mon Aug 8 09:38:48 2022 -0500
+++
+++    Version 2
+++    
+++    Added version 2 codes
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 9bde2d2..953e516 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+++ manipulating.c : Manipulating
+++ Purpose: This program manipulates input strings
+++ */
+++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+++ #include "manipulating.h" 
+++ /* Contains function prototypes and library declarations */
+++ 
++++// V1
+++ void manipulating(void) {
+++ /* Purpose: This function concatenates 2 input strings */
+++ 
+++@@ -19,16 +20,40 @@ void manipulating(void) {
+++ 
+++ 	do {
+++ 		printf("Type the 1st string (q - to quit):\n");
+++-		fgets(string1, BUFFER_SIZE, stdin);
+++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+++ 
+++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++ 			printf("Type the 2nd string:\n");
+++-			fgets(string2, BUFFER_SIZE, stdin);
++++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++ 			strcat(string1, string2);
+++ 			printf("Concatenated string is \'%s\'\n", string1);
+++ 		}
+++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++ 
+++ 	printf("*** End of Concatenating Strings Demo ***\n");
++++
++++//V2
++++	printf("*** Start of Comparing Strings Demo ***\n");
++++	char compare1[BUFFER_SIZE];
++++	char compare2[BUFFER_SIZE];
++++	int result;
++++	do {
++++		printf("Type the 1st string to compare (q - to quit):\n");
++++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++++			printf("Type the 2nd string to compare:\n");
++++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++++			if (result < 0)
++++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++++			else if (result == 0)
++++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++++			else
++++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++++		}
++++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++++	printf("*** End of Comparing Strings Demo ***\n\n");
+++ }
+++\ No newline at end of file
+++
+++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+++Author: kiararina <kiararina.pelenio@upou.edu.ph>
+++Date:   Thu Aug 4 15:34:34 2022 -0500
+++
+++    Update manipulating.c
+++
+++diff --git a/manipulating.c b/manipulating.c
+++index 748c895..9bde2d2 100644
+++--- a/manipulating.c
++++++ b/manipulating.c
+++@@ -1,5 +1,5 @@
+++ /*
+++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++ manipulating.c : Manipulating
+++ Purpose: This program manipulates input strings
+++ */
+++
+++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Thu Aug 4 16:30:00 2022 -0400
+++
+++    Version 1
+++
+++diff --git a/Programming Comments.docx b/Programming Comments.docx
+++new file mode 100644
+++index 0000000..07d1cd7
+++--- /dev/null
++++++ b/Programming Comments.docx	
+++@@ -0,0 +1,110 @@
++++                        Commenting Program Source Code
++++--------------------------------------------------------------------------------
++++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++++--------------------------------------------------------------------------------
++++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++++Comments are for programmers who will maintain the code in the future. 
++++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++++--------------------------------------------------------------------------------
++++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++++--------------------------------------------------------------------------------
++++
++++Organisation of Comments
++++Program comments 
++++ -  appear at the beginning of a source file.
++++/* 
++++Author: Name, email, ID, Date written, Course, Project
++++[executable filename] : [title of program]
++++Purpose: [what this program does, what problem does it solve?]
++++*/
++++
++++Function comments
++++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++++/*
++++Purpose: [what this function does, what problem does it solve?]
++++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++++*/
++++
++++Inline code comments
++++Your comment must say something different than explaining the code itself. 
++++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++++c = a + b;  // c stores total of assignment and test marks respectively.
++++
++++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++++cryptic = C + code; 		// explain this line's purpose in the program
++++crypticly = C + moreCode;	// explain this line's purpose in the program
++++
++++Longer code comments
++++Sometimes comments need more space than would fit inline. 
++++cryptic = C + code;
++++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++++moreCrypticly = C + moreCode;	
++++
++++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++++// this comment explains the purpose of the next line of code  
++++cryptic = C + code;
++++ 		
++++// this comment explains the purpose of the next line of code  
++++moreCrypticly = C + moreCode;	
++++		
++++
++++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++++
++++Structures
++++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++++// [what the structure accomplishes]
++++e.g. 
++++// compute factorial	
++++// prompt user until value within range 1  -  100 is input
++++Code Samples
++++printf("Type a few words separated by space(q - to quit):\n");
++++gets(words);
++++while (strcmp(words, "q") != 0) 
++++{
++++    word = strtok(words, " ");
++++    w_counter = 1;
++++    while (word) 
++++    {
++++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++++        word = strtok(NULL, " ");
++++    }
++++    printf("Type a few words separated by space(q - to quit):\n");
++++    gets(words);
++++}
++++
++++ the first while continues until the 'words' variable is equal to "q". What is it for?
++++ there is another while {structure} ... what does it do?
++++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++++ // keep looping until pointer is NULL
++++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++++ This technique is even more important at the end of a series nested structures, e.g.
++++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++++
++++
++++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++++
++++while (TRUE) // a comment explains why there is no exit condition here
++++{
++++ 	. . .
++++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++++. . .
++++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++++   // --------- *****      make it visually obvious that this is an exit from the structure
++++. . .
++++}
+++diff --git a/converting.c b/converting.c
+++new file mode 100644
+++index 0000000..c5a0775
+++--- /dev/null
++++++ b/converting.c
+++@@ -0,0 +1,43 @@
++++// CONVERTING MODULE SOURCE
++++/*
++++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++++converting.c : CONVERTING
++++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++++*/
++++
++++#define	_CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 80
++++
++++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++++// strings and convert a string to an integer value.
++++#include "converting.h"
++++
++++// V1
++++void converting(void) {
++++	// Display beginning message
++++	printf("*** Start of Converting Strings to int Demo ***\n");
++++
++++	// Declare variables
++++	char	intString[BUFFER_SIZE];
++++	int		intNumber;
++++
++++	do {
++++		// Prompt user for entry
++++		printf("Type an int numeric string (q - to quit):\n");
++++		fgets(intString, BUFFER_SIZE, stdin);
++++		intString[strlen(intString) - 1] = '\0';
++++
++++		// Check user input, exit if 'q' was entered.
++++		if (strcmp(intString, "q") != 0) {
++++
++++			// Convert user entry from string to integer value.
++++			intNumber = atoi(intString);
++++
++++			// Display converted number.
++++			printf("Converted number is %d\n", intNumber);
++++		}
++++	} while (strcmp(intString, "q") != 0);
++++
++++	// Display ending message and exit module.
++++	printf("*** End of Converting Strings to int Demo ***\n\n");
++++}
+++diff --git a/converting.h b/converting.h
+++new file mode 100644
+++index 0000000..03c62a3
+++--- /dev/null
++++++ b/converting.h
+++@@ -0,0 +1,18 @@
++++// CONVERTING MODULE HEADER
++++#ifndef _CONVERTING_H_
++++#define _CONVERTING_H_
++++
++++// Libraries
++++#include <stdio.h>
++++#include <string.h>
++++#include <stdlib.h>
++++
++++
++++/////////////////////////
++++// Prototype  Function //
++++/////////////////////////
++++
++++// Function used to apply conversions
++++void converting(void);
++++
++++#endif
+++diff --git a/fundamentals.c b/fundamentals.c
+++new file mode 100644
+++index 0000000..95c9f23
+++--- /dev/null
++++++ b/fundamentals.c
+++@@ -0,0 +1,43 @@
++++/*
++++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++++fundamentals.c : indexing
++++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++++*/
++++
++++
++++// FUNDAMENTALS MODULE SOURCE 
++++#define _CRT_SECURE_NO_WARNINGS 
++++#define BUFFER_SIZE 80
++++#define NUM_INPUT_SIZE 10 
++++#include "fundamentals.h"
++++
++++
++++void fundamentals(void) {
++++
++++// V1
++++    printf("*** start of Indexing Strings Demo ***\n"); 
++++    char buffer1[BUFFER_SIZE]; 
++++    char numInput[NUM_INPUT_SIZE]; 
++++    size_t position; 
++++    do {
++++        printf("Type not empty string (q - to quit): \n"); 
++++        fgets (buffer1, BUFFER_SIZE, stdin); 
++++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++++
++++        // checks if entered string is not equals to 'q'.
++++        if (strcmp (buffer1, "q") != 0) { 
++++            printf("Type the character position within the string: \n"); 
++++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++++            position = atoi (numInput); // Converts entered string to integer.
++++
++++            // Checks if converted integer is larger then string length and assigns max position if true.
++++            if (position >= strlen (buffer1)) { 
++++                position = strlen (buffer1) - 1; 
++++                printf("Too big... Position reduced to max. availbale\n");
++++            }
++++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++++        }
++++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++++    printf("*** End of Indexing Strings Demo ***\n\n");
++++}
+++\ No newline at end of file
+++diff --git a/fundamentals.h b/fundamentals.h
+++new file mode 100644
+++index 0000000..0433660
+++--- /dev/null
++++++ b/fundamentals.h
+++@@ -0,0 +1,12 @@
++++// FUNDAMENTALS MODULE HEADER 
++++#ifndef _FUNDAMENTALS_H_
++++#define _FUNDAMENTALS_H_
++++
++++#include <stdio.h> 
++++#include <stdlib.h> 
++++#include <string.h>
++++
++++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++++void fundamentals(void);
++++
++++#endif
+++\ No newline at end of file
+++diff --git a/main.c b/main.c
+++new file mode 100644
+++index 0000000..755b397
+++--- /dev/null
++++++ b/main.c
+++@@ -0,0 +1,58 @@
++++// MAIN 
++++/*
++++Author: BB01, 03/08/2022, CPR101, Final Project V1
++++main.c : MAIN
++++Purpose: Main Function used to prompt user for which various options.
++++*/
++++
++++// Include all necessary modules
++++#define _CRT_SECURE_NO_WARNINGS
++++#include "fundamentals.h"
++++#include "manipulating.h"
++++#include "converting.h"
++++#include "tokenizing.h"
++++
++++int main(void) {
++++	// Declare variables
++++	char buff[10];
++++
++++	// Open menu for user
++++	do {
++++		// Display menu options
++++		printf("1 - Fundamentals\n");
++++		printf("2 - Manipulation\n");
++++		printf("3 - Converting\n");
++++		printf("4 - Tokenizing\n");
++++		printf("0 - Exit\n");
++++		
++++		// Prompt user for input
++++		printf("Which module to run? \n");
++++		fgets(buff, 10, stdin);
++++
++++		// Analyze user entry and match selection
++++		switch (buff[0])
++++		{
++++		case '1': 
++++			// Call for fundamentals module
++++			fundamentals();
++++			break;
++++
++++		case '2': 
++++			// Call for manipulating module
++++			manipulating();
++++			break;
++++
++++		case '3': 
++++			// Call for converting module
++++			converting();
++++			break;
++++
++++		case '4': 
++++			// Call for tokenizing module
++++			tokenizing();
++++			break;
++++		}
++++	} while (buff[0] != '0');
++++	
++++	return 0;
++++}
+++\ No newline at end of file
+++diff --git a/manipulating.c b/manipulating.c
+++new file mode 100644
+++index 0000000..748c895
+++--- /dev/null
++++++ b/manipulating.c
+++@@ -0,0 +1,34 @@
++++/*
++++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++++manipulating.c : Manipulating
++++Purpose: This program manipulates input strings
++++*/
++++
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 80
++++
++++#include "manipulating.h" 
++++/* Contains function prototypes and library declarations */
++++
++++void manipulating(void) {
++++/* Purpose: This function concatenates 2 input strings */
++++
++++	printf("*** Start of Concatenating Strings Demo ***\n");
++++	char string1[BUFFER_SIZE];
++++	char string2[BUFFER_SIZE];
++++
++++	do {
++++		printf("Type the 1st string (q - to quit):\n");
++++		fgets(string1, BUFFER_SIZE, stdin);
++++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++++
++++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++++			printf("Type the 2nd string:\n");
++++			fgets(string2, BUFFER_SIZE, stdin);
++++			strcat(string1, string2);
++++			printf("Concatenated string is \'%s\'\n", string1);
++++		}
++++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++++
++++	printf("*** End of Concatenating Strings Demo ***\n");
++++}
+++\ No newline at end of file
+++diff --git a/manipulating.h b/manipulating.h
+++new file mode 100644
+++index 0000000..8a8f926
+++--- /dev/null
++++++ b/manipulating.h
+++@@ -0,0 +1,11 @@
++++//MANIPULATING MODULE HEADER
++++#ifndef _MANIPULATING_H_
++++#define _MANIPULATING_H_
++++
++++#include <stdio.h>		// For input/output and printing
++++#include <string.h>		// For string manipulation functions
++++
++++void manipulating(void);
++++/* Purpose: This function concatenates 2 input strings */
++++
++++#endif
+++diff --git a/tokenizing.c b/tokenizing.c
+++new file mode 100644
+++index 0000000..65d1c20
+++--- /dev/null
++++++ b/tokenizing.c
+++@@ -0,0 +1,42 @@
++++/*
++++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++++[tokenizing.c] : [tokenizing]
++++Purpose: [This function takes a user inputted string and tokenizes it]
++++*/
++++
++++
++++// TOKENIZING MODULE SOURCE
++++#define _CRT_SECURE_NO_WARNINGS
++++#define BUFFER_SIZE 300
++++#include "tokenizing.h"
++++
++++// V1
++++void tokenizing(void) {
++++
++++    printf("*** Start of Tokenizing Words Demo ***\n");
++++    char words[BUFFER_SIZE];
++++    char* nextWord = NULL;
++++    int wordsCounter;
++++    do {
++++        printf("Type a few words seperated by space (q - to quit):\n");
++++
++++        fgets(words, BUFFER_SIZE, stdin); 
++++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++++
++++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++++
++++        
++++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++++            while (nextWord) {
++++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++++            }
++++        }
++++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++++
++++    printf("*** End of Tokenizing Words Demo ***\n\n");
++++}
++++
++++
+++diff --git a/tokenizing.h b/tokenizing.h
+++new file mode 100644
+++index 0000000..c00f3cb
+++--- /dev/null
++++++ b/tokenizing.h
+++@@ -0,0 +1,10 @@
++++// Tokenization header file
++++#ifndef _TOKENIZING_H_
++++#define _TOKENIZING_H_
++++
++++#include <stdio.h>
++++#include <string.h>
++++
++++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++++
++++#endif
+++\ No newline at end of file
+++
+++commit f914d3afae4107c77728b3df4d39502c962ba74b
+++Author: krpm <mungcalrina@gmail.com>
+++Date:   Thu Aug 4 15:48:50 2022 -0400
+++
+++    Initial commit
+++
+++diff --git a/.gitattributes b/.gitattributes
+++new file mode 100644
+++index 0000000..dfe0770
+++--- /dev/null
++++++ b/.gitattributes
+++@@ -0,0 +1,2 @@
++++# Auto detect text files and perform LF normalization
++++* text=auto
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
+
+commit e14f5c429efccb7dc63749da2a425659ad905631
+Author: krpm <25734153+kiararina@users.noreply.github.com>
+Date:   Fri Aug 12 08:37:11 2022 -0400
+
+    Update manipulating.c for version 3.
+    
+    Added a section for checking the occurrence of 2nd string in 1st string.
+
+diff --git a/manipulating.c b/manipulating.c
+index 9193243..925e182 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
+ 
+ // V1
+ void manipulating(void) {
+-/* Purpose: This function concatenates 2 input strings */
++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
+ 
+ 	printf("*** Start of Concatenating Strings Demo ***\n");
+ 	char string1[BUFFER_SIZE];
+@@ -56,4 +56,27 @@ void manipulating(void) {
+ 		}
+ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+ 	printf("*** End of Comparing Strings Demo ***\n\n");
++
++
++//V3
++	printf("*** Start of Searching Strings Demo ***\n");
++	char haystack[BUFFER_SIZE];
++	char needle[BUFFER_SIZE];
++	char* occurence = NULL;
++	do {
++		printf("Type the string (q - to quit):\n");
++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
++			printf("Type the substring:\n");
++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
++			if (occurence)							// If found, return the position where 2nd string occurs
++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
++			else						
++				printf("Not found\n");				
++		}
++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Searching Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 23:04:40 2022 -0400
+
+    Adding git logs
+    
+    Version 2 Git Logs
+    $ git --no-pager log -p > "module-git-log.txt"
+
+diff --git a/converting-git-log.txt b/converting-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/converting-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/fundamentals-git-log.txt b/fundamentals-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/fundamentals-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/main-git-log.txt b/main-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/main-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/manipulating-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+diff --git a/tokenizing-git-log.txt b/tokenizing-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/tokenizing-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+
 commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
 Merge: 6361388 c3a8316
 Author: rsaguros <rsaguros1@myseneca.ca>

commit 285c5525d1092e24bd2bd8735f5ff1b8012d6be9
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Fri Aug 12 14:15:57 2022 -0400

    Renaming to keep consistent with other files.
    
    Changed _ to - to be consistent with the other git logs.  Replaced old one with new.

diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
index 7bb5209..05aa537 100644
--- a/manipulating-git-log.txt
+++ b/manipulating-git-log.txt
@@ -1,748 +1,1414 @@
-commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
-Merge: 6361388 c3a8316
-Author: rsaguros <rsaguros1@myseneca.ca>
-Date:   Tue Aug 9 22:49:17 2022 -0400
-
-    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
-
-commit 63613886b8f1ecccb62538d6d4b7905425a16358
-Merge: 0626d2e c0f7dc8
-Author: rsaguros <rsaguros1@myseneca.ca>
-Date:   Tue Aug 9 22:47:37 2022 -0400
-
-    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+commit e14f5c429efccb7dc63749da2a425659ad905631
+Author: krpm <25734153+kiararina@users.noreply.github.com>
+Date:   Fri Aug 12 08:37:11 2022 -0400
 
-commit c3a831696d320ac9100ed65017dacd96abb6c7c0
-Merge: 9d98950 c0f7dc8
-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-Date:   Tue Aug 9 22:46:28 2022 -0400
-
-    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
-
-commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
-Merge: fd97b97 a2a1bf4
-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-Date:   Tue Aug 9 22:44:47 2022 -0400
-
-    Merge pull request #1 from kiararina/converting
+    Update manipulating.c for version 3.
     
-    Recovering lost commits up to converting.c
-
-commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
-Merge: cee497d fd97b97
-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-Date:   Tue Aug 9 22:44:00 2022 -0400
-
-    Merge branch 'main' into converting
+    Added a section for checking the occurrence of 2nd string in 1st string.
 
-commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-Date:   Tue Aug 9 19:23:44 2022 -0400
-
-    tokenizing.c v2 corrected
-    
-    Corrected a previous error, now both v1 and v2 are within the same function name
-
-diff --git a/tokenizing.c b/tokenizing.c
-index 6332b6d..ae26066 100644
---- a/tokenizing.c
-+++ b/tokenizing.c
-@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
- 
- 
- 
-+void tokenizing(void) {
- 
--/*
--// V1
--//void tokenizing(void) {
--
-+    // V1
-     printf("*** Start of Tokenizing Words Demo ***\n");
-     char words[BUFFER_SIZE];
-     char* nextWord = NULL;
-@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
-     do {
-         printf("Type a few words seperated by space (q - to quit):\n");
- 
--        fgets(words, BUFFER_SIZE, stdin); 
-+        fgets(words, BUFFER_SIZE, stdin);
-         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
- 
-         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
- 
-     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-             while (nextWord) {
--                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
-                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-             }
--       }
-+        }
-     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
- 
-     printf("*** End of Tokenizing Words Demo ***\n\n");
--}
--*/
- 
- 
--// V2
--/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
--void tokenizing(void) {
--
-+    // V2
-+    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-     printf("*** Start of Tokenizing Words Demo ***\n");
-     char phrases[BUFFER_SIZE];
-     char* nextPhrase = NULL;
-
-commit 23f162166b815502c16ac1456d8f9be87b799f26
-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-Date:   Tue Aug 9 19:09:02 2022 -0400
-
-    Update tokenizing.c to V2
-
-diff --git a/tokenizing.c b/tokenizing.c
-index edc3184..6332b6d 100644
---- a/tokenizing.c
-+++ b/tokenizing.c
-@@ -1,5 +1,5 @@
- /*
--Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
- [tokenizing.c] : [tokenizing]
- Purpose: [This function takes a user inputted string and tokenizes it]
- */
-@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
- #include "tokenizing.h"
- 
- 
--int main(void) {
--    tokenizing();
--    return 0;
--}
- 
+diff --git a/manipulating.c b/manipulating.c
+index 9193243..925e182 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
  
-+/*
  // V1
--void tokenizing(void) {
-+//void tokenizing(void) {
- 
-     printf("*** Start of Tokenizing Words Demo ***\n");
-     char words[BUFFER_SIZE];
-@@ -34,16 +31,46 @@ void tokenizing(void) {
-             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
- 
--        
--    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-+    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-             while (nextWord) {
-                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-             }
--        }
-+       }
-     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
- 
-     printf("*** End of Tokenizing Words Demo ***\n\n");
- }
-+*/
-+
-+
-+// V2
-+/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-+void tokenizing(void) {
-+
-+    printf("*** Start of Tokenizing Words Demo ***\n");
-+    char phrases[BUFFER_SIZE];
-+    char* nextPhrase = NULL;
-+    int phrasesCounter;
-+    do {
-+        printf("Type a few words seperated by comma (q - to quit):\n");
-+
-+        fgets(phrases, BUFFER_SIZE, stdin); 
-+        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+
-+        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
-+            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
-+            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+
-+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
-+            while (nextPhrase) {
-+                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
-+                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
-+            }
-+        }
-+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+
-+    printf("*** End of Tokenizing Words Demo ***\n\n");
-+}
- 
- 
-
-commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-Date:   Tue Aug 9 19:06:55 2022 -0400
-
-    V1
-
-diff --git a/tokenizing.c b/tokenizing.c
-index 417d34a..edc3184 100644
---- a/tokenizing.c
-+++ b/tokenizing.c
-@@ -1,80 +1,49 @@
--/*
--Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
--[tokenizing.c] : [tokenizing]
--Purpose: [This function takes a user inputted string and tokenizes it]
--*/
--
--
--// TOKENIZING MODULE SOURCE
--#define _CRT_SECURE_NO_WARNINGS
--#define BUFFER_SIZE 300
--#include "tokenizing.h"
--
--
--int main(void) {
--    tokenizing();
--    return 0;
--}
--
--
--/*
--// V1
--//void tokenizing(void) {
--
--    printf("*** Start of Tokenizing Words Demo ***\n");
--    char words[BUFFER_SIZE];
--    char* nextWord = NULL;
--    int wordsCounter;
--    do {
--        printf("Type a few words seperated by space (q - to quit):\n");
--
--        fgets(words, BUFFER_SIZE, stdin); 
--        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
--
--        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
--            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
--            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
--
--    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
--            while (nextWord) {
--                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
--                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
--            }
--       }
--    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
--
--    printf("*** End of Tokenizing Words Demo ***\n\n");
--}
--*/
--
--
--// V2
--/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
--void tokenizing(void) {
--
--    printf("*** Start of Tokenizing Words Demo ***\n");
--    char phrases[BUFFER_SIZE];
--    char* nextPhrase = NULL;
--    int phrasesCounter;
--    do {
--        printf("Type a few words seperated by comma (q - to quit):\n");
--
--        fgets(phrases, BUFFER_SIZE, stdin); 
--        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
--
--        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
--            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
--            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
--
--    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
--            while (nextPhrase) {
--                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
--                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
--            }
--        }
--    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
--
--    printf("*** End of Tokenizing Words Demo ***\n\n");
--}
--
--
-+/*
-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-+[tokenizing.c] : [tokenizing]
-+Purpose: [This function takes a user inputted string and tokenizes it]
-+*/
-+
-+
-+// TOKENIZING MODULE SOURCE
-+#define _CRT_SECURE_NO_WARNINGS
-+#define BUFFER_SIZE 300
-+#include "tokenizing.h"
-+
-+
-+int main(void) {
-+    tokenizing();
-+    return 0;
-+}
-+
-+
-+// V1
-+void tokenizing(void) {
-+
-+    printf("*** Start of Tokenizing Words Demo ***\n");
-+    char words[BUFFER_SIZE];
-+    char* nextWord = NULL;
-+    int wordsCounter;
-+    do {
-+        printf("Type a few words seperated by space (q - to quit):\n");
-+
-+        fgets(words, BUFFER_SIZE, stdin); 
-+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+
-+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+
-+        
-+    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-+            while (nextWord) {
-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+            }
-+        }
-+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+
-+    printf("*** End of Tokenizing Words Demo ***\n\n");
-+}
-+
-+
-
-commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
-Author: CRYPTO43 <singharshjot07@gmail.com>
-Date:   Tue Aug 9 17:12:27 2022 -0400
-
-    first commit
-
-diff --git a/fundamentals.c b/fundamentals.c
-new file mode 100644
-index 0000000..cd7cd9f
---- /dev/null
-+++ b/fundamentals.c
-@@ -0,0 +1,63 @@
-+/*
-+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
-+fundamentals.c : indexing
-+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
-+*/
-+
-+
-+// FUNDAMENTALS MODULE SOURCE 
-+#define _CRT_SECURE_NO_WARNINGS 
-+#define BUFFER_SIZE 80
-+#define NUM_INPUT_SIZE 10 
-+#include "fundamentals.h"
-+
-+
-+void main(void) {
-+
-+// V1
-+    printf("*** start of Indexing Strings Demo ***\n"); 
-+    char buffer1[BUFFER_SIZE]; 
-+    char numInput[NUM_INPUT_SIZE]; 
-+    size_t position; 
-+    do {
-+        printf("Type not empty string (q - to quit): \n"); 
-+        fgets (buffer1, BUFFER_SIZE, stdin); 
-+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
-+
-+        // checks if entered string is not equals to 'q'.
-+        if (strcmp (buffer1, "q") != 0) { 
-+            printf("Type the character position within the string: \n"); 
-+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
-+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
-+            position = atoi (numInput); // Converts entered string to integer.
-+
-+            // Checks if converted integer is larger then string length and assigns max position if true.
-+            if (position >= strlen (buffer1)) { 
-+                position = strlen (buffer1) - 1; 
-+                printf("Too big... Position reduced to max. availbale\n");
-+            }
-+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
-+        }
-+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
-+    printf("*** End of Indexing Strings Demo ***\n\n");
-+
-+
-+
-+    // V2 
-+    printf("*** Start of Measuring Strings Demo ***\n"); 
-+    char buffer2[BUFFER_SIZE]; 
-+    do { 
-+        printf("Type a string (q - to quit):\n"); 
-+        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
-+        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
-+
-+        // checks if entered string is not equals to 'q'.
-+        if (strcmp(buffer2, "q") != 0) 
-+            printf("The length of \'%s\' is %d characters\n", 
-+            buffer2, (int)strlen(buffer2)); 
-+        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
-+        
-+        printf("*** End of Measuring Strings Demo ***\n\n");
-+}
-+
-+ 
-\ No newline at end of file
-diff --git a/fundamentals.h b/fundamentals.h
-new file mode 100644
-index 0000000..383cccc
---- /dev/null
-+++ b/fundamentals.h
-@@ -0,0 +1,12 @@
-+// FUNDAMENTALS MODULE HEADER 
-+#ifndef _FUNDAMENTALS_H_
-+#define _FUNDAMENTALS_H_
-+
-+#include <stdio.h> 
-+#include <stdlib.h> 
-+#include <string.h>
-+
-+//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
-+void main(void);
-+
-+#endif
-\ No newline at end of file
-
-commit 425a7ac33f432099cac3faa3a90bb69daf84067f
-Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-Date:   Tue Aug 9 16:17:34 2022 -0400
-
-    Add files via upload
-    
-    Version 2
-
-diff --git a/tokenizing.c b/tokenizing.c
-index 65d1c20..417d34a 100644
---- a/tokenizing.c
-+++ b/tokenizing.c
-@@ -1,42 +1,80 @@
--/*
--Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
--[tokenizing.c] : [tokenizing]
--Purpose: [This function takes a user inputted string and tokenizes it]
--*/
--
--
--// TOKENIZING MODULE SOURCE
--#define _CRT_SECURE_NO_WARNINGS
--#define BUFFER_SIZE 300
--#include "tokenizing.h"
--
--// V1
--void tokenizing(void) {
--
--    printf("*** Start of Tokenizing Words Demo ***\n");
--    char words[BUFFER_SIZE];
--    char* nextWord = NULL;
--    int wordsCounter;
--    do {
--        printf("Type a few words seperated by space (q - to quit):\n");
--
--        fgets(words, BUFFER_SIZE, stdin); 
--        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
--
--        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
--            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
--            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
--
--        
--    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
--            while (nextWord) {
--                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
--                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
--            }
--        }
--    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
--
--    printf("*** End of Tokenizing Words Demo ***\n\n");
--}
--
--
-+/*
-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
-+[tokenizing.c] : [tokenizing]
-+Purpose: [This function takes a user inputted string and tokenizes it]
-+*/
-+
-+
-+// TOKENIZING MODULE SOURCE
-+#define _CRT_SECURE_NO_WARNINGS
-+#define BUFFER_SIZE 300
-+#include "tokenizing.h"
-+
-+
-+int main(void) {
-+    tokenizing();
-+    return 0;
-+}
-+
-+
-+/*
-+// V1
-+//void tokenizing(void) {
-+
-+    printf("*** Start of Tokenizing Words Demo ***\n");
-+    char words[BUFFER_SIZE];
-+    char* nextWord = NULL;
-+    int wordsCounter;
-+    do {
-+        printf("Type a few words seperated by space (q - to quit):\n");
-+
-+        fgets(words, BUFFER_SIZE, stdin); 
-+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+
-+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+
-+    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-+            while (nextWord) {
-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+            }
-+       }
-+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+
-+    printf("*** End of Tokenizing Words Demo ***\n\n");
-+}
-+*/
-+
-+
-+// V2
-+/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-+void tokenizing(void) {
-+
-+    printf("*** Start of Tokenizing Words Demo ***\n");
-+    char phrases[BUFFER_SIZE];
-+    char* nextPhrase = NULL;
-+    int phrasesCounter;
-+    do {
-+        printf("Type a few words seperated by comma (q - to quit):\n");
-+
-+        fgets(phrases, BUFFER_SIZE, stdin); 
-+        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+
-+        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
-+            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
-+            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+
-+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
-+            while (nextPhrase) {
-+                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
-+                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
-+            }
-+        }
-+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+
-+    printf("*** End of Tokenizing Words Demo ***\n\n");
-+}
-+
-+
-diff --git a/tokenizing.h b/tokenizing.h
-index c00f3cb..7899cc2 100644
---- a/tokenizing.h
-+++ b/tokenizing.h
-@@ -1,10 +1,10 @@
--// Tokenization header file
--#ifndef _TOKENIZING_H_
--#define _TOKENIZING_H_
--
--#include <stdio.h>
--#include <string.h>
--
--void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
--
-+// Tokenization header file
-+#ifndef _TOKENIZING_H_
-+#define _TOKENIZING_H_
-+
-+#include <stdio.h>
-+#include <string.h>
-+
-+void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
-+
- #endif
-\ No newline at end of file
-
-commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
-Author: rsaguros <rsaguros1@myseneca.ca>
-Date:   Mon Aug 8 15:47:34 2022 -0400
-
-    Version 2
-    
-    Version 2
-
-diff --git a/converting.c b/converting.c
-index c5a0775..df23173 100644
---- a/converting.c
-+++ b/converting.c
-@@ -1,6 +1,6 @@
- // CONVERTING MODULE SOURCE
- /*
--Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
-+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
- converting.c : CONVERTING
- Purpose: This program converts integer numeric strings inputted by the user to an integer value.
- */
-@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
- // strings and convert a string to an integer value.
- #include "converting.h"
- 
--// V1
- void converting(void) {
-+	// V1
- 	// Display beginning message
- 	printf("*** Start of Converting Strings to int Demo ***\n");
+ void manipulating(void) {
+-/* Purpose: This function concatenates 2 input strings */
++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
  
-@@ -38,6 +38,30 @@ void converting(void) {
+ 	printf("*** Start of Concatenating Strings Demo ***\n");
+ 	char string1[BUFFER_SIZE];
+@@ -56,4 +56,27 @@ void manipulating(void) {
  		}
- 	} while (strcmp(intString, "q") != 0);
- 
--	// Display ending message and exit module.
-+	// Display ending message for int demo
- 	printf("*** End of Converting Strings to int Demo ***\n\n");
+ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+ 	printf("*** End of Comparing Strings Demo ***\n\n");
 +
-+	// V2
-+	printf("*** Start of Converting Strings to double Demo ***\n");
-+
-+	char	doubleString[BUFFER_SIZE];
-+	double	doubleNumber;
 +
++//V3
++	printf("*** Start of Searching Strings Demo ***\n");
++	char haystack[BUFFER_SIZE];
++	char needle[BUFFER_SIZE];
++	char* occurence = NULL;
 +	do {
-+		// Prompt user for entry, replacing the new line read by 
-+		// fgets with a null terminator
-+		printf("Type an double numeric string (q - to quit):\n");
-+		fgets(doubleString, BUFFER_SIZE, stdin);
-+		doubleString[strlen(doubleString) - 1] = '\0';
-+
-+		// Check user input, exit if 'q' was entered.  
-+		if ((strcmp(doubleString, "q") != 0)) {
-+
-+			// Convert user entry from numeric string to a double, then display it
-+			doubleNumber = atof(doubleString);
-+			printf("Converted number is %f\n", doubleNumber);
++		printf("Type the string (q - to quit):\n");
++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
++			printf("Type the substring:\n");
++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
++			if (occurence)							// If found, return the position where 2nd string occurs
++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
++			else						
++				printf("Not found\n");				
 +		}
-+	} while (strcmp(doubleString, "q") != 0);
-+
-+	printf("*** End of Converting Strings to double Demo ***\n\n");
++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Searching Strings Demo ***\n\n");
  }
+\ No newline at end of file
 
-commit e25ade313038da86c407f85f5c00586ba6b37a1b
-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-Date:   Mon Aug 8 15:05:20 2022 -0400
-
-    Update README.md
-
-diff --git a/README.md b/README.md
-index 28e7c31..f1ff45d 100644
---- a/README.md
-+++ b/README.md
-@@ -1,5 +1,8 @@
- # CPR101_Project
- CPR101 Final Project
-+
- Section: NAA
-+
- Group 1
-+
- Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
-
-commit a3e1e5ae394af27b186e61562b7167819c90ea13
-Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-Date:   Mon Aug 8 15:01:47 2022 -0400
-
-    Create README.md
-
-diff --git a/README.md b/README.md
-new file mode 100644
-index 0000000..28e7c31
---- /dev/null
-+++ b/README.md
-@@ -0,0 +1,5 @@
-+# CPR101_Project
-+CPR101 Final Project
-+Section: NAA
-+Group 1
-+Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
-
-commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
 Author: rsaguros <rsaguros1@myseneca.ca>
-Date:   Mon Aug 8 13:58:05 2022 -0400
+Date:   Tue Aug 9 23:04:40 2022 -0400
 
-    Update converting.c
+    Adding git logs
     
-    Version 2
+    Version 2 Git Logs
+    $ git --no-pager log -p > "module-git-log.txt"
 
-diff --git a/converting.c b/converting.c
-index c5a0775..df23173 100644
---- a/converting.c
-+++ b/converting.c
-@@ -1,6 +1,6 @@
- // CONVERTING MODULE SOURCE
- /*
--Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
-+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
- converting.c : CONVERTING
- Purpose: This program converts integer numeric strings inputted by the user to an integer value.
- */
-@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
- // strings and convert a string to an integer value.
- #include "converting.h"
- 
--// V1
- void converting(void) {
-+	// V1
- 	// Display beginning message
- 	printf("*** Start of Converting Strings to int Demo ***\n");
- 
-@@ -38,6 +38,30 @@ void converting(void) {
- 		}
- 	} while (strcmp(intString, "q") != 0);
- 
--	// Display ending message and exit module.
-+	// Display ending message for int demo
- 	printf("*** End of Converting Strings to int Demo ***\n\n");
-+
-+	// V2
-+	printf("*** Start of Converting Strings to double Demo ***\n");
-+
-+	char	doubleString[BUFFER_SIZE];
-+	double	doubleNumber;
-+
-+	do {
-+		// Prompt user for entry, replacing the new line read by 
-+		// fgets with a null terminator
-+		printf("Type an double numeric string (q - to quit):\n");
-+		fgets(doubleString, BUFFER_SIZE, stdin);
-+		doubleString[strlen(doubleString) - 1] = '\0';
-+
-+		// Check user input, exit if 'q' was entered.  
-+		if ((strcmp(doubleString, "q") != 0)) {
-+
-+			// Convert user entry from numeric string to a double, then display it
-+			doubleNumber = atof(doubleString);
-+			printf("Converted number is %f\n", doubleNumber);
-+		}
-+	} while (strcmp(doubleString, "q") != 0);
+diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/manipulating-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
 +
-+	printf("*** End of Converting Strings to double Demo ***\n\n");
- }
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
 
 commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
 Author: krpm <mungcalrina@gmail.com>
@@ -764,27 +1430,6 @@ index 953e516..9193243 100644
  			printf("Type the 2nd string to compare:\n");
  			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
 
-commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
-Author: krpm <mungcalrina@gmail.com>
-Date:   Mon Aug 8 12:51:35 2022 -0400
-
-    Version 2
-    
-    Updated main for version 2
-
-diff --git a/main.c b/main.c
-index 755b397..70aeeb7 100644
---- a/main.c
-+++ b/main.c
-@@ -1,6 +1,6 @@
- // MAIN 
- /*
--Author: BB01, 03/08/2022, CPR101, Final Project V1
-+Author: BB01, 03/08/2022, CPR101, Final Project
- main.c : MAIN
- Purpose: Main Function used to prompt user for which various options.
- */
-
 commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
 Author: kiararina <kiararina.pelenio@upou.edu.ph>
 Date:   Mon Aug 8 09:38:48 2022 -0500
@@ -882,329 +1527,6 @@ Date:   Thu Aug 4 16:30:00 2022 -0400
 
     Version 1
 
-diff --git a/Programming Comments.docx b/Programming Comments.docx
-new file mode 100644
-index 0000000..07d1cd7
---- /dev/null
-+++ b/Programming Comments.docx	
-@@ -0,0 +1,110 @@
-+                        Commenting Program Source Code
-+--------------------------------------------------------------------------------
-+Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
-+--------------------------------------------------------------------------------
-+In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
-+Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
-+Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
-+Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
-+Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
-+You know you have good comments if you delete all the code and what's left still makes sense as a program.
-+Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
-+75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
-+Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
-+Comments are for programmers who will maintain the code in the future. 
-+Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
-+Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
-+--------------------------------------------------------------------------------
-+Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
-+--------------------------------------------------------------------------------
-+
-+Organisation of Comments
-+Program comments 
-+ -  appear at the beginning of a source file.
-+/* 
-+Author: Name, email, ID, Date written, Course, Project
-+[executable filename] : [title of program]
-+Purpose: [what this program does, what problem does it solve?]
-+*/
-+
-+Function comments
-+The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
-+/*
-+Purpose: [what this function does, what problem does it solve?]
-+Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
-+Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
-+Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
-+*/
-+
-+Inline code comments
-+Your comment must say something different than explaining the code itself. 
-+c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
-+Ideally, variable names should be self-explanatory. When they are not, comments are required.
-+c = a + b;  // c stores total of assignment and test marks respectively.
-+
-+Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
-+cryptic = C + code; 		// explain this line's purpose in the program
-+crypticly = C + moreCode;	// explain this line's purpose in the program
-+
-+Longer code comments
-+Sometimes comments need more space than would fit inline. 
-+cryptic = C + code;
-+// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
-+moreCrypticly = C + moreCode;	
-+
-+Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
-+// this comment explains the purpose of the next line of code  
-+cryptic = C + code;
-+ 		
-+// this comment explains the purpose of the next line of code  
-+moreCrypticly = C + moreCode;	
-+		
-+
-+Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
-+
-+Structures
-+Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
-+// [what the structure accomplishes]
-+e.g. 
-+// compute factorial	
-+// prompt user until value within range 1  -  100 is input
-+Code Samples
-+printf("Type a few words separated by space(q - to quit):\n");
-+gets(words);
-+while (strcmp(words, "q") != 0) 
-+{
-+    word = strtok(words, " ");
-+    w_counter = 1;
-+    while (word) 
-+    {
-+        printf("Word #%d is \'%s\'\n", w_counter++, word);
-+        word = strtok(NULL, " ");
-+    }
-+    printf("Type a few words separated by space(q - to quit):\n");
-+    gets(words);
-+}
-+
-+ the first while continues until the 'words' variable is equal to "q". What is it for?
-+ there is another while {structure} ... what does it do?
-+ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
-+ // keep looping until pointer is NULL
-+This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
-+ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
-+ This technique is even more important at the end of a series nested structures, e.g.
-+      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
-+   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
-+} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
-+
-+
-+Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
-+
-+while (TRUE) // a comment explains why there is no exit condition here
-+{
-+ 	. . .
-+   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
-+   // --------- ********   make it visually obvious that this causes another iteration of the structure
-+. . .
-+   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
-+   // --------- *****      make it visually obvious that this is an exit from the structure
-+. . .
-+}
-diff --git a/converting.c b/converting.c
-new file mode 100644
-index 0000000..c5a0775
---- /dev/null
-+++ b/converting.c
-@@ -0,0 +1,43 @@
-+// CONVERTING MODULE SOURCE
-+/*
-+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
-+converting.c : CONVERTING
-+Purpose: This program converts integer numeric strings inputted by the user to an integer value.
-+*/
-+
-+#define	_CRT_SECURE_NO_WARNINGS
-+#define BUFFER_SIZE 80
-+
-+// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
-+// strings and convert a string to an integer value.
-+#include "converting.h"
-+
-+// V1
-+void converting(void) {
-+	// Display beginning message
-+	printf("*** Start of Converting Strings to int Demo ***\n");
-+
-+	// Declare variables
-+	char	intString[BUFFER_SIZE];
-+	int		intNumber;
-+
-+	do {
-+		// Prompt user for entry
-+		printf("Type an int numeric string (q - to quit):\n");
-+		fgets(intString, BUFFER_SIZE, stdin);
-+		intString[strlen(intString) - 1] = '\0';
-+
-+		// Check user input, exit if 'q' was entered.
-+		if (strcmp(intString, "q") != 0) {
-+
-+			// Convert user entry from string to integer value.
-+			intNumber = atoi(intString);
-+
-+			// Display converted number.
-+			printf("Converted number is %d\n", intNumber);
-+		}
-+	} while (strcmp(intString, "q") != 0);
-+
-+	// Display ending message and exit module.
-+	printf("*** End of Converting Strings to int Demo ***\n\n");
-+}
-diff --git a/converting.h b/converting.h
-new file mode 100644
-index 0000000..03c62a3
---- /dev/null
-+++ b/converting.h
-@@ -0,0 +1,18 @@
-+// CONVERTING MODULE HEADER
-+#ifndef _CONVERTING_H_
-+#define _CONVERTING_H_
-+
-+// Libraries
-+#include <stdio.h>
-+#include <string.h>
-+#include <stdlib.h>
-+
-+
-+/////////////////////////
-+// Prototype  Function //
-+/////////////////////////
-+
-+// Function used to apply conversions
-+void converting(void);
-+
-+#endif
-diff --git a/fundamentals.c b/fundamentals.c
-new file mode 100644
-index 0000000..95c9f23
---- /dev/null
-+++ b/fundamentals.c
-@@ -0,0 +1,43 @@
-+/*
-+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
-+fundamentals.c : indexing
-+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
-+*/
-+
-+
-+// FUNDAMENTALS MODULE SOURCE 
-+#define _CRT_SECURE_NO_WARNINGS 
-+#define BUFFER_SIZE 80
-+#define NUM_INPUT_SIZE 10 
-+#include "fundamentals.h"
-+
-+
-+void fundamentals(void) {
-+
-+// V1
-+    printf("*** start of Indexing Strings Demo ***\n"); 
-+    char buffer1[BUFFER_SIZE]; 
-+    char numInput[NUM_INPUT_SIZE]; 
-+    size_t position; 
-+    do {
-+        printf("Type not empty string (q - to quit): \n"); 
-+        fgets (buffer1, BUFFER_SIZE, stdin); 
-+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
-+
-+        // checks if entered string is not equals to 'q'.
-+        if (strcmp (buffer1, "q") != 0) { 
-+            printf("Type the character position within the string: \n"); 
-+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
-+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
-+            position = atoi (numInput); // Converts entered string to integer.
-+
-+            // Checks if converted integer is larger then string length and assigns max position if true.
-+            if (position >= strlen (buffer1)) { 
-+                position = strlen (buffer1) - 1; 
-+                printf("Too big... Position reduced to max. availbale\n");
-+            }
-+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
-+        }
-+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
-+    printf("*** End of Indexing Strings Demo ***\n\n");
-+}
-\ No newline at end of file
-diff --git a/fundamentals.h b/fundamentals.h
-new file mode 100644
-index 0000000..0433660
---- /dev/null
-+++ b/fundamentals.h
-@@ -0,0 +1,12 @@
-+// FUNDAMENTALS MODULE HEADER 
-+#ifndef _FUNDAMENTALS_H_
-+#define _FUNDAMENTALS_H_
-+
-+#include <stdio.h> 
-+#include <stdlib.h> 
-+#include <string.h>
-+
-+//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
-+void fundamentals(void);
-+
-+#endif
-\ No newline at end of file
-diff --git a/main.c b/main.c
-new file mode 100644
-index 0000000..755b397
---- /dev/null
-+++ b/main.c
-@@ -0,0 +1,58 @@
-+// MAIN 
-+/*
-+Author: BB01, 03/08/2022, CPR101, Final Project V1
-+main.c : MAIN
-+Purpose: Main Function used to prompt user for which various options.
-+*/
-+
-+// Include all necessary modules
-+#define _CRT_SECURE_NO_WARNINGS
-+#include "fundamentals.h"
-+#include "manipulating.h"
-+#include "converting.h"
-+#include "tokenizing.h"
-+
-+int main(void) {
-+	// Declare variables
-+	char buff[10];
-+
-+	// Open menu for user
-+	do {
-+		// Display menu options
-+		printf("1 - Fundamentals\n");
-+		printf("2 - Manipulation\n");
-+		printf("3 - Converting\n");
-+		printf("4 - Tokenizing\n");
-+		printf("0 - Exit\n");
-+		
-+		// Prompt user for input
-+		printf("Which module to run? \n");
-+		fgets(buff, 10, stdin);
-+
-+		// Analyze user entry and match selection
-+		switch (buff[0])
-+		{
-+		case '1': 
-+			// Call for fundamentals module
-+			fundamentals();
-+			break;
-+
-+		case '2': 
-+			// Call for manipulating module
-+			manipulating();
-+			break;
-+
-+		case '3': 
-+			// Call for converting module
-+			converting();
-+			break;
-+
-+		case '4': 
-+			// Call for tokenizing module
-+			tokenizing();
-+			break;
-+		}
-+	} while (buff[0] != '0');
-+	
-+	return 0;
-+}
-\ No newline at end of file
 diff --git a/manipulating.c b/manipulating.c
 new file mode 100644
 index 0000000..748c895
@@ -1263,83 +1585,3 @@ index 0000000..8a8f926
 +/* Purpose: This function concatenates 2 input strings */
 +
 +#endif
-diff --git a/tokenizing.c b/tokenizing.c
-new file mode 100644
-index 0000000..65d1c20
---- /dev/null
-+++ b/tokenizing.c
-@@ -0,0 +1,42 @@
-+/*
-+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-+[tokenizing.c] : [tokenizing]
-+Purpose: [This function takes a user inputted string and tokenizes it]
-+*/
-+
-+
-+// TOKENIZING MODULE SOURCE
-+#define _CRT_SECURE_NO_WARNINGS
-+#define BUFFER_SIZE 300
-+#include "tokenizing.h"
-+
-+// V1
-+void tokenizing(void) {
-+
-+    printf("*** Start of Tokenizing Words Demo ***\n");
-+    char words[BUFFER_SIZE];
-+    char* nextWord = NULL;
-+    int wordsCounter;
-+    do {
-+        printf("Type a few words seperated by space (q - to quit):\n");
-+
-+        fgets(words, BUFFER_SIZE, stdin); 
-+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+
-+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+
-+        
-+    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-+            while (nextWord) {
-+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+            }
-+        }
-+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+
-+    printf("*** End of Tokenizing Words Demo ***\n\n");
-+}
-+
-+
-diff --git a/tokenizing.h b/tokenizing.h
-new file mode 100644
-index 0000000..c00f3cb
---- /dev/null
-+++ b/tokenizing.h
-@@ -0,0 +1,10 @@
-+// Tokenization header file
-+#ifndef _TOKENIZING_H_
-+#define _TOKENIZING_H_
-+
-+#include <stdio.h>
-+#include <string.h>
-+
-+void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
-+
-+#endif
-\ No newline at end of file
-
-commit f914d3afae4107c77728b3df4d39502c962ba74b
-Author: krpm <mungcalrina@gmail.com>
-Date:   Thu Aug 4 15:48:50 2022 -0400
-
-    Initial commit
-
-diff --git a/.gitattributes b/.gitattributes
-new file mode 100644
-index 0000000..dfe0770
---- /dev/null
-+++ b/.gitattributes
-@@ -0,0 +1,2 @@
-+# Auto detect text files and perform LF normalization
-+* text=auto
diff --git a/manipulating_git_log.txt b/manipulating_git_log.txt
deleted file mode 100644
index 05aa537..0000000
--- a/manipulating_git_log.txt
+++ /dev/null
@@ -1,1587 +0,0 @@
-commit e14f5c429efccb7dc63749da2a425659ad905631
-Author: krpm <25734153+kiararina@users.noreply.github.com>
-Date:   Fri Aug 12 08:37:11 2022 -0400
-
-    Update manipulating.c for version 3.
-    
-    Added a section for checking the occurrence of 2nd string in 1st string.
-
-diff --git a/manipulating.c b/manipulating.c
-index 9193243..925e182 100644
---- a/manipulating.c
-+++ b/manipulating.c
-@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
- 
- // V1
- void manipulating(void) {
--/* Purpose: This function concatenates 2 input strings */
-+/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
- 
- 	printf("*** Start of Concatenating Strings Demo ***\n");
- 	char string1[BUFFER_SIZE];
-@@ -56,4 +56,27 @@ void manipulating(void) {
- 		}
- 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
- 	printf("*** End of Comparing Strings Demo ***\n\n");
-+
-+
-+//V3
-+	printf("*** Start of Searching Strings Demo ***\n");
-+	char haystack[BUFFER_SIZE];
-+	char needle[BUFFER_SIZE];
-+	char* occurence = NULL;
-+	do {
-+		printf("Type the string (q - to quit):\n");
-+		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
-+		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
-+		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
-+			printf("Type the substring:\n");
-+			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
-+			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
-+			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
-+			if (occurence)							// If found, return the position where 2nd string occurs
-+				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
-+			else						
-+				printf("Not found\n");				
-+		}
-+	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
-+	printf("*** End of Searching Strings Demo ***\n\n");
- }
-\ No newline at end of file
-
-commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
-Author: rsaguros <rsaguros1@myseneca.ca>
-Date:   Tue Aug 9 23:04:40 2022 -0400
-
-    Adding git logs
-    
-    Version 2 Git Logs
-    $ git --no-pager log -p > "module-git-log.txt"
-
-diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
-new file mode 100644
-index 0000000..7bb5209
---- /dev/null
-+++ b/manipulating-git-log.txt
-@@ -0,0 +1,1345 @@
-+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
-+Merge: 6361388 c3a8316
-+Author: rsaguros <rsaguros1@myseneca.ca>
-+Date:   Tue Aug 9 22:49:17 2022 -0400
-+
-+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
-+
-+commit 63613886b8f1ecccb62538d6d4b7905425a16358
-+Merge: 0626d2e c0f7dc8
-+Author: rsaguros <rsaguros1@myseneca.ca>
-+Date:   Tue Aug 9 22:47:37 2022 -0400
-+
-+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
-+
-+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
-+Merge: 9d98950 c0f7dc8
-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-+Date:   Tue Aug 9 22:46:28 2022 -0400
-+
-+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
-+
-+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
-+Merge: fd97b97 a2a1bf4
-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-+Date:   Tue Aug 9 22:44:47 2022 -0400
-+
-+    Merge pull request #1 from kiararina/converting
-+    
-+    Recovering lost commits up to converting.c
-+
-+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
-+Merge: cee497d fd97b97
-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-+Date:   Tue Aug 9 22:44:00 2022 -0400
-+
-+    Merge branch 'main' into converting
-+
-+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-+Date:   Tue Aug 9 19:23:44 2022 -0400
-+
-+    tokenizing.c v2 corrected
-+    
-+    Corrected a previous error, now both v1 and v2 are within the same function name
-+
-+diff --git a/tokenizing.c b/tokenizing.c
-+index 6332b6d..ae26066 100644
-+--- a/tokenizing.c
-++++ b/tokenizing.c
-+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
-+ 
-+ 
-+ 
-++void tokenizing(void) {
-+ 
-+-/*
-+-// V1
-+-//void tokenizing(void) {
-+-
-++    // V1
-+     printf("*** Start of Tokenizing Words Demo ***\n");
-+     char words[BUFFER_SIZE];
-+     char* nextWord = NULL;
-+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
-+     do {
-+         printf("Type a few words seperated by space (q - to quit):\n");
-+ 
-+-        fgets(words, BUFFER_SIZE, stdin); 
-++        fgets(words, BUFFER_SIZE, stdin);
-+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+ 
-+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
-+ 
-+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-+             while (nextWord) {
-+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
-+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+             }
-+-       }
-++        }
-+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+ 
-+     printf("*** End of Tokenizing Words Demo ***\n\n");
-+-}
-+-*/
-+ 
-+ 
-+-// V2
-+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-+-void tokenizing(void) {
-+-
-++    // V2
-++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-+     printf("*** Start of Tokenizing Words Demo ***\n");
-+     char phrases[BUFFER_SIZE];
-+     char* nextPhrase = NULL;
-+
-+commit 23f162166b815502c16ac1456d8f9be87b799f26
-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-+Date:   Tue Aug 9 19:09:02 2022 -0400
-+
-+    Update tokenizing.c to V2
-+
-+diff --git a/tokenizing.c b/tokenizing.c
-+index edc3184..6332b6d 100644
-+--- a/tokenizing.c
-++++ b/tokenizing.c
-+@@ -1,5 +1,5 @@
-+ /*
-+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
-+ [tokenizing.c] : [tokenizing]
-+ Purpose: [This function takes a user inputted string and tokenizes it]
-+ */
-+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
-+ #include "tokenizing.h"
-+ 
-+ 
-+-int main(void) {
-+-    tokenizing();
-+-    return 0;
-+-}
-+ 
-+ 
-++/*
-+ // V1
-+-void tokenizing(void) {
-++//void tokenizing(void) {
-+ 
-+     printf("*** Start of Tokenizing Words Demo ***\n");
-+     char words[BUFFER_SIZE];
-+@@ -34,16 +31,46 @@ void tokenizing(void) {
-+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+ 
-+-        
-+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-+             while (nextWord) {
-+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+             }
-+-        }
-++       }
-+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+ 
-+     printf("*** End of Tokenizing Words Demo ***\n\n");
-+ }
-++*/
-++
-++
-++// V2
-++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-++void tokenizing(void) {
-++
-++    printf("*** Start of Tokenizing Words Demo ***\n");
-++    char phrases[BUFFER_SIZE];
-++    char* nextPhrase = NULL;
-++    int phrasesCounter;
-++    do {
-++        printf("Type a few words seperated by comma (q - to quit):\n");
-++
-++        fgets(phrases, BUFFER_SIZE, stdin); 
-++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-++
-++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
-++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
-++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-++
-++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
-++            while (nextPhrase) {
-++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
-++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
-++            }
-++        }
-++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-++
-++    printf("*** End of Tokenizing Words Demo ***\n\n");
-++}
-+ 
-+ 
-+
-+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-+Date:   Tue Aug 9 19:06:55 2022 -0400
-+
-+    V1
-+
-+diff --git a/tokenizing.c b/tokenizing.c
-+index 417d34a..edc3184 100644
-+--- a/tokenizing.c
-++++ b/tokenizing.c
-+@@ -1,80 +1,49 @@
-+-/*
-+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
-+-[tokenizing.c] : [tokenizing]
-+-Purpose: [This function takes a user inputted string and tokenizes it]
-+-*/
-+-
-+-
-+-// TOKENIZING MODULE SOURCE
-+-#define _CRT_SECURE_NO_WARNINGS
-+-#define BUFFER_SIZE 300
-+-#include "tokenizing.h"
-+-
-+-
-+-int main(void) {
-+-    tokenizing();
-+-    return 0;
-+-}
-+-
-+-
-+-/*
-+-// V1
-+-//void tokenizing(void) {
-+-
-+-    printf("*** Start of Tokenizing Words Demo ***\n");
-+-    char words[BUFFER_SIZE];
-+-    char* nextWord = NULL;
-+-    int wordsCounter;
-+-    do {
-+-        printf("Type a few words seperated by space (q - to quit):\n");
-+-
-+-        fgets(words, BUFFER_SIZE, stdin); 
-+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+-
-+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+-
-+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-+-            while (nextWord) {
-+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+-            }
-+-       }
-+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+-
-+-    printf("*** End of Tokenizing Words Demo ***\n\n");
-+-}
-+-*/
-+-
-+-
-+-// V2
-+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-+-void tokenizing(void) {
-+-
-+-    printf("*** Start of Tokenizing Words Demo ***\n");
-+-    char phrases[BUFFER_SIZE];
-+-    char* nextPhrase = NULL;
-+-    int phrasesCounter;
-+-    do {
-+-        printf("Type a few words seperated by comma (q - to quit):\n");
-+-
-+-        fgets(phrases, BUFFER_SIZE, stdin); 
-+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+-
-+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
-+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
-+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+-
-+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
-+-            while (nextPhrase) {
-+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
-+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
-+-            }
-+-        }
-+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+-
-+-    printf("*** End of Tokenizing Words Demo ***\n\n");
-+-}
-+-
-+-
-++/*
-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-++[tokenizing.c] : [tokenizing]
-++Purpose: [This function takes a user inputted string and tokenizes it]
-++*/
-++
-++
-++// TOKENIZING MODULE SOURCE
-++#define _CRT_SECURE_NO_WARNINGS
-++#define BUFFER_SIZE 300
-++#include "tokenizing.h"
-++
-++
-++int main(void) {
-++    tokenizing();
-++    return 0;
-++}
-++
-++
-++// V1
-++void tokenizing(void) {
-++
-++    printf("*** Start of Tokenizing Words Demo ***\n");
-++    char words[BUFFER_SIZE];
-++    char* nextWord = NULL;
-++    int wordsCounter;
-++    do {
-++        printf("Type a few words seperated by space (q - to quit):\n");
-++
-++        fgets(words, BUFFER_SIZE, stdin); 
-++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-++
-++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-++
-++        
-++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-++            while (nextWord) {
-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-++            }
-++        }
-++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-++
-++    printf("*** End of Tokenizing Words Demo ***\n\n");
-++}
-++
-++
-+
-+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
-+Author: CRYPTO43 <singharshjot07@gmail.com>
-+Date:   Tue Aug 9 17:12:27 2022 -0400
-+
-+    first commit
-+
-+diff --git a/fundamentals.c b/fundamentals.c
-+new file mode 100644
-+index 0000000..cd7cd9f
-+--- /dev/null
-++++ b/fundamentals.c
-+@@ -0,0 +1,63 @@
-++/*
-++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
-++fundamentals.c : indexing
-++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
-++*/
-++
-++
-++// FUNDAMENTALS MODULE SOURCE 
-++#define _CRT_SECURE_NO_WARNINGS 
-++#define BUFFER_SIZE 80
-++#define NUM_INPUT_SIZE 10 
-++#include "fundamentals.h"
-++
-++
-++void main(void) {
-++
-++// V1
-++    printf("*** start of Indexing Strings Demo ***\n"); 
-++    char buffer1[BUFFER_SIZE]; 
-++    char numInput[NUM_INPUT_SIZE]; 
-++    size_t position; 
-++    do {
-++        printf("Type not empty string (q - to quit): \n"); 
-++        fgets (buffer1, BUFFER_SIZE, stdin); 
-++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
-++
-++        // checks if entered string is not equals to 'q'.
-++        if (strcmp (buffer1, "q") != 0) { 
-++            printf("Type the character position within the string: \n"); 
-++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
-++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
-++            position = atoi (numInput); // Converts entered string to integer.
-++
-++            // Checks if converted integer is larger then string length and assigns max position if true.
-++            if (position >= strlen (buffer1)) { 
-++                position = strlen (buffer1) - 1; 
-++                printf("Too big... Position reduced to max. availbale\n");
-++            }
-++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
-++        }
-++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
-++    printf("*** End of Indexing Strings Demo ***\n\n");
-++
-++
-++
-++    // V2 
-++    printf("*** Start of Measuring Strings Demo ***\n"); 
-++    char buffer2[BUFFER_SIZE]; 
-++    do { 
-++        printf("Type a string (q - to quit):\n"); 
-++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
-++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
-++
-++        // checks if entered string is not equals to 'q'.
-++        if (strcmp(buffer2, "q") != 0) 
-++            printf("The length of \'%s\' is %d characters\n", 
-++            buffer2, (int)strlen(buffer2)); 
-++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
-++        
-++        printf("*** End of Measuring Strings Demo ***\n\n");
-++}
-++
-++ 
-+\ No newline at end of file
-+diff --git a/fundamentals.h b/fundamentals.h
-+new file mode 100644
-+index 0000000..383cccc
-+--- /dev/null
-++++ b/fundamentals.h
-+@@ -0,0 +1,12 @@
-++// FUNDAMENTALS MODULE HEADER 
-++#ifndef _FUNDAMENTALS_H_
-++#define _FUNDAMENTALS_H_
-++
-++#include <stdio.h> 
-++#include <stdlib.h> 
-++#include <string.h>
-++
-++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
-++void main(void);
-++
-++#endif
-+\ No newline at end of file
-+
-+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
-+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
-+Date:   Tue Aug 9 16:17:34 2022 -0400
-+
-+    Add files via upload
-+    
-+    Version 2
-+
-+diff --git a/tokenizing.c b/tokenizing.c
-+index 65d1c20..417d34a 100644
-+--- a/tokenizing.c
-++++ b/tokenizing.c
-+@@ -1,42 +1,80 @@
-+-/*
-+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-+-[tokenizing.c] : [tokenizing]
-+-Purpose: [This function takes a user inputted string and tokenizes it]
-+-*/
-+-
-+-
-+-// TOKENIZING MODULE SOURCE
-+-#define _CRT_SECURE_NO_WARNINGS
-+-#define BUFFER_SIZE 300
-+-#include "tokenizing.h"
-+-
-+-// V1
-+-void tokenizing(void) {
-+-
-+-    printf("*** Start of Tokenizing Words Demo ***\n");
-+-    char words[BUFFER_SIZE];
-+-    char* nextWord = NULL;
-+-    int wordsCounter;
-+-    do {
-+-        printf("Type a few words seperated by space (q - to quit):\n");
-+-
-+-        fgets(words, BUFFER_SIZE, stdin); 
-+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-+-
-+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-+-
-+-        
-+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-+-            while (nextWord) {
-+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-+-            }
-+-        }
-+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-+-
-+-    printf("*** End of Tokenizing Words Demo ***\n\n");
-+-}
-+-
-+-
-++/*
-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
-++[tokenizing.c] : [tokenizing]
-++Purpose: [This function takes a user inputted string and tokenizes it]
-++*/
-++
-++
-++// TOKENIZING MODULE SOURCE
-++#define _CRT_SECURE_NO_WARNINGS
-++#define BUFFER_SIZE 300
-++#include "tokenizing.h"
-++
-++
-++int main(void) {
-++    tokenizing();
-++    return 0;
-++}
-++
-++
-++/*
-++// V1
-++//void tokenizing(void) {
-++
-++    printf("*** Start of Tokenizing Words Demo ***\n");
-++    char words[BUFFER_SIZE];
-++    char* nextWord = NULL;
-++    int wordsCounter;
-++    do {
-++        printf("Type a few words seperated by space (q - to quit):\n");
-++
-++        fgets(words, BUFFER_SIZE, stdin); 
-++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-++
-++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-++
-++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-++            while (nextWord) {
-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-++            }
-++       }
-++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-++
-++    printf("*** End of Tokenizing Words Demo ***\n\n");
-++}
-++*/
-++
-++
-++// V2
-++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-++void tokenizing(void) {
-++
-++    printf("*** Start of Tokenizing Words Demo ***\n");
-++    char phrases[BUFFER_SIZE];
-++    char* nextPhrase = NULL;
-++    int phrasesCounter;
-++    do {
-++        printf("Type a few words seperated by comma (q - to quit):\n");
-++
-++        fgets(phrases, BUFFER_SIZE, stdin); 
-++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-++
-++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
-++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
-++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-++
-++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
-++            while (nextPhrase) {
-++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
-++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
-++            }
-++        }
-++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-++
-++    printf("*** End of Tokenizing Words Demo ***\n\n");
-++}
-++
-++
-+diff --git a/tokenizing.h b/tokenizing.h
-+index c00f3cb..7899cc2 100644
-+--- a/tokenizing.h
-++++ b/tokenizing.h
-+@@ -1,10 +1,10 @@
-+-// Tokenization header file
-+-#ifndef _TOKENIZING_H_
-+-#define _TOKENIZING_H_
-+-
-+-#include <stdio.h>
-+-#include <string.h>
-+-
-+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
-+-
-++// Tokenization header file
-++#ifndef _TOKENIZING_H_
-++#define _TOKENIZING_H_
-++
-++#include <stdio.h>
-++#include <string.h>
-++
-++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
-++
-+ #endif
-+\ No newline at end of file
-+
-+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
-+Author: rsaguros <rsaguros1@myseneca.ca>
-+Date:   Mon Aug 8 15:47:34 2022 -0400
-+
-+    Version 2
-+    
-+    Version 2
-+
-+diff --git a/converting.c b/converting.c
-+index c5a0775..df23173 100644
-+--- a/converting.c
-++++ b/converting.c
-+@@ -1,6 +1,6 @@
-+ // CONVERTING MODULE SOURCE
-+ /*
-+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
-++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
-+ converting.c : CONVERTING
-+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
-+ */
-+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
-+ // strings and convert a string to an integer value.
-+ #include "converting.h"
-+ 
-+-// V1
-+ void converting(void) {
-++	// V1
-+ 	// Display beginning message
-+ 	printf("*** Start of Converting Strings to int Demo ***\n");
-+ 
-+@@ -38,6 +38,30 @@ void converting(void) {
-+ 		}
-+ 	} while (strcmp(intString, "q") != 0);
-+ 
-+-	// Display ending message and exit module.
-++	// Display ending message for int demo
-+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
-++
-++	// V2
-++	printf("*** Start of Converting Strings to double Demo ***\n");
-++
-++	char	doubleString[BUFFER_SIZE];
-++	double	doubleNumber;
-++
-++	do {
-++		// Prompt user for entry, replacing the new line read by 
-++		// fgets with a null terminator
-++		printf("Type an double numeric string (q - to quit):\n");
-++		fgets(doubleString, BUFFER_SIZE, stdin);
-++		doubleString[strlen(doubleString) - 1] = '\0';
-++
-++		// Check user input, exit if 'q' was entered.  
-++		if ((strcmp(doubleString, "q") != 0)) {
-++
-++			// Convert user entry from numeric string to a double, then display it
-++			doubleNumber = atof(doubleString);
-++			printf("Converted number is %f\n", doubleNumber);
-++		}
-++	} while (strcmp(doubleString, "q") != 0);
-++
-++	printf("*** End of Converting Strings to double Demo ***\n\n");
-+ }
-+
-+commit e25ade313038da86c407f85f5c00586ba6b37a1b
-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-+Date:   Mon Aug 8 15:05:20 2022 -0400
-+
-+    Update README.md
-+
-+diff --git a/README.md b/README.md
-+index 28e7c31..f1ff45d 100644
-+--- a/README.md
-++++ b/README.md
-+@@ -1,5 +1,8 @@
-+ # CPR101_Project
-+ CPR101 Final Project
-++
-+ Section: NAA
-++
-+ Group 1
-++
-+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
-+
-+commit a3e1e5ae394af27b186e61562b7167819c90ea13
-+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
-+Date:   Mon Aug 8 15:01:47 2022 -0400
-+
-+    Create README.md
-+
-+diff --git a/README.md b/README.md
-+new file mode 100644
-+index 0000000..28e7c31
-+--- /dev/null
-++++ b/README.md
-+@@ -0,0 +1,5 @@
-++# CPR101_Project
-++CPR101 Final Project
-++Section: NAA
-++Group 1
-++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
-+
-+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
-+Author: rsaguros <rsaguros1@myseneca.ca>
-+Date:   Mon Aug 8 13:58:05 2022 -0400
-+
-+    Update converting.c
-+    
-+    Version 2
-+
-+diff --git a/converting.c b/converting.c
-+index c5a0775..df23173 100644
-+--- a/converting.c
-++++ b/converting.c
-+@@ -1,6 +1,6 @@
-+ // CONVERTING MODULE SOURCE
-+ /*
-+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
-++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
-+ converting.c : CONVERTING
-+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
-+ */
-+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
-+ // strings and convert a string to an integer value.
-+ #include "converting.h"
-+ 
-+-// V1
-+ void converting(void) {
-++	// V1
-+ 	// Display beginning message
-+ 	printf("*** Start of Converting Strings to int Demo ***\n");
-+ 
-+@@ -38,6 +38,30 @@ void converting(void) {
-+ 		}
-+ 	} while (strcmp(intString, "q") != 0);
-+ 
-+-	// Display ending message and exit module.
-++	// Display ending message for int demo
-+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
-++
-++	// V2
-++	printf("*** Start of Converting Strings to double Demo ***\n");
-++
-++	char	doubleString[BUFFER_SIZE];
-++	double	doubleNumber;
-++
-++	do {
-++		// Prompt user for entry, replacing the new line read by 
-++		// fgets with a null terminator
-++		printf("Type an double numeric string (q - to quit):\n");
-++		fgets(doubleString, BUFFER_SIZE, stdin);
-++		doubleString[strlen(doubleString) - 1] = '\0';
-++
-++		// Check user input, exit if 'q' was entered.  
-++		if ((strcmp(doubleString, "q") != 0)) {
-++
-++			// Convert user entry from numeric string to a double, then display it
-++			doubleNumber = atof(doubleString);
-++			printf("Converted number is %f\n", doubleNumber);
-++		}
-++	} while (strcmp(doubleString, "q") != 0);
-++
-++	printf("*** End of Converting Strings to double Demo ***\n\n");
-+ }
-+
-+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
-+Author: krpm <mungcalrina@gmail.com>
-+Date:   Mon Aug 8 13:43:58 2022 -0400
-+
-+    Update manipulating.c
-+
-+diff --git a/manipulating.c b/manipulating.c
-+index 953e516..9193243 100644
-+--- a/manipulating.c
-++++ b/manipulating.c
-+@@ -41,7 +41,7 @@ void manipulating(void) {
-+ 	do {
-+ 		printf("Type the 1st string to compare (q - to quit):\n");
-+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
-+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
-++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
-+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
-+ 			printf("Type the 2nd string to compare:\n");
-+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
-+
-+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
-+Author: krpm <mungcalrina@gmail.com>
-+Date:   Mon Aug 8 12:51:35 2022 -0400
-+
-+    Version 2
-+    
-+    Updated main for version 2
-+
-+diff --git a/main.c b/main.c
-+index 755b397..70aeeb7 100644
-+--- a/main.c
-++++ b/main.c
-+@@ -1,6 +1,6 @@
-+ // MAIN 
-+ /*
-+-Author: BB01, 03/08/2022, CPR101, Final Project V1
-++Author: BB01, 03/08/2022, CPR101, Final Project
-+ main.c : MAIN
-+ Purpose: Main Function used to prompt user for which various options.
-+ */
-+
-+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
-+Author: kiararina <kiararina.pelenio@upou.edu.ph>
-+Date:   Mon Aug 8 09:38:48 2022 -0500
-+
-+    Version 2
-+    
-+    Added version 2 codes
-+
-+diff --git a/manipulating.c b/manipulating.c
-+index 9bde2d2..953e516 100644
-+--- a/manipulating.c
-++++ b/manipulating.c
-+@@ -1,5 +1,5 @@
-+ /*
-+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
-++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
-+ manipulating.c : Manipulating
-+ Purpose: This program manipulates input strings
-+ */
-+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
-+ #include "manipulating.h" 
-+ /* Contains function prototypes and library declarations */
-+ 
-++// V1
-+ void manipulating(void) {
-+ /* Purpose: This function concatenates 2 input strings */
-+ 
-+@@ -19,16 +20,40 @@ void manipulating(void) {
-+ 
-+ 	do {
-+ 		printf("Type the 1st string (q - to quit):\n");
-+-		fgets(string1, BUFFER_SIZE, stdin);
-+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
-++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
-++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
-+ 
-+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
-+ 			printf("Type the 2nd string:\n");
-+-			fgets(string2, BUFFER_SIZE, stdin);
-++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
-+ 			strcat(string1, string2);
-+ 			printf("Concatenated string is \'%s\'\n", string1);
-+ 		}
-+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
-+ 
-+ 	printf("*** End of Concatenating Strings Demo ***\n");
-++
-++//V2
-++	printf("*** Start of Comparing Strings Demo ***\n");
-++	char compare1[BUFFER_SIZE];
-++	char compare2[BUFFER_SIZE];
-++	int result;
-++	do {
-++		printf("Type the 1st string to compare (q - to quit):\n");
-++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
-++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
-++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
-++			printf("Type the 2nd string to compare:\n");
-++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
-++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
-++			result = strcmp(compare1, compare2);	// Compare the 2 strings
-++			if (result < 0)
-++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
-++			else if (result == 0)
-++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
-++			else
-++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
-++		}
-++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
-++	printf("*** End of Comparing Strings Demo ***\n\n");
-+ }
-+\ No newline at end of file
-+
-+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
-+Author: kiararina <kiararina.pelenio@upou.edu.ph>
-+Date:   Thu Aug 4 15:34:34 2022 -0500
-+
-+    Update manipulating.c
-+
-+diff --git a/manipulating.c b/manipulating.c
-+index 748c895..9bde2d2 100644
-+--- a/manipulating.c
-++++ b/manipulating.c
-+@@ -1,5 +1,5 @@
-+ /*
-+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
-++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
-+ manipulating.c : Manipulating
-+ Purpose: This program manipulates input strings
-+ */
-+
-+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
-+Author: krpm <mungcalrina@gmail.com>
-+Date:   Thu Aug 4 16:30:00 2022 -0400
-+
-+    Version 1
-+
-+diff --git a/Programming Comments.docx b/Programming Comments.docx
-+new file mode 100644
-+index 0000000..07d1cd7
-+--- /dev/null
-++++ b/Programming Comments.docx	
-+@@ -0,0 +1,110 @@
-++                        Commenting Program Source Code
-++--------------------------------------------------------------------------------
-++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
-++--------------------------------------------------------------------------------
-++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
-++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
-++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
-++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
-++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
-++You know you have good comments if you delete all the code and what's left still makes sense as a program.
-++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
-++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
-++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
-++Comments are for programmers who will maintain the code in the future. 
-++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
-++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
-++--------------------------------------------------------------------------------
-++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
-++--------------------------------------------------------------------------------
-++
-++Organisation of Comments
-++Program comments 
-++ -  appear at the beginning of a source file.
-++/* 
-++Author: Name, email, ID, Date written, Course, Project
-++[executable filename] : [title of program]
-++Purpose: [what this program does, what problem does it solve?]
-++*/
-++
-++Function comments
-++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
-++/*
-++Purpose: [what this function does, what problem does it solve?]
-++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
-++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
-++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
-++*/
-++
-++Inline code comments
-++Your comment must say something different than explaining the code itself. 
-++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
-++Ideally, variable names should be self-explanatory. When they are not, comments are required.
-++c = a + b;  // c stores total of assignment and test marks respectively.
-++
-++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
-++cryptic = C + code; 		// explain this line's purpose in the program
-++crypticly = C + moreCode;	// explain this line's purpose in the program
-++
-++Longer code comments
-++Sometimes comments need more space than would fit inline. 
-++cryptic = C + code;
-++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
-++moreCrypticly = C + moreCode;	
-++
-++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
-++// this comment explains the purpose of the next line of code  
-++cryptic = C + code;
-++ 		
-++// this comment explains the purpose of the next line of code  
-++moreCrypticly = C + moreCode;	
-++		
-++
-++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
-++
-++Structures
-++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
-++// [what the structure accomplishes]
-++e.g. 
-++// compute factorial	
-++// prompt user until value within range 1  -  100 is input
-++Code Samples
-++printf("Type a few words separated by space(q - to quit):\n");
-++gets(words);
-++while (strcmp(words, "q") != 0) 
-++{
-++    word = strtok(words, " ");
-++    w_counter = 1;
-++    while (word) 
-++    {
-++        printf("Word #%d is \'%s\'\n", w_counter++, word);
-++        word = strtok(NULL, " ");
-++    }
-++    printf("Type a few words separated by space(q - to quit):\n");
-++    gets(words);
-++}
-++
-++ the first while continues until the 'words' variable is equal to "q". What is it for?
-++ there is another while {structure} ... what does it do?
-++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
-++ // keep looping until pointer is NULL
-++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
-++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
-++ This technique is even more important at the end of a series nested structures, e.g.
-++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
-++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
-++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
-++
-++
-++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
-++
-++while (TRUE) // a comment explains why there is no exit condition here
-++{
-++ 	. . .
-++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
-++   // --------- ********   make it visually obvious that this causes another iteration of the structure
-++. . .
-++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
-++   // --------- *****      make it visually obvious that this is an exit from the structure
-++. . .
-++}
-+diff --git a/converting.c b/converting.c
-+new file mode 100644
-+index 0000000..c5a0775
-+--- /dev/null
-++++ b/converting.c
-+@@ -0,0 +1,43 @@
-++// CONVERTING MODULE SOURCE
-++/*
-++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
-++converting.c : CONVERTING
-++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
-++*/
-++
-++#define	_CRT_SECURE_NO_WARNINGS
-++#define BUFFER_SIZE 80
-++
-++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
-++// strings and convert a string to an integer value.
-++#include "converting.h"
-++
-++// V1
-++void converting(void) {
-++	// Display beginning message
-++	printf("*** Start of Converting Strings to int Demo ***\n");
-++
-++	// Declare variables
-++	char	intString[BUFFER_SIZE];
-++	int		intNumber;
-++
-++	do {
-++		// Prompt user for entry
-++		printf("Type an int numeric string (q - to quit):\n");
-++		fgets(intString, BUFFER_SIZE, stdin);
-++		intString[strlen(intString) - 1] = '\0';
-++
-++		// Check user input, exit if 'q' was entered.
-++		if (strcmp(intString, "q") != 0) {
-++
-++			// Convert user entry from string to integer value.
-++			intNumber = atoi(intString);
-++
-++			// Display converted number.
-++			printf("Converted number is %d\n", intNumber);
-++		}
-++	} while (strcmp(intString, "q") != 0);
-++
-++	// Display ending message and exit module.
-++	printf("*** End of Converting Strings to int Demo ***\n\n");
-++}
-+diff --git a/converting.h b/converting.h
-+new file mode 100644
-+index 0000000..03c62a3
-+--- /dev/null
-++++ b/converting.h
-+@@ -0,0 +1,18 @@
-++// CONVERTING MODULE HEADER
-++#ifndef _CONVERTING_H_
-++#define _CONVERTING_H_
-++
-++// Libraries
-++#include <stdio.h>
-++#include <string.h>
-++#include <stdlib.h>
-++
-++
-++/////////////////////////
-++// Prototype  Function //
-++/////////////////////////
-++
-++// Function used to apply conversions
-++void converting(void);
-++
-++#endif
-+diff --git a/fundamentals.c b/fundamentals.c
-+new file mode 100644
-+index 0000000..95c9f23
-+--- /dev/null
-++++ b/fundamentals.c
-+@@ -0,0 +1,43 @@
-++/*
-++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
-++fundamentals.c : indexing
-++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
-++*/
-++
-++
-++// FUNDAMENTALS MODULE SOURCE 
-++#define _CRT_SECURE_NO_WARNINGS 
-++#define BUFFER_SIZE 80
-++#define NUM_INPUT_SIZE 10 
-++#include "fundamentals.h"
-++
-++
-++void fundamentals(void) {
-++
-++// V1
-++    printf("*** start of Indexing Strings Demo ***\n"); 
-++    char buffer1[BUFFER_SIZE]; 
-++    char numInput[NUM_INPUT_SIZE]; 
-++    size_t position; 
-++    do {
-++        printf("Type not empty string (q - to quit): \n"); 
-++        fgets (buffer1, BUFFER_SIZE, stdin); 
-++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
-++
-++        // checks if entered string is not equals to 'q'.
-++        if (strcmp (buffer1, "q") != 0) { 
-++            printf("Type the character position within the string: \n"); 
-++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
-++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
-++            position = atoi (numInput); // Converts entered string to integer.
-++
-++            // Checks if converted integer is larger then string length and assigns max position if true.
-++            if (position >= strlen (buffer1)) { 
-++                position = strlen (buffer1) - 1; 
-++                printf("Too big... Position reduced to max. availbale\n");
-++            }
-++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
-++        }
-++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
-++    printf("*** End of Indexing Strings Demo ***\n\n");
-++}
-+\ No newline at end of file
-+diff --git a/fundamentals.h b/fundamentals.h
-+new file mode 100644
-+index 0000000..0433660
-+--- /dev/null
-++++ b/fundamentals.h
-+@@ -0,0 +1,12 @@
-++// FUNDAMENTALS MODULE HEADER 
-++#ifndef _FUNDAMENTALS_H_
-++#define _FUNDAMENTALS_H_
-++
-++#include <stdio.h> 
-++#include <stdlib.h> 
-++#include <string.h>
-++
-++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
-++void fundamentals(void);
-++
-++#endif
-+\ No newline at end of file
-+diff --git a/main.c b/main.c
-+new file mode 100644
-+index 0000000..755b397
-+--- /dev/null
-++++ b/main.c
-+@@ -0,0 +1,58 @@
-++// MAIN 
-++/*
-++Author: BB01, 03/08/2022, CPR101, Final Project V1
-++main.c : MAIN
-++Purpose: Main Function used to prompt user for which various options.
-++*/
-++
-++// Include all necessary modules
-++#define _CRT_SECURE_NO_WARNINGS
-++#include "fundamentals.h"
-++#include "manipulating.h"
-++#include "converting.h"
-++#include "tokenizing.h"
-++
-++int main(void) {
-++	// Declare variables
-++	char buff[10];
-++
-++	// Open menu for user
-++	do {
-++		// Display menu options
-++		printf("1 - Fundamentals\n");
-++		printf("2 - Manipulation\n");
-++		printf("3 - Converting\n");
-++		printf("4 - Tokenizing\n");
-++		printf("0 - Exit\n");
-++		
-++		// Prompt user for input
-++		printf("Which module to run? \n");
-++		fgets(buff, 10, stdin);
-++
-++		// Analyze user entry and match selection
-++		switch (buff[0])
-++		{
-++		case '1': 
-++			// Call for fundamentals module
-++			fundamentals();
-++			break;
-++
-++		case '2': 
-++			// Call for manipulating module
-++			manipulating();
-++			break;
-++
-++		case '3': 
-++			// Call for converting module
-++			converting();
-++			break;
-++
-++		case '4': 
-++			// Call for tokenizing module
-++			tokenizing();
-++			break;
-++		}
-++	} while (buff[0] != '0');
-++	
-++	return 0;
-++}
-+\ No newline at end of file
-+diff --git a/manipulating.c b/manipulating.c
-+new file mode 100644
-+index 0000000..748c895
-+--- /dev/null
-++++ b/manipulating.c
-+@@ -0,0 +1,34 @@
-++/*
-++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
-++manipulating.c : Manipulating
-++Purpose: This program manipulates input strings
-++*/
-++
-++#define _CRT_SECURE_NO_WARNINGS
-++#define BUFFER_SIZE 80
-++
-++#include "manipulating.h" 
-++/* Contains function prototypes and library declarations */
-++
-++void manipulating(void) {
-++/* Purpose: This function concatenates 2 input strings */
-++
-++	printf("*** Start of Concatenating Strings Demo ***\n");
-++	char string1[BUFFER_SIZE];
-++	char string2[BUFFER_SIZE];
-++
-++	do {
-++		printf("Type the 1st string (q - to quit):\n");
-++		fgets(string1, BUFFER_SIZE, stdin);
-++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
-++
-++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
-++			printf("Type the 2nd string:\n");
-++			fgets(string2, BUFFER_SIZE, stdin);
-++			strcat(string1, string2);
-++			printf("Concatenated string is \'%s\'\n", string1);
-++		}
-++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
-++
-++	printf("*** End of Concatenating Strings Demo ***\n");
-++}
-+\ No newline at end of file
-+diff --git a/manipulating.h b/manipulating.h
-+new file mode 100644
-+index 0000000..8a8f926
-+--- /dev/null
-++++ b/manipulating.h
-+@@ -0,0 +1,11 @@
-++//MANIPULATING MODULE HEADER
-++#ifndef _MANIPULATING_H_
-++#define _MANIPULATING_H_
-++
-++#include <stdio.h>		// For input/output and printing
-++#include <string.h>		// For string manipulation functions
-++
-++void manipulating(void);
-++/* Purpose: This function concatenates 2 input strings */
-++
-++#endif
-+diff --git a/tokenizing.c b/tokenizing.c
-+new file mode 100644
-+index 0000000..65d1c20
-+--- /dev/null
-++++ b/tokenizing.c
-+@@ -0,0 +1,42 @@
-++/*
-++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-++[tokenizing.c] : [tokenizing]
-++Purpose: [This function takes a user inputted string and tokenizes it]
-++*/
-++
-++
-++// TOKENIZING MODULE SOURCE
-++#define _CRT_SECURE_NO_WARNINGS
-++#define BUFFER_SIZE 300
-++#include "tokenizing.h"
-++
-++// V1
-++void tokenizing(void) {
-++
-++    printf("*** Start of Tokenizing Words Demo ***\n");
-++    char words[BUFFER_SIZE];
-++    char* nextWord = NULL;
-++    int wordsCounter;
-++    do {
-++        printf("Type a few words seperated by space (q - to quit):\n");
-++
-++        fgets(words, BUFFER_SIZE, stdin); 
-++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-++
-++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-++
-++        
-++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-++            while (nextWord) {
-++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-++            }
-++        }
-++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-++
-++    printf("*** End of Tokenizing Words Demo ***\n\n");
-++}
-++
-++
-+diff --git a/tokenizing.h b/tokenizing.h
-+new file mode 100644
-+index 0000000..c00f3cb
-+--- /dev/null
-++++ b/tokenizing.h
-+@@ -0,0 +1,10 @@
-++// Tokenization header file
-++#ifndef _TOKENIZING_H_
-++#define _TOKENIZING_H_
-++
-++#include <stdio.h>
-++#include <string.h>
-++
-++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
-++
-++#endif
-+\ No newline at end of file
-+
-+commit f914d3afae4107c77728b3df4d39502c962ba74b
-+Author: krpm <mungcalrina@gmail.com>
-+Date:   Thu Aug 4 15:48:50 2022 -0400
-+
-+    Initial commit
-+
-+diff --git a/.gitattributes b/.gitattributes
-+new file mode 100644
-+index 0000000..dfe0770
-+--- /dev/null
-++++ b/.gitattributes
-+@@ -0,0 +1,2 @@
-++# Auto detect text files and perform LF normalization
-++* text=auto
-
-commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
-Author: krpm <mungcalrina@gmail.com>
-Date:   Mon Aug 8 13:43:58 2022 -0400
-
-    Update manipulating.c
-
-diff --git a/manipulating.c b/manipulating.c
-index 953e516..9193243 100644
---- a/manipulating.c
-+++ b/manipulating.c
-@@ -41,7 +41,7 @@ void manipulating(void) {
- 	do {
- 		printf("Type the 1st string to compare (q - to quit):\n");
- 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
--		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
-+		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
- 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
- 			printf("Type the 2nd string to compare:\n");
- 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
-
-commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
-Author: kiararina <kiararina.pelenio@upou.edu.ph>
-Date:   Mon Aug 8 09:38:48 2022 -0500
-
-    Version 2
-    
-    Added version 2 codes
-
-diff --git a/manipulating.c b/manipulating.c
-index 9bde2d2..953e516 100644
---- a/manipulating.c
-+++ b/manipulating.c
-@@ -1,5 +1,5 @@
- /*
--Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
-+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
- manipulating.c : Manipulating
- Purpose: This program manipulates input strings
- */
-@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
- #include "manipulating.h" 
- /* Contains function prototypes and library declarations */
- 
-+// V1
- void manipulating(void) {
- /* Purpose: This function concatenates 2 input strings */
- 
-@@ -19,16 +20,40 @@ void manipulating(void) {
- 
- 	do {
- 		printf("Type the 1st string (q - to quit):\n");
--		fgets(string1, BUFFER_SIZE, stdin);
--		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
-+		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
-+		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
- 
- 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
- 			printf("Type the 2nd string:\n");
--			fgets(string2, BUFFER_SIZE, stdin);
-+			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
- 			strcat(string1, string2);
- 			printf("Concatenated string is \'%s\'\n", string1);
- 		}
- 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
- 
- 	printf("*** End of Concatenating Strings Demo ***\n");
-+
-+//V2
-+	printf("*** Start of Comparing Strings Demo ***\n");
-+	char compare1[BUFFER_SIZE];
-+	char compare2[BUFFER_SIZE];
-+	int result;
-+	do {
-+		printf("Type the 1st string to compare (q - to quit):\n");
-+		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
-+		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
-+		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
-+			printf("Type the 2nd string to compare:\n");
-+			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
-+			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
-+			result = strcmp(compare1, compare2);	// Compare the 2 strings
-+			if (result < 0)
-+				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
-+			else if (result == 0)
-+				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
-+			else
-+				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
-+		}
-+	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
-+	printf("*** End of Comparing Strings Demo ***\n\n");
- }
-\ No newline at end of file
-
-commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
-Author: kiararina <kiararina.pelenio@upou.edu.ph>
-Date:   Thu Aug 4 15:34:34 2022 -0500
-
-    Update manipulating.c
-
-diff --git a/manipulating.c b/manipulating.c
-index 748c895..9bde2d2 100644
---- a/manipulating.c
-+++ b/manipulating.c
-@@ -1,5 +1,5 @@
- /*
--Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
-+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
- manipulating.c : Manipulating
- Purpose: This program manipulates input strings
- */
-
-commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
-Author: krpm <mungcalrina@gmail.com>
-Date:   Thu Aug 4 16:30:00 2022 -0400
-
-    Version 1
-
-diff --git a/manipulating.c b/manipulating.c
-new file mode 100644
-index 0000000..748c895
---- /dev/null
-+++ b/manipulating.c
-@@ -0,0 +1,34 @@
-+/*
-+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
-+manipulating.c : Manipulating
-+Purpose: This program manipulates input strings
-+*/
-+
-+#define _CRT_SECURE_NO_WARNINGS
-+#define BUFFER_SIZE 80
-+
-+#include "manipulating.h" 
-+/* Contains function prototypes and library declarations */
-+
-+void manipulating(void) {
-+/* Purpose: This function concatenates 2 input strings */
-+
-+	printf("*** Start of Concatenating Strings Demo ***\n");
-+	char string1[BUFFER_SIZE];
-+	char string2[BUFFER_SIZE];
-+
-+	do {
-+		printf("Type the 1st string (q - to quit):\n");
-+		fgets(string1, BUFFER_SIZE, stdin);
-+		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
-+
-+		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
-+			printf("Type the 2nd string:\n");
-+			fgets(string2, BUFFER_SIZE, stdin);
-+			strcat(string1, string2);
-+			printf("Concatenated string is \'%s\'\n", string1);
-+		}
-+	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
-+
-+	printf("*** End of Concatenating Strings Demo ***\n");
-+}
-\ No newline at end of file
-diff --git a/manipulating.h b/manipulating.h
-new file mode 100644
-index 0000000..8a8f926
---- /dev/null
-+++ b/manipulating.h
-@@ -0,0 +1,11 @@
-+//MANIPULATING MODULE HEADER
-+#ifndef _MANIPULATING_H_
-+#define _MANIPULATING_H_
-+
-+#include <stdio.h>		// For input/output and printing
-+#include <string.h>		// For string manipulation functions
-+
-+void manipulating(void);
-+/* Purpose: This function concatenates 2 input strings */
-+
-+#endif

commit e8242740404c7e5e308d7dabecc4d5c41b7e695b
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Fri Aug 12 14:14:56 2022 -0400

    Updating converting.c to Version 3
    
    Version 3 adds functionality to convert a long numeric string to a long value.

diff --git a/converting.c b/converting.c
index df23173..acb6e07 100644
--- a/converting.c
+++ b/converting.c
@@ -1,15 +1,15 @@
 // CONVERTING MODULE SOURCE
 /*
-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 12/08/2022, CPR101, Final Project V3
 converting.c : CONVERTING
-Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+Purpose: This program converts numeric strings inputted by the user to an integer value, a double value, and a long value.
 */
 
 #define	_CRT_SECURE_NO_WARNINGS
 #define BUFFER_SIZE 80
 
 // Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
-// strings and convert a string to an integer value.
+// strings and convert a string to an integer, a double, and a long value.
 #include "converting.h"
 
 void converting(void) {
@@ -22,10 +22,10 @@ void converting(void) {
 	int		intNumber;
 
 	do {
-		// Prompt user for entry
+		// Prompt user for a integer numeric string
 		printf("Type an int numeric string (q - to quit):\n");
 		fgets(intString, BUFFER_SIZE, stdin);
-		intString[strlen(intString) - 1] = '\0';
+		intString[strlen(intString) - 1] = '\0';	// Replace new line with null terminator
 
 		// Check user input, exit if 'q' was entered.
 		if (strcmp(intString, "q") != 0) {
@@ -48,7 +48,7 @@ void converting(void) {
 	double	doubleNumber;
 
 	do {
-		// Prompt user for entry, replacing the new line read by 
+		// Prompt user for a double numeric string, replacing the new line read by 
 		// fgets with a null terminator
 		printf("Type an double numeric string (q - to quit):\n");
 		fgets(doubleString, BUFFER_SIZE, stdin);
@@ -63,5 +63,31 @@ void converting(void) {
 		}
 	} while (strcmp(doubleString, "q") != 0);
 
+	// Display ending message for double demo
 	printf("*** End of Converting Strings to double Demo ***\n\n");
+
+	// V3
+	printf("*** Start of Converting Strings to long Demo ***\n");
+	
+	char	longString[BUFFER_SIZE];
+	long	longNumber;
+
+	do {
+		// Prompt user for a long numeric string, replacing the new line read by
+		// fgets with a null terminator.
+		printf("Type a long numeric string (q - to quit):\n");
+		fgets(longString, BUFFER_SIZE, stdin);
+		longString[strlen(longString) - 1] = '\0';
+
+		// Check user input, exit if 'q' was entered.
+		if ((strcmp(longString, "q") != 0)) {
+
+			// Convert user entry from numeric string to a long, then display it
+			longNumber = atol(longString);
+			printf("Converted number is %ld\n", longNumber);
+		}
+	} while (strcmp(longString, "q") != 0);
+
+	// Display ending message for long demo
+	printf("*** End of Converting Strings to long Demo ***\n\n");
 }

commit ade615136b67a44a1c986034b1ce8c45b1f10a01
Merge: faa99c8 443688d
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Fri Aug 12 12:04:26 2022 -0400

    Merge pull request #2 from kiararina/manipulating
    
    Update manipulating.c for version 3.

commit 443688d725f580de26b30951bc73c5f4420cbd78
Author: krpm <25734153+kiararina@users.noreply.github.com>
Date:   Fri Aug 12 10:23:30 2022 -0400

    Update to version 3

diff --git a/manipulating_git_log.txt b/manipulating_git_log.txt
new file mode 100644
index 0000000..05aa537
--- /dev/null
+++ b/manipulating_git_log.txt
@@ -0,0 +1,1587 @@
+commit e14f5c429efccb7dc63749da2a425659ad905631
+Author: krpm <25734153+kiararina@users.noreply.github.com>
+Date:   Fri Aug 12 08:37:11 2022 -0400
+
+    Update manipulating.c for version 3.
+    
+    Added a section for checking the occurrence of 2nd string in 1st string.
+
+diff --git a/manipulating.c b/manipulating.c
+index 9193243..925e182 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
+ 
+ // V1
+ void manipulating(void) {
+-/* Purpose: This function concatenates 2 input strings */
++/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
+ 
+ 	printf("*** Start of Concatenating Strings Demo ***\n");
+ 	char string1[BUFFER_SIZE];
+@@ -56,4 +56,27 @@ void manipulating(void) {
+ 		}
+ 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+ 	printf("*** End of Comparing Strings Demo ***\n\n");
++
++
++//V3
++	printf("*** Start of Searching Strings Demo ***\n");
++	char haystack[BUFFER_SIZE];
++	char needle[BUFFER_SIZE];
++	char* occurence = NULL;
++	do {
++		printf("Type the string (q - to quit):\n");
++		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
++		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
++		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
++			printf("Type the substring:\n");
++			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
++			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
++			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
++			if (occurence)							// If found, return the position where 2nd string occurs
++				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
++			else						
++				printf("Not found\n");				
++		}
++	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Searching Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 23:04:40 2022 -0400
+
+    Adding git logs
+    
+    Version 2 Git Logs
+    $ git --no-pager log -p > "module-git-log.txt"
+
+diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
+new file mode 100644
+index 0000000..7bb5209
+--- /dev/null
++++ b/manipulating-git-log.txt
+@@ -0,0 +1,1345 @@
++commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
++Merge: 6361388 c3a8316
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:49:17 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit 63613886b8f1ecccb62538d6d4b7905425a16358
++Merge: 0626d2e c0f7dc8
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Tue Aug 9 22:47:37 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c3a831696d320ac9100ed65017dacd96abb6c7c0
++Merge: 9d98950 c0f7dc8
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 22:46:28 2022 -0400
++
++    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
++
++commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
++Merge: fd97b97 a2a1bf4
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:47 2022 -0400
++
++    Merge pull request #1 from kiararina/converting
++    
++    Recovering lost commits up to converting.c
++
++commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
++Merge: cee497d fd97b97
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Tue Aug 9 22:44:00 2022 -0400
++
++    Merge branch 'main' into converting
++
++commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:23:44 2022 -0400
++
++    tokenizing.c v2 corrected
++    
++    Corrected a previous error, now both v1 and v2 are within the same function name
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 6332b6d..ae26066 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++ 
++ 
+++void tokenizing(void) {
++ 
++-/*
++-// V1
++-//void tokenizing(void) {
++-
+++    // V1
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++     char* nextWord = NULL;
++@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++     do {
++         printf("Type a few words seperated by space (q - to quit):\n");
++ 
++-        fgets(words, BUFFER_SIZE, stdin); 
+++        fgets(words, BUFFER_SIZE, stdin);
++         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++ 
++         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ 
++     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-       }
+++        }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++ 
++ 
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
+++    // V2
+++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char phrases[BUFFER_SIZE];
++     char* nextPhrase = NULL;
++
++commit 23f162166b815502c16ac1456d8f9be87b799f26
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:09:02 2022 -0400
++
++    Update tokenizing.c to V2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index edc3184..6332b6d 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++ [tokenizing.c] : [tokenizing]
++ Purpose: [This function takes a user inputted string and tokenizes it]
++ */
++@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
++ #include "tokenizing.h"
++ 
++ 
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++ 
++ 
+++/*
++ // V1
++-void tokenizing(void) {
+++//void tokenizing(void) {
++ 
++     printf("*** Start of Tokenizing Words Demo ***\n");
++     char words[BUFFER_SIZE];
++@@ -34,16 +31,46 @@ void tokenizing(void) {
++             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++ 
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++             while (nextWord) {
++                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++             }
++-        }
+++       }
++     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++ 
++     printf("*** End of Tokenizing Words Demo ***\n\n");
++ }
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
++ 
++ 
++
++commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 19:06:55 2022 -0400
++
++    V1
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 417d34a..edc3184 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,80 +1,49 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-
++-int main(void) {
++-    tokenizing();
++-    return 0;
++-}
++-
++-
++-/*
++-// V1
++-//void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-       }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-*/
++-
++-
++-// V2
++-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char phrases[BUFFER_SIZE];
++-    char* nextPhrase = NULL;
++-    int phrasesCounter;
++-    do {
++-        printf("Type a few words seperated by comma (q - to quit):\n");
++-
++-        fgets(phrases, BUFFER_SIZE, stdin); 
++-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++-            while (nextPhrase) {
++-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++-            }
++-        }
++-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++
++commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
++Author: CRYPTO43 <singharshjot07@gmail.com>
++Date:   Tue Aug 9 17:12:27 2022 -0400
++
++    first commit
++
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..cd7cd9f
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,63 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void main(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++
+++
+++
+++    // V2 
+++    printf("*** Start of Measuring Strings Demo ***\n"); 
+++    char buffer2[BUFFER_SIZE]; 
+++    do { 
+++        printf("Type a string (q - to quit):\n"); 
+++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp(buffer2, "q") != 0) 
+++            printf("The length of \'%s\' is %d characters\n", 
+++            buffer2, (int)strlen(buffer2)); 
+++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+++        
+++        printf("*** End of Measuring Strings Demo ***\n\n");
+++}
+++
+++ 
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..383cccc
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void main(void);
+++
+++#endif
++\ No newline at end of file
++
++commit 425a7ac33f432099cac3faa3a90bb69daf84067f
++Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
++Date:   Tue Aug 9 16:17:34 2022 -0400
++
++    Add files via upload
++    
++    Version 2
++
++diff --git a/tokenizing.c b/tokenizing.c
++index 65d1c20..417d34a 100644
++--- a/tokenizing.c
+++++ b/tokenizing.c
++@@ -1,42 +1,80 @@
++-/*
++-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++-[tokenizing.c] : [tokenizing]
++-Purpose: [This function takes a user inputted string and tokenizes it]
++-*/
++-
++-
++-// TOKENIZING MODULE SOURCE
++-#define _CRT_SECURE_NO_WARNINGS
++-#define BUFFER_SIZE 300
++-#include "tokenizing.h"
++-
++-// V1
++-void tokenizing(void) {
++-
++-    printf("*** Start of Tokenizing Words Demo ***\n");
++-    char words[BUFFER_SIZE];
++-    char* nextWord = NULL;
++-    int wordsCounter;
++-    do {
++-        printf("Type a few words seperated by space (q - to quit):\n");
++-
++-        fgets(words, BUFFER_SIZE, stdin); 
++-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++-
++-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++-
++-        
++-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++-            while (nextWord) {
++-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++-            }
++-        }
++-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++-
++-    printf("*** End of Tokenizing Words Demo ***\n\n");
++-}
++-
++-
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++
+++int main(void) {
+++    tokenizing();
+++    return 0;
+++}
+++
+++
+++/*
+++// V1
+++//void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++       }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++*/
+++
+++
+++// V2
+++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char phrases[BUFFER_SIZE];
+++    char* nextPhrase = NULL;
+++    int phrasesCounter;
+++    do {
+++        printf("Type a few words seperated by comma (q - to quit):\n");
+++
+++        fgets(phrases, BUFFER_SIZE, stdin); 
+++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+++            while (nextPhrase) {
+++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+++            }
+++        }
+++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++index c00f3cb..7899cc2 100644
++--- a/tokenizing.h
+++++ b/tokenizing.h
++@@ -1,10 +1,10 @@
++-// Tokenization header file
++-#ifndef _TOKENIZING_H_
++-#define _TOKENIZING_H_
++-
++-#include <stdio.h>
++-#include <string.h>
++-
++-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++-
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
++ #endif
++\ No newline at end of file
++
++commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 15:47:34 2022 -0400
++
++    Version 2
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit e25ade313038da86c407f85f5c00586ba6b37a1b
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:05:20 2022 -0400
++
++    Update README.md
++
++diff --git a/README.md b/README.md
++index 28e7c31..f1ff45d 100644
++--- a/README.md
+++++ b/README.md
++@@ -1,5 +1,8 @@
++ # CPR101_Project
++ CPR101 Final Project
+++
++ Section: NAA
+++
++ Group 1
+++
++ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit a3e1e5ae394af27b186e61562b7167819c90ea13
++Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
++Date:   Mon Aug 8 15:01:47 2022 -0400
++
++    Create README.md
++
++diff --git a/README.md b/README.md
++new file mode 100644
++index 0000000..28e7c31
++--- /dev/null
+++++ b/README.md
++@@ -0,0 +1,5 @@
+++# CPR101_Project
+++CPR101 Final Project
+++Section: NAA
+++Group 1
+++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
++
++commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
++Author: rsaguros <rsaguros1@myseneca.ca>
++Date:   Mon Aug 8 13:58:05 2022 -0400
++
++    Update converting.c
++    
++    Version 2
++
++diff --git a/converting.c b/converting.c
++index c5a0775..df23173 100644
++--- a/converting.c
+++++ b/converting.c
++@@ -1,6 +1,6 @@
++ // CONVERTING MODULE SOURCE
++ /*
++-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
++ converting.c : CONVERTING
++ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++ */
++@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
++ // strings and convert a string to an integer value.
++ #include "converting.h"
++ 
++-// V1
++ void converting(void) {
+++	// V1
++ 	// Display beginning message
++ 	printf("*** Start of Converting Strings to int Demo ***\n");
++ 
++@@ -38,6 +38,30 @@ void converting(void) {
++ 		}
++ 	} while (strcmp(intString, "q") != 0);
++ 
++-	// Display ending message and exit module.
+++	// Display ending message for int demo
++ 	printf("*** End of Converting Strings to int Demo ***\n\n");
+++
+++	// V2
+++	printf("*** Start of Converting Strings to double Demo ***\n");
+++
+++	char	doubleString[BUFFER_SIZE];
+++	double	doubleNumber;
+++
+++	do {
+++		// Prompt user for entry, replacing the new line read by 
+++		// fgets with a null terminator
+++		printf("Type an double numeric string (q - to quit):\n");
+++		fgets(doubleString, BUFFER_SIZE, stdin);
+++		doubleString[strlen(doubleString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.  
+++		if ((strcmp(doubleString, "q") != 0)) {
+++
+++			// Convert user entry from numeric string to a double, then display it
+++			doubleNumber = atof(doubleString);
+++			printf("Converted number is %f\n", doubleNumber);
+++		}
+++	} while (strcmp(doubleString, "q") != 0);
+++
+++	printf("*** End of Converting Strings to double Demo ***\n\n");
++ }
++
++commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 13:43:58 2022 -0400
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 953e516..9193243 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -41,7 +41,7 @@ void manipulating(void) {
++ 	do {
++ 		printf("Type the 1st string to compare (q - to quit):\n");
++ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++ 			printf("Type the 2nd string to compare:\n");
++ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++
++commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
++Author: krpm <mungcalrina@gmail.com>
++Date:   Mon Aug 8 12:51:35 2022 -0400
++
++    Version 2
++    
++    Updated main for version 2
++
++diff --git a/main.c b/main.c
++index 755b397..70aeeb7 100644
++--- a/main.c
+++++ b/main.c
++@@ -1,6 +1,6 @@
++ // MAIN 
++ /*
++-Author: BB01, 03/08/2022, CPR101, Final Project V1
+++Author: BB01, 03/08/2022, CPR101, Final Project
++ main.c : MAIN
++ Purpose: Main Function used to prompt user for which various options.
++ */
++
++commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Mon Aug 8 09:38:48 2022 -0500
++
++    Version 2
++    
++    Added version 2 codes
++
++diff --git a/manipulating.c b/manipulating.c
++index 9bde2d2..953e516 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
++ #include "manipulating.h" 
++ /* Contains function prototypes and library declarations */
++ 
+++// V1
++ void manipulating(void) {
++ /* Purpose: This function concatenates 2 input strings */
++ 
++@@ -19,16 +20,40 @@ void manipulating(void) {
++ 
++ 	do {
++ 		printf("Type the 1st string (q - to quit):\n");
++-		fgets(string1, BUFFER_SIZE, stdin);
++-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
++ 
++ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++ 			printf("Type the 2nd string:\n");
++-			fgets(string2, BUFFER_SIZE, stdin);
+++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++ 			strcat(string1, string2);
++ 			printf("Concatenated string is \'%s\'\n", string1);
++ 		}
++ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++ 
++ 	printf("*** End of Concatenating Strings Demo ***\n");
+++
+++//V2
+++	printf("*** Start of Comparing Strings Demo ***\n");
+++	char compare1[BUFFER_SIZE];
+++	char compare2[BUFFER_SIZE];
+++	int result;
+++	do {
+++		printf("Type the 1st string to compare (q - to quit):\n");
+++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+++			printf("Type the 2nd string to compare:\n");
+++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+++			result = strcmp(compare1, compare2);	// Compare the 2 strings
+++			if (result < 0)
+++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+++			else if (result == 0)
+++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+++			else
+++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+++		}
+++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+++	printf("*** End of Comparing Strings Demo ***\n\n");
++ }
++\ No newline at end of file
++
++commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
++Author: kiararina <kiararina.pelenio@upou.edu.ph>
++Date:   Thu Aug 4 15:34:34 2022 -0500
++
++    Update manipulating.c
++
++diff --git a/manipulating.c b/manipulating.c
++index 748c895..9bde2d2 100644
++--- a/manipulating.c
+++++ b/manipulating.c
++@@ -1,5 +1,5 @@
++ /*
++-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++ manipulating.c : Manipulating
++ Purpose: This program manipulates input strings
++ */
++
++commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 16:30:00 2022 -0400
++
++    Version 1
++
++diff --git a/Programming Comments.docx b/Programming Comments.docx
++new file mode 100644
++index 0000000..07d1cd7
++--- /dev/null
+++++ b/Programming Comments.docx	
++@@ -0,0 +1,110 @@
+++                        Commenting Program Source Code
+++--------------------------------------------------------------------------------
+++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+++--------------------------------------------------------------------------------
+++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+++You know you have good comments if you delete all the code and what's left still makes sense as a program.
+++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+++Comments are for programmers who will maintain the code in the future. 
+++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+++--------------------------------------------------------------------------------
+++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+++--------------------------------------------------------------------------------
+++
+++Organisation of Comments
+++Program comments 
+++ -  appear at the beginning of a source file.
+++/* 
+++Author: Name, email, ID, Date written, Course, Project
+++[executable filename] : [title of program]
+++Purpose: [what this program does, what problem does it solve?]
+++*/
+++
+++Function comments
+++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+++/*
+++Purpose: [what this function does, what problem does it solve?]
+++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+++*/
+++
+++Inline code comments
+++Your comment must say something different than explaining the code itself. 
+++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+++Ideally, variable names should be self-explanatory. When they are not, comments are required.
+++c = a + b;  // c stores total of assignment and test marks respectively.
+++
+++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+++cryptic = C + code; 		// explain this line's purpose in the program
+++crypticly = C + moreCode;	// explain this line's purpose in the program
+++
+++Longer code comments
+++Sometimes comments need more space than would fit inline. 
+++cryptic = C + code;
+++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+++moreCrypticly = C + moreCode;	
+++
+++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+++// this comment explains the purpose of the next line of code  
+++cryptic = C + code;
+++ 		
+++// this comment explains the purpose of the next line of code  
+++moreCrypticly = C + moreCode;	
+++		
+++
+++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+++
+++Structures
+++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+++// [what the structure accomplishes]
+++e.g. 
+++// compute factorial	
+++// prompt user until value within range 1  -  100 is input
+++Code Samples
+++printf("Type a few words separated by space(q - to quit):\n");
+++gets(words);
+++while (strcmp(words, "q") != 0) 
+++{
+++    word = strtok(words, " ");
+++    w_counter = 1;
+++    while (word) 
+++    {
+++        printf("Word #%d is \'%s\'\n", w_counter++, word);
+++        word = strtok(NULL, " ");
+++    }
+++    printf("Type a few words separated by space(q - to quit):\n");
+++    gets(words);
+++}
+++
+++ the first while continues until the 'words' variable is equal to "q". What is it for?
+++ there is another while {structure} ... what does it do?
+++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+++ // keep looping until pointer is NULL
+++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+++ This technique is even more important at the end of a series nested structures, e.g.
+++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+++
+++
+++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+++
+++while (TRUE) // a comment explains why there is no exit condition here
+++{
+++ 	. . .
+++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+++   // --------- ********   make it visually obvious that this causes another iteration of the structure
+++. . .
+++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+++   // --------- *****      make it visually obvious that this is an exit from the structure
+++. . .
+++}
++diff --git a/converting.c b/converting.c
++new file mode 100644
++index 0000000..c5a0775
++--- /dev/null
+++++ b/converting.c
++@@ -0,0 +1,43 @@
+++// CONVERTING MODULE SOURCE
+++/*
+++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+++converting.c : CONVERTING
+++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+++*/
+++
+++#define	_CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+++// strings and convert a string to an integer value.
+++#include "converting.h"
+++
+++// V1
+++void converting(void) {
+++	// Display beginning message
+++	printf("*** Start of Converting Strings to int Demo ***\n");
+++
+++	// Declare variables
+++	char	intString[BUFFER_SIZE];
+++	int		intNumber;
+++
+++	do {
+++		// Prompt user for entry
+++		printf("Type an int numeric string (q - to quit):\n");
+++		fgets(intString, BUFFER_SIZE, stdin);
+++		intString[strlen(intString) - 1] = '\0';
+++
+++		// Check user input, exit if 'q' was entered.
+++		if (strcmp(intString, "q") != 0) {
+++
+++			// Convert user entry from string to integer value.
+++			intNumber = atoi(intString);
+++
+++			// Display converted number.
+++			printf("Converted number is %d\n", intNumber);
+++		}
+++	} while (strcmp(intString, "q") != 0);
+++
+++	// Display ending message and exit module.
+++	printf("*** End of Converting Strings to int Demo ***\n\n");
+++}
++diff --git a/converting.h b/converting.h
++new file mode 100644
++index 0000000..03c62a3
++--- /dev/null
+++++ b/converting.h
++@@ -0,0 +1,18 @@
+++// CONVERTING MODULE HEADER
+++#ifndef _CONVERTING_H_
+++#define _CONVERTING_H_
+++
+++// Libraries
+++#include <stdio.h>
+++#include <string.h>
+++#include <stdlib.h>
+++
+++
+++/////////////////////////
+++// Prototype  Function //
+++/////////////////////////
+++
+++// Function used to apply conversions
+++void converting(void);
+++
+++#endif
++diff --git a/fundamentals.c b/fundamentals.c
++new file mode 100644
++index 0000000..95c9f23
++--- /dev/null
+++++ b/fundamentals.c
++@@ -0,0 +1,43 @@
+++/*
+++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+++fundamentals.c : indexing
+++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+++*/
+++
+++
+++// FUNDAMENTALS MODULE SOURCE 
+++#define _CRT_SECURE_NO_WARNINGS 
+++#define BUFFER_SIZE 80
+++#define NUM_INPUT_SIZE 10 
+++#include "fundamentals.h"
+++
+++
+++void fundamentals(void) {
+++
+++// V1
+++    printf("*** start of Indexing Strings Demo ***\n"); 
+++    char buffer1[BUFFER_SIZE]; 
+++    char numInput[NUM_INPUT_SIZE]; 
+++    size_t position; 
+++    do {
+++        printf("Type not empty string (q - to quit): \n"); 
+++        fgets (buffer1, BUFFER_SIZE, stdin); 
+++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+++
+++        // checks if entered string is not equals to 'q'.
+++        if (strcmp (buffer1, "q") != 0) { 
+++            printf("Type the character position within the string: \n"); 
+++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+++            position = atoi (numInput); // Converts entered string to integer.
+++
+++            // Checks if converted integer is larger then string length and assigns max position if true.
+++            if (position >= strlen (buffer1)) { 
+++                position = strlen (buffer1) - 1; 
+++                printf("Too big... Position reduced to max. availbale\n");
+++            }
+++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+++        }
+++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+++    printf("*** End of Indexing Strings Demo ***\n\n");
+++}
++\ No newline at end of file
++diff --git a/fundamentals.h b/fundamentals.h
++new file mode 100644
++index 0000000..0433660
++--- /dev/null
+++++ b/fundamentals.h
++@@ -0,0 +1,12 @@
+++// FUNDAMENTALS MODULE HEADER 
+++#ifndef _FUNDAMENTALS_H_
+++#define _FUNDAMENTALS_H_
+++
+++#include <stdio.h> 
+++#include <stdlib.h> 
+++#include <string.h>
+++
+++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+++void fundamentals(void);
+++
+++#endif
++\ No newline at end of file
++diff --git a/main.c b/main.c
++new file mode 100644
++index 0000000..755b397
++--- /dev/null
+++++ b/main.c
++@@ -0,0 +1,58 @@
+++// MAIN 
+++/*
+++Author: BB01, 03/08/2022, CPR101, Final Project V1
+++main.c : MAIN
+++Purpose: Main Function used to prompt user for which various options.
+++*/
+++
+++// Include all necessary modules
+++#define _CRT_SECURE_NO_WARNINGS
+++#include "fundamentals.h"
+++#include "manipulating.h"
+++#include "converting.h"
+++#include "tokenizing.h"
+++
+++int main(void) {
+++	// Declare variables
+++	char buff[10];
+++
+++	// Open menu for user
+++	do {
+++		// Display menu options
+++		printf("1 - Fundamentals\n");
+++		printf("2 - Manipulation\n");
+++		printf("3 - Converting\n");
+++		printf("4 - Tokenizing\n");
+++		printf("0 - Exit\n");
+++		
+++		// Prompt user for input
+++		printf("Which module to run? \n");
+++		fgets(buff, 10, stdin);
+++
+++		// Analyze user entry and match selection
+++		switch (buff[0])
+++		{
+++		case '1': 
+++			// Call for fundamentals module
+++			fundamentals();
+++			break;
+++
+++		case '2': 
+++			// Call for manipulating module
+++			manipulating();
+++			break;
+++
+++		case '3': 
+++			// Call for converting module
+++			converting();
+++			break;
+++
+++		case '4': 
+++			// Call for tokenizing module
+++			tokenizing();
+++			break;
+++		}
+++	} while (buff[0] != '0');
+++	
+++	return 0;
+++}
++\ No newline at end of file
++diff --git a/manipulating.c b/manipulating.c
++new file mode 100644
++index 0000000..748c895
++--- /dev/null
+++++ b/manipulating.c
++@@ -0,0 +1,34 @@
+++/*
+++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+++manipulating.c : Manipulating
+++Purpose: This program manipulates input strings
+++*/
+++
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 80
+++
+++#include "manipulating.h" 
+++/* Contains function prototypes and library declarations */
+++
+++void manipulating(void) {
+++/* Purpose: This function concatenates 2 input strings */
+++
+++	printf("*** Start of Concatenating Strings Demo ***\n");
+++	char string1[BUFFER_SIZE];
+++	char string2[BUFFER_SIZE];
+++
+++	do {
+++		printf("Type the 1st string (q - to quit):\n");
+++		fgets(string1, BUFFER_SIZE, stdin);
+++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+++
+++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+++			printf("Type the 2nd string:\n");
+++			fgets(string2, BUFFER_SIZE, stdin);
+++			strcat(string1, string2);
+++			printf("Concatenated string is \'%s\'\n", string1);
+++		}
+++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+++
+++	printf("*** End of Concatenating Strings Demo ***\n");
+++}
++\ No newline at end of file
++diff --git a/manipulating.h b/manipulating.h
++new file mode 100644
++index 0000000..8a8f926
++--- /dev/null
+++++ b/manipulating.h
++@@ -0,0 +1,11 @@
+++//MANIPULATING MODULE HEADER
+++#ifndef _MANIPULATING_H_
+++#define _MANIPULATING_H_
+++
+++#include <stdio.h>		// For input/output and printing
+++#include <string.h>		// For string manipulation functions
+++
+++void manipulating(void);
+++/* Purpose: This function concatenates 2 input strings */
+++
+++#endif
++diff --git a/tokenizing.c b/tokenizing.c
++new file mode 100644
++index 0000000..65d1c20
++--- /dev/null
+++++ b/tokenizing.c
++@@ -0,0 +1,42 @@
+++/*
+++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+++[tokenizing.c] : [tokenizing]
+++Purpose: [This function takes a user inputted string and tokenizes it]
+++*/
+++
+++
+++// TOKENIZING MODULE SOURCE
+++#define _CRT_SECURE_NO_WARNINGS
+++#define BUFFER_SIZE 300
+++#include "tokenizing.h"
+++
+++// V1
+++void tokenizing(void) {
+++
+++    printf("*** Start of Tokenizing Words Demo ***\n");
+++    char words[BUFFER_SIZE];
+++    char* nextWord = NULL;
+++    int wordsCounter;
+++    do {
+++        printf("Type a few words seperated by space (q - to quit):\n");
+++
+++        fgets(words, BUFFER_SIZE, stdin); 
+++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+++
+++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+++
+++        
+++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+++            while (nextWord) {
+++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+++            }
+++        }
+++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+++
+++    printf("*** End of Tokenizing Words Demo ***\n\n");
+++}
+++
+++
++diff --git a/tokenizing.h b/tokenizing.h
++new file mode 100644
++index 0000000..c00f3cb
++--- /dev/null
+++++ b/tokenizing.h
++@@ -0,0 +1,10 @@
+++// Tokenization header file
+++#ifndef _TOKENIZING_H_
+++#define _TOKENIZING_H_
+++
+++#include <stdio.h>
+++#include <string.h>
+++
+++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+++
+++#endif
++\ No newline at end of file
++
++commit f914d3afae4107c77728b3df4d39502c962ba74b
++Author: krpm <mungcalrina@gmail.com>
++Date:   Thu Aug 4 15:48:50 2022 -0400
++
++    Initial commit
++
++diff --git a/.gitattributes b/.gitattributes
++new file mode 100644
++index 0000000..dfe0770
++--- /dev/null
+++++ b/.gitattributes
++@@ -0,0 +1,2 @@
+++# Auto detect text files and perform LF normalization
+++* text=auto
+
+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 13:43:58 2022 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 953e516..9193243 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -41,7 +41,7 @@ void manipulating(void) {
+ 	do {
+ 		printf("Type the 1st string to compare (q - to quit):\n");
+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+ 			printf("Type the 2nd string to compare:\n");
+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+
+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Mon Aug 8 09:38:48 2022 -0500
+
+    Version 2
+    
+    Added version 2 codes
+
+diff --git a/manipulating.c b/manipulating.c
+index 9bde2d2..953e516 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+ #include "manipulating.h" 
+ /* Contains function prototypes and library declarations */
+ 
++// V1
+ void manipulating(void) {
+ /* Purpose: This function concatenates 2 input strings */
+ 
+@@ -19,16 +20,40 @@ void manipulating(void) {
+ 
+ 	do {
+ 		printf("Type the 1st string (q - to quit):\n");
+-		fgets(string1, BUFFER_SIZE, stdin);
+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 
+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+ 			printf("Type the 2nd string:\n");
+-			fgets(string2, BUFFER_SIZE, stdin);
++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 			strcat(string1, string2);
+ 			printf("Concatenated string is \'%s\'\n", string1);
+ 		}
+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+ 
+ 	printf("*** End of Concatenating Strings Demo ***\n");
++
++//V2
++	printf("*** Start of Comparing Strings Demo ***\n");
++	char compare1[BUFFER_SIZE];
++	char compare2[BUFFER_SIZE];
++	int result;
++	do {
++		printf("Type the 1st string to compare (q - to quit):\n");
++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++			printf("Type the 2nd string to compare:\n");
++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++			if (result < 0)
++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++			else if (result == 0)
++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++			else
++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++		}
++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Comparing Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Thu Aug 4 15:34:34 2022 -0500
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 748c895..9bde2d2 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+
+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 16:30:00 2022 -0400
+
+    Version 1
+
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..748c895
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,34 @@
++/*
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++manipulating.c : Manipulating
++Purpose: This program manipulates input strings
++*/
++
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++#include "manipulating.h" 
++/* Contains function prototypes and library declarations */
++
++void manipulating(void) {
++/* Purpose: This function concatenates 2 input strings */
++
++	printf("*** Start of Concatenating Strings Demo ***\n");
++	char string1[BUFFER_SIZE];
++	char string2[BUFFER_SIZE];
++
++	do {
++		printf("Type the 1st string (q - to quit):\n");
++		fgets(string1, BUFFER_SIZE, stdin);
++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++
++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++			printf("Type the 2nd string:\n");
++			fgets(string2, BUFFER_SIZE, stdin);
++			strcat(string1, string2);
++			printf("Concatenated string is \'%s\'\n", string1);
++		}
++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++
++	printf("*** End of Concatenating Strings Demo ***\n");
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..8a8f926
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,11 @@
++//MANIPULATING MODULE HEADER
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>		// For input/output and printing
++#include <string.h>		// For string manipulation functions
++
++void manipulating(void);
++/* Purpose: This function concatenates 2 input strings */
++
++#endif

commit e14f5c429efccb7dc63749da2a425659ad905631
Author: krpm <25734153+kiararina@users.noreply.github.com>
Date:   Fri Aug 12 08:37:11 2022 -0400

    Update manipulating.c for version 3.
    
    Added a section for checking the occurrence of 2nd string in 1st string.

diff --git a/manipulating.c b/manipulating.c
index 9193243..925e182 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -12,7 +12,7 @@ Purpose: This program manipulates input strings
 
 // V1
 void manipulating(void) {
-/* Purpose: This function concatenates 2 input strings */
+/* Purpose: This function concatenates, compares and checks occurence bet. 2 input strings */
 
 	printf("*** Start of Concatenating Strings Demo ***\n");
 	char string1[BUFFER_SIZE];
@@ -56,4 +56,27 @@ void manipulating(void) {
 		}
 	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
 	printf("*** End of Comparing Strings Demo ***\n\n");
+
+
+//V3
+	printf("*** Start of Searching Strings Demo ***\n");
+	char haystack[BUFFER_SIZE];
+	char needle[BUFFER_SIZE];
+	char* occurence = NULL;
+	do {
+		printf("Type the string (q - to quit):\n");
+		fgets(haystack, BUFFER_SIZE, stdin);		// Get the 1st string input
+		haystack[strlen(haystack) - 1] = '\0';		// Add the null terminator in the end of the string
+		if (strcmp(haystack, "q") != 0) {			// Check if the user wants to exit the program
+			printf("Type the substring:\n");
+			fgets(needle, BUFFER_SIZE, stdin);		// Get the 2nd string input
+			needle[strlen(needle) - 1] = '\0';		// Add the null terminator in the end of the string
+			occurence = strstr(haystack, needle);	// Check if 2nd string occurs on 1st string
+			if (occurence)							// If found, return the position where 2nd string occurs
+				printf("\'%s\' found at %d position\n", needle, (int) (occurence - haystack));
+			else						
+				printf("Not found\n");				
+		}
+	} while (strcmp(haystack, "q") != 0);			// Continue while user doesn't want to quit
+	printf("*** End of Searching Strings Demo ***\n\n");
 }
\ No newline at end of file

commit faa99c8f060ba6dd0f7cf11b2fd24257a6c75fd4
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Tue Aug 9 23:04:40 2022 -0400

    Adding git logs
    
    Version 2 Git Logs
    $ git --no-pager log -p > "module-git-log.txt"

diff --git a/converting-git-log.txt b/converting-git-log.txt
new file mode 100644
index 0000000..7bb5209
--- /dev/null
+++ b/converting-git-log.txt
@@ -0,0 +1,1345 @@
+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+Merge: 6361388 c3a8316
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:49:17 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit 63613886b8f1ecccb62538d6d4b7905425a16358
+Merge: 0626d2e c0f7dc8
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:47:37 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+Merge: 9d98950 c0f7dc8
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 22:46:28 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+Merge: fd97b97 a2a1bf4
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:47 2022 -0400
+
+    Merge pull request #1 from kiararina/converting
+    
+    Recovering lost commits up to converting.c
+
+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+Merge: cee497d fd97b97
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:00 2022 -0400
+
+    Merge branch 'main' into converting
+
+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:23:44 2022 -0400
+
+    tokenizing.c v2 corrected
+    
+    Corrected a previous error, now both v1 and v2 are within the same function name
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 6332b6d..ae26066 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+ 
+ 
++void tokenizing(void) {
+ 
+-/*
+-// V1
+-//void tokenizing(void) {
+-
++    // V1
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+     char* nextWord = NULL;
+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+     do {
+         printf("Type a few words seperated by space (q - to quit):\n");
+ 
+-        fgets(words, BUFFER_SIZE, stdin); 
++        fgets(words, BUFFER_SIZE, stdin);
+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-       }
++        }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+ 
+ 
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
++    // V2
++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char phrases[BUFFER_SIZE];
+     char* nextPhrase = NULL;
+
+commit 23f162166b815502c16ac1456d8f9be87b799f26
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:09:02 2022 -0400
+
+    Update tokenizing.c to V2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index edc3184..6332b6d 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+ [tokenizing.c] : [tokenizing]
+ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ #include "tokenizing.h"
+ 
+ 
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+ 
+ 
++/*
+ // V1
+-void tokenizing(void) {
++//void tokenizing(void) {
+ 
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+@@ -34,16 +31,46 @@ void tokenizing(void) {
+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+ 
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-        }
++       }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+ }
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
+ 
+ 
+
+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:06:55 2022 -0400
+
+    V1
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 417d34a..edc3184 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,80 +1,49 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+-
+-
+-/*
+-// V1
+-//void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-       }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+-
+-
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char phrases[BUFFER_SIZE];
+-    char* nextPhrase = NULL;
+-    int phrasesCounter;
+-    do {
+-        printf("Type a few words seperated by comma (q - to quit):\n");
+-
+-        fgets(phrases, BUFFER_SIZE, stdin); 
+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-            while (nextPhrase) {
+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-            }
+-        }
+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+
+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+Author: CRYPTO43 <singharshjot07@gmail.com>
+Date:   Tue Aug 9 17:12:27 2022 -0400
+
+    first commit
+
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..cd7cd9f
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,63 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void main(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++
++
++
++    // V2 
++    printf("*** Start of Measuring Strings Demo ***\n"); 
++    char buffer2[BUFFER_SIZE]; 
++    do { 
++        printf("Type a string (q - to quit):\n"); 
++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp(buffer2, "q") != 0) 
++            printf("The length of \'%s\' is %d characters\n", 
++            buffer2, (int)strlen(buffer2)); 
++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++        
++        printf("*** End of Measuring Strings Demo ***\n\n");
++}
++
++ 
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..383cccc
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void main(void);
++
++#endif
+\ No newline at end of file
+
+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 16:17:34 2022 -0400
+
+    Add files via upload
+    
+    Version 2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 65d1c20..417d34a 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,42 +1,80 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-// V1
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-        }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++/*
++// V1
++//void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++       }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+index c00f3cb..7899cc2 100644
+--- a/tokenizing.h
++++ b/tokenizing.h
+@@ -1,10 +1,10 @@
+-// Tokenization header file
+-#ifndef _TOKENIZING_H_
+-#define _TOKENIZING_H_
+-
+-#include <stdio.h>
+-#include <string.h>
+-
+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
+ #endif
+\ No newline at end of file
+
+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 15:47:34 2022 -0400
+
+    Version 2
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit e25ade313038da86c407f85f5c00586ba6b37a1b
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:05:20 2022 -0400
+
+    Update README.md
+
+diff --git a/README.md b/README.md
+index 28e7c31..f1ff45d 100644
+--- a/README.md
++++ b/README.md
+@@ -1,5 +1,8 @@
+ # CPR101_Project
+ CPR101 Final Project
++
+ Section: NAA
++
+ Group 1
++
+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit a3e1e5ae394af27b186e61562b7167819c90ea13
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:01:47 2022 -0400
+
+    Create README.md
+
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..28e7c31
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,5 @@
++# CPR101_Project
++CPR101 Final Project
++Section: NAA
++Group 1
++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 13:58:05 2022 -0400
+
+    Update converting.c
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 13:43:58 2022 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 953e516..9193243 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -41,7 +41,7 @@ void manipulating(void) {
+ 	do {
+ 		printf("Type the 1st string to compare (q - to quit):\n");
+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+ 			printf("Type the 2nd string to compare:\n");
+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+
+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 12:51:35 2022 -0400
+
+    Version 2
+    
+    Updated main for version 2
+
+diff --git a/main.c b/main.c
+index 755b397..70aeeb7 100644
+--- a/main.c
++++ b/main.c
+@@ -1,6 +1,6 @@
+ // MAIN 
+ /*
+-Author: BB01, 03/08/2022, CPR101, Final Project V1
++Author: BB01, 03/08/2022, CPR101, Final Project
+ main.c : MAIN
+ Purpose: Main Function used to prompt user for which various options.
+ */
+
+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Mon Aug 8 09:38:48 2022 -0500
+
+    Version 2
+    
+    Added version 2 codes
+
+diff --git a/manipulating.c b/manipulating.c
+index 9bde2d2..953e516 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+ #include "manipulating.h" 
+ /* Contains function prototypes and library declarations */
+ 
++// V1
+ void manipulating(void) {
+ /* Purpose: This function concatenates 2 input strings */
+ 
+@@ -19,16 +20,40 @@ void manipulating(void) {
+ 
+ 	do {
+ 		printf("Type the 1st string (q - to quit):\n");
+-		fgets(string1, BUFFER_SIZE, stdin);
+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 
+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+ 			printf("Type the 2nd string:\n");
+-			fgets(string2, BUFFER_SIZE, stdin);
++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 			strcat(string1, string2);
+ 			printf("Concatenated string is \'%s\'\n", string1);
+ 		}
+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+ 
+ 	printf("*** End of Concatenating Strings Demo ***\n");
++
++//V2
++	printf("*** Start of Comparing Strings Demo ***\n");
++	char compare1[BUFFER_SIZE];
++	char compare2[BUFFER_SIZE];
++	int result;
++	do {
++		printf("Type the 1st string to compare (q - to quit):\n");
++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++			printf("Type the 2nd string to compare:\n");
++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++			if (result < 0)
++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++			else if (result == 0)
++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++			else
++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++		}
++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Comparing Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Thu Aug 4 15:34:34 2022 -0500
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 748c895..9bde2d2 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+
+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 16:30:00 2022 -0400
+
+    Version 1
+
+diff --git a/Programming Comments.docx b/Programming Comments.docx
+new file mode 100644
+index 0000000..07d1cd7
+--- /dev/null
++++ b/Programming Comments.docx	
+@@ -0,0 +1,110 @@
++                        Commenting Program Source Code
++--------------------------------------------------------------------------------
++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++--------------------------------------------------------------------------------
++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++Comments are for programmers who will maintain the code in the future. 
++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++--------------------------------------------------------------------------------
++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++--------------------------------------------------------------------------------
++
++Organisation of Comments
++Program comments 
++ -  appear at the beginning of a source file.
++/* 
++Author: Name, email, ID, Date written, Course, Project
++[executable filename] : [title of program]
++Purpose: [what this program does, what problem does it solve?]
++*/
++
++Function comments
++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++/*
++Purpose: [what this function does, what problem does it solve?]
++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++*/
++
++Inline code comments
++Your comment must say something different than explaining the code itself. 
++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++c = a + b;  // c stores total of assignment and test marks respectively.
++
++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++cryptic = C + code; 		// explain this line's purpose in the program
++crypticly = C + moreCode;	// explain this line's purpose in the program
++
++Longer code comments
++Sometimes comments need more space than would fit inline. 
++cryptic = C + code;
++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++moreCrypticly = C + moreCode;	
++
++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++// this comment explains the purpose of the next line of code  
++cryptic = C + code;
++ 		
++// this comment explains the purpose of the next line of code  
++moreCrypticly = C + moreCode;	
++		
++
++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++
++Structures
++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++// [what the structure accomplishes]
++e.g. 
++// compute factorial	
++// prompt user until value within range 1  -  100 is input
++Code Samples
++printf("Type a few words separated by space(q - to quit):\n");
++gets(words);
++while (strcmp(words, "q") != 0) 
++{
++    word = strtok(words, " ");
++    w_counter = 1;
++    while (word) 
++    {
++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++        word = strtok(NULL, " ");
++    }
++    printf("Type a few words separated by space(q - to quit):\n");
++    gets(words);
++}
++
++ the first while continues until the 'words' variable is equal to "q". What is it for?
++ there is another while {structure} ... what does it do?
++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++ // keep looping until pointer is NULL
++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++ This technique is even more important at the end of a series nested structures, e.g.
++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++
++
++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++
++while (TRUE) // a comment explains why there is no exit condition here
++{
++ 	. . .
++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++. . .
++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++   // --------- *****      make it visually obvious that this is an exit from the structure
++. . .
++}
+diff --git a/converting.c b/converting.c
+new file mode 100644
+index 0000000..c5a0775
+--- /dev/null
++++ b/converting.c
+@@ -0,0 +1,43 @@
++// CONVERTING MODULE SOURCE
++/*
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++converting.c : CONVERTING
++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++*/
++
++#define	_CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++// strings and convert a string to an integer value.
++#include "converting.h"
++
++// V1
++void converting(void) {
++	// Display beginning message
++	printf("*** Start of Converting Strings to int Demo ***\n");
++
++	// Declare variables
++	char	intString[BUFFER_SIZE];
++	int		intNumber;
++
++	do {
++		// Prompt user for entry
++		printf("Type an int numeric string (q - to quit):\n");
++		fgets(intString, BUFFER_SIZE, stdin);
++		intString[strlen(intString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.
++		if (strcmp(intString, "q") != 0) {
++
++			// Convert user entry from string to integer value.
++			intNumber = atoi(intString);
++
++			// Display converted number.
++			printf("Converted number is %d\n", intNumber);
++		}
++	} while (strcmp(intString, "q") != 0);
++
++	// Display ending message and exit module.
++	printf("*** End of Converting Strings to int Demo ***\n\n");
++}
+diff --git a/converting.h b/converting.h
+new file mode 100644
+index 0000000..03c62a3
+--- /dev/null
++++ b/converting.h
+@@ -0,0 +1,18 @@
++// CONVERTING MODULE HEADER
++#ifndef _CONVERTING_H_
++#define _CONVERTING_H_
++
++// Libraries
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++
++
++/////////////////////////
++// Prototype  Function //
++/////////////////////////
++
++// Function used to apply conversions
++void converting(void);
++
++#endif
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..95c9f23
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,43 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void fundamentals(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++}
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..0433660
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void fundamentals(void);
++
++#endif
+\ No newline at end of file
+diff --git a/main.c b/main.c
+new file mode 100644
+index 0000000..755b397
+--- /dev/null
++++ b/main.c
+@@ -0,0 +1,58 @@
++// MAIN 
++/*
++Author: BB01, 03/08/2022, CPR101, Final Project V1
++main.c : MAIN
++Purpose: Main Function used to prompt user for which various options.
++*/
++
++// Include all necessary modules
++#define _CRT_SECURE_NO_WARNINGS
++#include "fundamentals.h"
++#include "manipulating.h"
++#include "converting.h"
++#include "tokenizing.h"
++
++int main(void) {
++	// Declare variables
++	char buff[10];
++
++	// Open menu for user
++	do {
++		// Display menu options
++		printf("1 - Fundamentals\n");
++		printf("2 - Manipulation\n");
++		printf("3 - Converting\n");
++		printf("4 - Tokenizing\n");
++		printf("0 - Exit\n");
++		
++		// Prompt user for input
++		printf("Which module to run? \n");
++		fgets(buff, 10, stdin);
++
++		// Analyze user entry and match selection
++		switch (buff[0])
++		{
++		case '1': 
++			// Call for fundamentals module
++			fundamentals();
++			break;
++
++		case '2': 
++			// Call for manipulating module
++			manipulating();
++			break;
++
++		case '3': 
++			// Call for converting module
++			converting();
++			break;
++
++		case '4': 
++			// Call for tokenizing module
++			tokenizing();
++			break;
++		}
++	} while (buff[0] != '0');
++	
++	return 0;
++}
+\ No newline at end of file
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..748c895
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,34 @@
++/*
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++manipulating.c : Manipulating
++Purpose: This program manipulates input strings
++*/
++
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++#include "manipulating.h" 
++/* Contains function prototypes and library declarations */
++
++void manipulating(void) {
++/* Purpose: This function concatenates 2 input strings */
++
++	printf("*** Start of Concatenating Strings Demo ***\n");
++	char string1[BUFFER_SIZE];
++	char string2[BUFFER_SIZE];
++
++	do {
++		printf("Type the 1st string (q - to quit):\n");
++		fgets(string1, BUFFER_SIZE, stdin);
++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++
++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++			printf("Type the 2nd string:\n");
++			fgets(string2, BUFFER_SIZE, stdin);
++			strcat(string1, string2);
++			printf("Concatenated string is \'%s\'\n", string1);
++		}
++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++
++	printf("*** End of Concatenating Strings Demo ***\n");
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..8a8f926
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,11 @@
++//MANIPULATING MODULE HEADER
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>		// For input/output and printing
++#include <string.h>		// For string manipulation functions
++
++void manipulating(void);
++/* Purpose: This function concatenates 2 input strings */
++
++#endif
+diff --git a/tokenizing.c b/tokenizing.c
+new file mode 100644
+index 0000000..65d1c20
+--- /dev/null
++++ b/tokenizing.c
+@@ -0,0 +1,42 @@
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+new file mode 100644
+index 0000000..c00f3cb
+--- /dev/null
++++ b/tokenizing.h
+@@ -0,0 +1,10 @@
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
++#endif
+\ No newline at end of file
+
+commit f914d3afae4107c77728b3df4d39502c962ba74b
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 15:48:50 2022 -0400
+
+    Initial commit
+
+diff --git a/.gitattributes b/.gitattributes
+new file mode 100644
+index 0000000..dfe0770
+--- /dev/null
++++ b/.gitattributes
+@@ -0,0 +1,2 @@
++# Auto detect text files and perform LF normalization
++* text=auto
diff --git a/fundamentals-git-log.txt b/fundamentals-git-log.txt
new file mode 100644
index 0000000..7bb5209
--- /dev/null
+++ b/fundamentals-git-log.txt
@@ -0,0 +1,1345 @@
+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+Merge: 6361388 c3a8316
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:49:17 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit 63613886b8f1ecccb62538d6d4b7905425a16358
+Merge: 0626d2e c0f7dc8
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:47:37 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+Merge: 9d98950 c0f7dc8
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 22:46:28 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+Merge: fd97b97 a2a1bf4
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:47 2022 -0400
+
+    Merge pull request #1 from kiararina/converting
+    
+    Recovering lost commits up to converting.c
+
+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+Merge: cee497d fd97b97
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:00 2022 -0400
+
+    Merge branch 'main' into converting
+
+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:23:44 2022 -0400
+
+    tokenizing.c v2 corrected
+    
+    Corrected a previous error, now both v1 and v2 are within the same function name
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 6332b6d..ae26066 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+ 
+ 
++void tokenizing(void) {
+ 
+-/*
+-// V1
+-//void tokenizing(void) {
+-
++    // V1
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+     char* nextWord = NULL;
+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+     do {
+         printf("Type a few words seperated by space (q - to quit):\n");
+ 
+-        fgets(words, BUFFER_SIZE, stdin); 
++        fgets(words, BUFFER_SIZE, stdin);
+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-       }
++        }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+ 
+ 
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
++    // V2
++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char phrases[BUFFER_SIZE];
+     char* nextPhrase = NULL;
+
+commit 23f162166b815502c16ac1456d8f9be87b799f26
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:09:02 2022 -0400
+
+    Update tokenizing.c to V2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index edc3184..6332b6d 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+ [tokenizing.c] : [tokenizing]
+ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ #include "tokenizing.h"
+ 
+ 
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+ 
+ 
++/*
+ // V1
+-void tokenizing(void) {
++//void tokenizing(void) {
+ 
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+@@ -34,16 +31,46 @@ void tokenizing(void) {
+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+ 
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-        }
++       }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+ }
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
+ 
+ 
+
+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:06:55 2022 -0400
+
+    V1
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 417d34a..edc3184 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,80 +1,49 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+-
+-
+-/*
+-// V1
+-//void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-       }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+-
+-
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char phrases[BUFFER_SIZE];
+-    char* nextPhrase = NULL;
+-    int phrasesCounter;
+-    do {
+-        printf("Type a few words seperated by comma (q - to quit):\n");
+-
+-        fgets(phrases, BUFFER_SIZE, stdin); 
+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-            while (nextPhrase) {
+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-            }
+-        }
+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+
+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+Author: CRYPTO43 <singharshjot07@gmail.com>
+Date:   Tue Aug 9 17:12:27 2022 -0400
+
+    first commit
+
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..cd7cd9f
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,63 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void main(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++
++
++
++    // V2 
++    printf("*** Start of Measuring Strings Demo ***\n"); 
++    char buffer2[BUFFER_SIZE]; 
++    do { 
++        printf("Type a string (q - to quit):\n"); 
++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp(buffer2, "q") != 0) 
++            printf("The length of \'%s\' is %d characters\n", 
++            buffer2, (int)strlen(buffer2)); 
++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++        
++        printf("*** End of Measuring Strings Demo ***\n\n");
++}
++
++ 
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..383cccc
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void main(void);
++
++#endif
+\ No newline at end of file
+
+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 16:17:34 2022 -0400
+
+    Add files via upload
+    
+    Version 2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 65d1c20..417d34a 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,42 +1,80 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-// V1
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-        }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++/*
++// V1
++//void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++       }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+index c00f3cb..7899cc2 100644
+--- a/tokenizing.h
++++ b/tokenizing.h
+@@ -1,10 +1,10 @@
+-// Tokenization header file
+-#ifndef _TOKENIZING_H_
+-#define _TOKENIZING_H_
+-
+-#include <stdio.h>
+-#include <string.h>
+-
+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
+ #endif
+\ No newline at end of file
+
+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 15:47:34 2022 -0400
+
+    Version 2
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit e25ade313038da86c407f85f5c00586ba6b37a1b
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:05:20 2022 -0400
+
+    Update README.md
+
+diff --git a/README.md b/README.md
+index 28e7c31..f1ff45d 100644
+--- a/README.md
++++ b/README.md
+@@ -1,5 +1,8 @@
+ # CPR101_Project
+ CPR101 Final Project
++
+ Section: NAA
++
+ Group 1
++
+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit a3e1e5ae394af27b186e61562b7167819c90ea13
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:01:47 2022 -0400
+
+    Create README.md
+
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..28e7c31
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,5 @@
++# CPR101_Project
++CPR101 Final Project
++Section: NAA
++Group 1
++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 13:58:05 2022 -0400
+
+    Update converting.c
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 13:43:58 2022 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 953e516..9193243 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -41,7 +41,7 @@ void manipulating(void) {
+ 	do {
+ 		printf("Type the 1st string to compare (q - to quit):\n");
+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+ 			printf("Type the 2nd string to compare:\n");
+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+
+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 12:51:35 2022 -0400
+
+    Version 2
+    
+    Updated main for version 2
+
+diff --git a/main.c b/main.c
+index 755b397..70aeeb7 100644
+--- a/main.c
++++ b/main.c
+@@ -1,6 +1,6 @@
+ // MAIN 
+ /*
+-Author: BB01, 03/08/2022, CPR101, Final Project V1
++Author: BB01, 03/08/2022, CPR101, Final Project
+ main.c : MAIN
+ Purpose: Main Function used to prompt user for which various options.
+ */
+
+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Mon Aug 8 09:38:48 2022 -0500
+
+    Version 2
+    
+    Added version 2 codes
+
+diff --git a/manipulating.c b/manipulating.c
+index 9bde2d2..953e516 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+ #include "manipulating.h" 
+ /* Contains function prototypes and library declarations */
+ 
++// V1
+ void manipulating(void) {
+ /* Purpose: This function concatenates 2 input strings */
+ 
+@@ -19,16 +20,40 @@ void manipulating(void) {
+ 
+ 	do {
+ 		printf("Type the 1st string (q - to quit):\n");
+-		fgets(string1, BUFFER_SIZE, stdin);
+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 
+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+ 			printf("Type the 2nd string:\n");
+-			fgets(string2, BUFFER_SIZE, stdin);
++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 			strcat(string1, string2);
+ 			printf("Concatenated string is \'%s\'\n", string1);
+ 		}
+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+ 
+ 	printf("*** End of Concatenating Strings Demo ***\n");
++
++//V2
++	printf("*** Start of Comparing Strings Demo ***\n");
++	char compare1[BUFFER_SIZE];
++	char compare2[BUFFER_SIZE];
++	int result;
++	do {
++		printf("Type the 1st string to compare (q - to quit):\n");
++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++			printf("Type the 2nd string to compare:\n");
++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++			if (result < 0)
++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++			else if (result == 0)
++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++			else
++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++		}
++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Comparing Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Thu Aug 4 15:34:34 2022 -0500
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 748c895..9bde2d2 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+
+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 16:30:00 2022 -0400
+
+    Version 1
+
+diff --git a/Programming Comments.docx b/Programming Comments.docx
+new file mode 100644
+index 0000000..07d1cd7
+--- /dev/null
++++ b/Programming Comments.docx	
+@@ -0,0 +1,110 @@
++                        Commenting Program Source Code
++--------------------------------------------------------------------------------
++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++--------------------------------------------------------------------------------
++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++Comments are for programmers who will maintain the code in the future. 
++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++--------------------------------------------------------------------------------
++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++--------------------------------------------------------------------------------
++
++Organisation of Comments
++Program comments 
++ -  appear at the beginning of a source file.
++/* 
++Author: Name, email, ID, Date written, Course, Project
++[executable filename] : [title of program]
++Purpose: [what this program does, what problem does it solve?]
++*/
++
++Function comments
++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++/*
++Purpose: [what this function does, what problem does it solve?]
++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++*/
++
++Inline code comments
++Your comment must say something different than explaining the code itself. 
++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++c = a + b;  // c stores total of assignment and test marks respectively.
++
++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++cryptic = C + code; 		// explain this line's purpose in the program
++crypticly = C + moreCode;	// explain this line's purpose in the program
++
++Longer code comments
++Sometimes comments need more space than would fit inline. 
++cryptic = C + code;
++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++moreCrypticly = C + moreCode;	
++
++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++// this comment explains the purpose of the next line of code  
++cryptic = C + code;
++ 		
++// this comment explains the purpose of the next line of code  
++moreCrypticly = C + moreCode;	
++		
++
++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++
++Structures
++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++// [what the structure accomplishes]
++e.g. 
++// compute factorial	
++// prompt user until value within range 1  -  100 is input
++Code Samples
++printf("Type a few words separated by space(q - to quit):\n");
++gets(words);
++while (strcmp(words, "q") != 0) 
++{
++    word = strtok(words, " ");
++    w_counter = 1;
++    while (word) 
++    {
++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++        word = strtok(NULL, " ");
++    }
++    printf("Type a few words separated by space(q - to quit):\n");
++    gets(words);
++}
++
++ the first while continues until the 'words' variable is equal to "q". What is it for?
++ there is another while {structure} ... what does it do?
++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++ // keep looping until pointer is NULL
++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++ This technique is even more important at the end of a series nested structures, e.g.
++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++
++
++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++
++while (TRUE) // a comment explains why there is no exit condition here
++{
++ 	. . .
++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++. . .
++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++   // --------- *****      make it visually obvious that this is an exit from the structure
++. . .
++}
+diff --git a/converting.c b/converting.c
+new file mode 100644
+index 0000000..c5a0775
+--- /dev/null
++++ b/converting.c
+@@ -0,0 +1,43 @@
++// CONVERTING MODULE SOURCE
++/*
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++converting.c : CONVERTING
++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++*/
++
++#define	_CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++// strings and convert a string to an integer value.
++#include "converting.h"
++
++// V1
++void converting(void) {
++	// Display beginning message
++	printf("*** Start of Converting Strings to int Demo ***\n");
++
++	// Declare variables
++	char	intString[BUFFER_SIZE];
++	int		intNumber;
++
++	do {
++		// Prompt user for entry
++		printf("Type an int numeric string (q - to quit):\n");
++		fgets(intString, BUFFER_SIZE, stdin);
++		intString[strlen(intString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.
++		if (strcmp(intString, "q") != 0) {
++
++			// Convert user entry from string to integer value.
++			intNumber = atoi(intString);
++
++			// Display converted number.
++			printf("Converted number is %d\n", intNumber);
++		}
++	} while (strcmp(intString, "q") != 0);
++
++	// Display ending message and exit module.
++	printf("*** End of Converting Strings to int Demo ***\n\n");
++}
+diff --git a/converting.h b/converting.h
+new file mode 100644
+index 0000000..03c62a3
+--- /dev/null
++++ b/converting.h
+@@ -0,0 +1,18 @@
++// CONVERTING MODULE HEADER
++#ifndef _CONVERTING_H_
++#define _CONVERTING_H_
++
++// Libraries
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++
++
++/////////////////////////
++// Prototype  Function //
++/////////////////////////
++
++// Function used to apply conversions
++void converting(void);
++
++#endif
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..95c9f23
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,43 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void fundamentals(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++}
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..0433660
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void fundamentals(void);
++
++#endif
+\ No newline at end of file
+diff --git a/main.c b/main.c
+new file mode 100644
+index 0000000..755b397
+--- /dev/null
++++ b/main.c
+@@ -0,0 +1,58 @@
++// MAIN 
++/*
++Author: BB01, 03/08/2022, CPR101, Final Project V1
++main.c : MAIN
++Purpose: Main Function used to prompt user for which various options.
++*/
++
++// Include all necessary modules
++#define _CRT_SECURE_NO_WARNINGS
++#include "fundamentals.h"
++#include "manipulating.h"
++#include "converting.h"
++#include "tokenizing.h"
++
++int main(void) {
++	// Declare variables
++	char buff[10];
++
++	// Open menu for user
++	do {
++		// Display menu options
++		printf("1 - Fundamentals\n");
++		printf("2 - Manipulation\n");
++		printf("3 - Converting\n");
++		printf("4 - Tokenizing\n");
++		printf("0 - Exit\n");
++		
++		// Prompt user for input
++		printf("Which module to run? \n");
++		fgets(buff, 10, stdin);
++
++		// Analyze user entry and match selection
++		switch (buff[0])
++		{
++		case '1': 
++			// Call for fundamentals module
++			fundamentals();
++			break;
++
++		case '2': 
++			// Call for manipulating module
++			manipulating();
++			break;
++
++		case '3': 
++			// Call for converting module
++			converting();
++			break;
++
++		case '4': 
++			// Call for tokenizing module
++			tokenizing();
++			break;
++		}
++	} while (buff[0] != '0');
++	
++	return 0;
++}
+\ No newline at end of file
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..748c895
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,34 @@
++/*
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++manipulating.c : Manipulating
++Purpose: This program manipulates input strings
++*/
++
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++#include "manipulating.h" 
++/* Contains function prototypes and library declarations */
++
++void manipulating(void) {
++/* Purpose: This function concatenates 2 input strings */
++
++	printf("*** Start of Concatenating Strings Demo ***\n");
++	char string1[BUFFER_SIZE];
++	char string2[BUFFER_SIZE];
++
++	do {
++		printf("Type the 1st string (q - to quit):\n");
++		fgets(string1, BUFFER_SIZE, stdin);
++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++
++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++			printf("Type the 2nd string:\n");
++			fgets(string2, BUFFER_SIZE, stdin);
++			strcat(string1, string2);
++			printf("Concatenated string is \'%s\'\n", string1);
++		}
++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++
++	printf("*** End of Concatenating Strings Demo ***\n");
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..8a8f926
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,11 @@
++//MANIPULATING MODULE HEADER
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>		// For input/output and printing
++#include <string.h>		// For string manipulation functions
++
++void manipulating(void);
++/* Purpose: This function concatenates 2 input strings */
++
++#endif
+diff --git a/tokenizing.c b/tokenizing.c
+new file mode 100644
+index 0000000..65d1c20
+--- /dev/null
++++ b/tokenizing.c
+@@ -0,0 +1,42 @@
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+new file mode 100644
+index 0000000..c00f3cb
+--- /dev/null
++++ b/tokenizing.h
+@@ -0,0 +1,10 @@
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
++#endif
+\ No newline at end of file
+
+commit f914d3afae4107c77728b3df4d39502c962ba74b
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 15:48:50 2022 -0400
+
+    Initial commit
+
+diff --git a/.gitattributes b/.gitattributes
+new file mode 100644
+index 0000000..dfe0770
+--- /dev/null
++++ b/.gitattributes
+@@ -0,0 +1,2 @@
++# Auto detect text files and perform LF normalization
++* text=auto
diff --git a/main-git-log.txt b/main-git-log.txt
new file mode 100644
index 0000000..7bb5209
--- /dev/null
+++ b/main-git-log.txt
@@ -0,0 +1,1345 @@
+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+Merge: 6361388 c3a8316
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:49:17 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit 63613886b8f1ecccb62538d6d4b7905425a16358
+Merge: 0626d2e c0f7dc8
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:47:37 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+Merge: 9d98950 c0f7dc8
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 22:46:28 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+Merge: fd97b97 a2a1bf4
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:47 2022 -0400
+
+    Merge pull request #1 from kiararina/converting
+    
+    Recovering lost commits up to converting.c
+
+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+Merge: cee497d fd97b97
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:00 2022 -0400
+
+    Merge branch 'main' into converting
+
+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:23:44 2022 -0400
+
+    tokenizing.c v2 corrected
+    
+    Corrected a previous error, now both v1 and v2 are within the same function name
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 6332b6d..ae26066 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+ 
+ 
++void tokenizing(void) {
+ 
+-/*
+-// V1
+-//void tokenizing(void) {
+-
++    // V1
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+     char* nextWord = NULL;
+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+     do {
+         printf("Type a few words seperated by space (q - to quit):\n");
+ 
+-        fgets(words, BUFFER_SIZE, stdin); 
++        fgets(words, BUFFER_SIZE, stdin);
+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-       }
++        }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+ 
+ 
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
++    // V2
++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char phrases[BUFFER_SIZE];
+     char* nextPhrase = NULL;
+
+commit 23f162166b815502c16ac1456d8f9be87b799f26
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:09:02 2022 -0400
+
+    Update tokenizing.c to V2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index edc3184..6332b6d 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+ [tokenizing.c] : [tokenizing]
+ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ #include "tokenizing.h"
+ 
+ 
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+ 
+ 
++/*
+ // V1
+-void tokenizing(void) {
++//void tokenizing(void) {
+ 
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+@@ -34,16 +31,46 @@ void tokenizing(void) {
+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+ 
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-        }
++       }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+ }
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
+ 
+ 
+
+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:06:55 2022 -0400
+
+    V1
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 417d34a..edc3184 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,80 +1,49 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+-
+-
+-/*
+-// V1
+-//void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-       }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+-
+-
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char phrases[BUFFER_SIZE];
+-    char* nextPhrase = NULL;
+-    int phrasesCounter;
+-    do {
+-        printf("Type a few words seperated by comma (q - to quit):\n");
+-
+-        fgets(phrases, BUFFER_SIZE, stdin); 
+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-            while (nextPhrase) {
+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-            }
+-        }
+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+
+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+Author: CRYPTO43 <singharshjot07@gmail.com>
+Date:   Tue Aug 9 17:12:27 2022 -0400
+
+    first commit
+
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..cd7cd9f
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,63 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void main(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++
++
++
++    // V2 
++    printf("*** Start of Measuring Strings Demo ***\n"); 
++    char buffer2[BUFFER_SIZE]; 
++    do { 
++        printf("Type a string (q - to quit):\n"); 
++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp(buffer2, "q") != 0) 
++            printf("The length of \'%s\' is %d characters\n", 
++            buffer2, (int)strlen(buffer2)); 
++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++        
++        printf("*** End of Measuring Strings Demo ***\n\n");
++}
++
++ 
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..383cccc
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void main(void);
++
++#endif
+\ No newline at end of file
+
+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 16:17:34 2022 -0400
+
+    Add files via upload
+    
+    Version 2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 65d1c20..417d34a 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,42 +1,80 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-// V1
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-        }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++/*
++// V1
++//void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++       }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+index c00f3cb..7899cc2 100644
+--- a/tokenizing.h
++++ b/tokenizing.h
+@@ -1,10 +1,10 @@
+-// Tokenization header file
+-#ifndef _TOKENIZING_H_
+-#define _TOKENIZING_H_
+-
+-#include <stdio.h>
+-#include <string.h>
+-
+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
+ #endif
+\ No newline at end of file
+
+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 15:47:34 2022 -0400
+
+    Version 2
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit e25ade313038da86c407f85f5c00586ba6b37a1b
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:05:20 2022 -0400
+
+    Update README.md
+
+diff --git a/README.md b/README.md
+index 28e7c31..f1ff45d 100644
+--- a/README.md
++++ b/README.md
+@@ -1,5 +1,8 @@
+ # CPR101_Project
+ CPR101 Final Project
++
+ Section: NAA
++
+ Group 1
++
+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit a3e1e5ae394af27b186e61562b7167819c90ea13
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:01:47 2022 -0400
+
+    Create README.md
+
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..28e7c31
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,5 @@
++# CPR101_Project
++CPR101 Final Project
++Section: NAA
++Group 1
++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 13:58:05 2022 -0400
+
+    Update converting.c
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 13:43:58 2022 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 953e516..9193243 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -41,7 +41,7 @@ void manipulating(void) {
+ 	do {
+ 		printf("Type the 1st string to compare (q - to quit):\n");
+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+ 			printf("Type the 2nd string to compare:\n");
+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+
+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 12:51:35 2022 -0400
+
+    Version 2
+    
+    Updated main for version 2
+
+diff --git a/main.c b/main.c
+index 755b397..70aeeb7 100644
+--- a/main.c
++++ b/main.c
+@@ -1,6 +1,6 @@
+ // MAIN 
+ /*
+-Author: BB01, 03/08/2022, CPR101, Final Project V1
++Author: BB01, 03/08/2022, CPR101, Final Project
+ main.c : MAIN
+ Purpose: Main Function used to prompt user for which various options.
+ */
+
+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Mon Aug 8 09:38:48 2022 -0500
+
+    Version 2
+    
+    Added version 2 codes
+
+diff --git a/manipulating.c b/manipulating.c
+index 9bde2d2..953e516 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+ #include "manipulating.h" 
+ /* Contains function prototypes and library declarations */
+ 
++// V1
+ void manipulating(void) {
+ /* Purpose: This function concatenates 2 input strings */
+ 
+@@ -19,16 +20,40 @@ void manipulating(void) {
+ 
+ 	do {
+ 		printf("Type the 1st string (q - to quit):\n");
+-		fgets(string1, BUFFER_SIZE, stdin);
+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 
+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+ 			printf("Type the 2nd string:\n");
+-			fgets(string2, BUFFER_SIZE, stdin);
++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 			strcat(string1, string2);
+ 			printf("Concatenated string is \'%s\'\n", string1);
+ 		}
+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+ 
+ 	printf("*** End of Concatenating Strings Demo ***\n");
++
++//V2
++	printf("*** Start of Comparing Strings Demo ***\n");
++	char compare1[BUFFER_SIZE];
++	char compare2[BUFFER_SIZE];
++	int result;
++	do {
++		printf("Type the 1st string to compare (q - to quit):\n");
++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++			printf("Type the 2nd string to compare:\n");
++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++			if (result < 0)
++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++			else if (result == 0)
++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++			else
++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++		}
++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Comparing Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Thu Aug 4 15:34:34 2022 -0500
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 748c895..9bde2d2 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+
+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 16:30:00 2022 -0400
+
+    Version 1
+
+diff --git a/Programming Comments.docx b/Programming Comments.docx
+new file mode 100644
+index 0000000..07d1cd7
+--- /dev/null
++++ b/Programming Comments.docx	
+@@ -0,0 +1,110 @@
++                        Commenting Program Source Code
++--------------------------------------------------------------------------------
++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++--------------------------------------------------------------------------------
++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++Comments are for programmers who will maintain the code in the future. 
++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++--------------------------------------------------------------------------------
++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++--------------------------------------------------------------------------------
++
++Organisation of Comments
++Program comments 
++ -  appear at the beginning of a source file.
++/* 
++Author: Name, email, ID, Date written, Course, Project
++[executable filename] : [title of program]
++Purpose: [what this program does, what problem does it solve?]
++*/
++
++Function comments
++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++/*
++Purpose: [what this function does, what problem does it solve?]
++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++*/
++
++Inline code comments
++Your comment must say something different than explaining the code itself. 
++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++c = a + b;  // c stores total of assignment and test marks respectively.
++
++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++cryptic = C + code; 		// explain this line's purpose in the program
++crypticly = C + moreCode;	// explain this line's purpose in the program
++
++Longer code comments
++Sometimes comments need more space than would fit inline. 
++cryptic = C + code;
++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++moreCrypticly = C + moreCode;	
++
++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++// this comment explains the purpose of the next line of code  
++cryptic = C + code;
++ 		
++// this comment explains the purpose of the next line of code  
++moreCrypticly = C + moreCode;	
++		
++
++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++
++Structures
++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++// [what the structure accomplishes]
++e.g. 
++// compute factorial	
++// prompt user until value within range 1  -  100 is input
++Code Samples
++printf("Type a few words separated by space(q - to quit):\n");
++gets(words);
++while (strcmp(words, "q") != 0) 
++{
++    word = strtok(words, " ");
++    w_counter = 1;
++    while (word) 
++    {
++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++        word = strtok(NULL, " ");
++    }
++    printf("Type a few words separated by space(q - to quit):\n");
++    gets(words);
++}
++
++ the first while continues until the 'words' variable is equal to "q". What is it for?
++ there is another while {structure} ... what does it do?
++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++ // keep looping until pointer is NULL
++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++ This technique is even more important at the end of a series nested structures, e.g.
++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++
++
++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++
++while (TRUE) // a comment explains why there is no exit condition here
++{
++ 	. . .
++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++. . .
++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++   // --------- *****      make it visually obvious that this is an exit from the structure
++. . .
++}
+diff --git a/converting.c b/converting.c
+new file mode 100644
+index 0000000..c5a0775
+--- /dev/null
++++ b/converting.c
+@@ -0,0 +1,43 @@
++// CONVERTING MODULE SOURCE
++/*
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++converting.c : CONVERTING
++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++*/
++
++#define	_CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++// strings and convert a string to an integer value.
++#include "converting.h"
++
++// V1
++void converting(void) {
++	// Display beginning message
++	printf("*** Start of Converting Strings to int Demo ***\n");
++
++	// Declare variables
++	char	intString[BUFFER_SIZE];
++	int		intNumber;
++
++	do {
++		// Prompt user for entry
++		printf("Type an int numeric string (q - to quit):\n");
++		fgets(intString, BUFFER_SIZE, stdin);
++		intString[strlen(intString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.
++		if (strcmp(intString, "q") != 0) {
++
++			// Convert user entry from string to integer value.
++			intNumber = atoi(intString);
++
++			// Display converted number.
++			printf("Converted number is %d\n", intNumber);
++		}
++	} while (strcmp(intString, "q") != 0);
++
++	// Display ending message and exit module.
++	printf("*** End of Converting Strings to int Demo ***\n\n");
++}
+diff --git a/converting.h b/converting.h
+new file mode 100644
+index 0000000..03c62a3
+--- /dev/null
++++ b/converting.h
+@@ -0,0 +1,18 @@
++// CONVERTING MODULE HEADER
++#ifndef _CONVERTING_H_
++#define _CONVERTING_H_
++
++// Libraries
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++
++
++/////////////////////////
++// Prototype  Function //
++/////////////////////////
++
++// Function used to apply conversions
++void converting(void);
++
++#endif
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..95c9f23
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,43 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void fundamentals(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++}
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..0433660
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void fundamentals(void);
++
++#endif
+\ No newline at end of file
+diff --git a/main.c b/main.c
+new file mode 100644
+index 0000000..755b397
+--- /dev/null
++++ b/main.c
+@@ -0,0 +1,58 @@
++// MAIN 
++/*
++Author: BB01, 03/08/2022, CPR101, Final Project V1
++main.c : MAIN
++Purpose: Main Function used to prompt user for which various options.
++*/
++
++// Include all necessary modules
++#define _CRT_SECURE_NO_WARNINGS
++#include "fundamentals.h"
++#include "manipulating.h"
++#include "converting.h"
++#include "tokenizing.h"
++
++int main(void) {
++	// Declare variables
++	char buff[10];
++
++	// Open menu for user
++	do {
++		// Display menu options
++		printf("1 - Fundamentals\n");
++		printf("2 - Manipulation\n");
++		printf("3 - Converting\n");
++		printf("4 - Tokenizing\n");
++		printf("0 - Exit\n");
++		
++		// Prompt user for input
++		printf("Which module to run? \n");
++		fgets(buff, 10, stdin);
++
++		// Analyze user entry and match selection
++		switch (buff[0])
++		{
++		case '1': 
++			// Call for fundamentals module
++			fundamentals();
++			break;
++
++		case '2': 
++			// Call for manipulating module
++			manipulating();
++			break;
++
++		case '3': 
++			// Call for converting module
++			converting();
++			break;
++
++		case '4': 
++			// Call for tokenizing module
++			tokenizing();
++			break;
++		}
++	} while (buff[0] != '0');
++	
++	return 0;
++}
+\ No newline at end of file
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..748c895
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,34 @@
++/*
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++manipulating.c : Manipulating
++Purpose: This program manipulates input strings
++*/
++
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++#include "manipulating.h" 
++/* Contains function prototypes and library declarations */
++
++void manipulating(void) {
++/* Purpose: This function concatenates 2 input strings */
++
++	printf("*** Start of Concatenating Strings Demo ***\n");
++	char string1[BUFFER_SIZE];
++	char string2[BUFFER_SIZE];
++
++	do {
++		printf("Type the 1st string (q - to quit):\n");
++		fgets(string1, BUFFER_SIZE, stdin);
++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++
++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++			printf("Type the 2nd string:\n");
++			fgets(string2, BUFFER_SIZE, stdin);
++			strcat(string1, string2);
++			printf("Concatenated string is \'%s\'\n", string1);
++		}
++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++
++	printf("*** End of Concatenating Strings Demo ***\n");
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..8a8f926
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,11 @@
++//MANIPULATING MODULE HEADER
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>		// For input/output and printing
++#include <string.h>		// For string manipulation functions
++
++void manipulating(void);
++/* Purpose: This function concatenates 2 input strings */
++
++#endif
+diff --git a/tokenizing.c b/tokenizing.c
+new file mode 100644
+index 0000000..65d1c20
+--- /dev/null
++++ b/tokenizing.c
+@@ -0,0 +1,42 @@
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+new file mode 100644
+index 0000000..c00f3cb
+--- /dev/null
++++ b/tokenizing.h
+@@ -0,0 +1,10 @@
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
++#endif
+\ No newline at end of file
+
+commit f914d3afae4107c77728b3df4d39502c962ba74b
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 15:48:50 2022 -0400
+
+    Initial commit
+
+diff --git a/.gitattributes b/.gitattributes
+new file mode 100644
+index 0000000..dfe0770
+--- /dev/null
++++ b/.gitattributes
+@@ -0,0 +1,2 @@
++# Auto detect text files and perform LF normalization
++* text=auto
diff --git a/manipulating-git-log.txt b/manipulating-git-log.txt
new file mode 100644
index 0000000..7bb5209
--- /dev/null
+++ b/manipulating-git-log.txt
@@ -0,0 +1,1345 @@
+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+Merge: 6361388 c3a8316
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:49:17 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit 63613886b8f1ecccb62538d6d4b7905425a16358
+Merge: 0626d2e c0f7dc8
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:47:37 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+Merge: 9d98950 c0f7dc8
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 22:46:28 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+Merge: fd97b97 a2a1bf4
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:47 2022 -0400
+
+    Merge pull request #1 from kiararina/converting
+    
+    Recovering lost commits up to converting.c
+
+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+Merge: cee497d fd97b97
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:00 2022 -0400
+
+    Merge branch 'main' into converting
+
+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:23:44 2022 -0400
+
+    tokenizing.c v2 corrected
+    
+    Corrected a previous error, now both v1 and v2 are within the same function name
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 6332b6d..ae26066 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+ 
+ 
++void tokenizing(void) {
+ 
+-/*
+-// V1
+-//void tokenizing(void) {
+-
++    // V1
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+     char* nextWord = NULL;
+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+     do {
+         printf("Type a few words seperated by space (q - to quit):\n");
+ 
+-        fgets(words, BUFFER_SIZE, stdin); 
++        fgets(words, BUFFER_SIZE, stdin);
+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-       }
++        }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+ 
+ 
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
++    // V2
++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char phrases[BUFFER_SIZE];
+     char* nextPhrase = NULL;
+
+commit 23f162166b815502c16ac1456d8f9be87b799f26
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:09:02 2022 -0400
+
+    Update tokenizing.c to V2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index edc3184..6332b6d 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+ [tokenizing.c] : [tokenizing]
+ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ #include "tokenizing.h"
+ 
+ 
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+ 
+ 
++/*
+ // V1
+-void tokenizing(void) {
++//void tokenizing(void) {
+ 
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+@@ -34,16 +31,46 @@ void tokenizing(void) {
+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+ 
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-        }
++       }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+ }
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
+ 
+ 
+
+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:06:55 2022 -0400
+
+    V1
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 417d34a..edc3184 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,80 +1,49 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+-
+-
+-/*
+-// V1
+-//void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-       }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+-
+-
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char phrases[BUFFER_SIZE];
+-    char* nextPhrase = NULL;
+-    int phrasesCounter;
+-    do {
+-        printf("Type a few words seperated by comma (q - to quit):\n");
+-
+-        fgets(phrases, BUFFER_SIZE, stdin); 
+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-            while (nextPhrase) {
+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-            }
+-        }
+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+
+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+Author: CRYPTO43 <singharshjot07@gmail.com>
+Date:   Tue Aug 9 17:12:27 2022 -0400
+
+    first commit
+
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..cd7cd9f
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,63 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void main(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++
++
++
++    // V2 
++    printf("*** Start of Measuring Strings Demo ***\n"); 
++    char buffer2[BUFFER_SIZE]; 
++    do { 
++        printf("Type a string (q - to quit):\n"); 
++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp(buffer2, "q") != 0) 
++            printf("The length of \'%s\' is %d characters\n", 
++            buffer2, (int)strlen(buffer2)); 
++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++        
++        printf("*** End of Measuring Strings Demo ***\n\n");
++}
++
++ 
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..383cccc
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void main(void);
++
++#endif
+\ No newline at end of file
+
+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 16:17:34 2022 -0400
+
+    Add files via upload
+    
+    Version 2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 65d1c20..417d34a 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,42 +1,80 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-// V1
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-        }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++/*
++// V1
++//void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++       }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+index c00f3cb..7899cc2 100644
+--- a/tokenizing.h
++++ b/tokenizing.h
+@@ -1,10 +1,10 @@
+-// Tokenization header file
+-#ifndef _TOKENIZING_H_
+-#define _TOKENIZING_H_
+-
+-#include <stdio.h>
+-#include <string.h>
+-
+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
+ #endif
+\ No newline at end of file
+
+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 15:47:34 2022 -0400
+
+    Version 2
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit e25ade313038da86c407f85f5c00586ba6b37a1b
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:05:20 2022 -0400
+
+    Update README.md
+
+diff --git a/README.md b/README.md
+index 28e7c31..f1ff45d 100644
+--- a/README.md
++++ b/README.md
+@@ -1,5 +1,8 @@
+ # CPR101_Project
+ CPR101 Final Project
++
+ Section: NAA
++
+ Group 1
++
+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit a3e1e5ae394af27b186e61562b7167819c90ea13
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:01:47 2022 -0400
+
+    Create README.md
+
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..28e7c31
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,5 @@
++# CPR101_Project
++CPR101 Final Project
++Section: NAA
++Group 1
++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 13:58:05 2022 -0400
+
+    Update converting.c
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 13:43:58 2022 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 953e516..9193243 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -41,7 +41,7 @@ void manipulating(void) {
+ 	do {
+ 		printf("Type the 1st string to compare (q - to quit):\n");
+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+ 			printf("Type the 2nd string to compare:\n");
+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+
+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 12:51:35 2022 -0400
+
+    Version 2
+    
+    Updated main for version 2
+
+diff --git a/main.c b/main.c
+index 755b397..70aeeb7 100644
+--- a/main.c
++++ b/main.c
+@@ -1,6 +1,6 @@
+ // MAIN 
+ /*
+-Author: BB01, 03/08/2022, CPR101, Final Project V1
++Author: BB01, 03/08/2022, CPR101, Final Project
+ main.c : MAIN
+ Purpose: Main Function used to prompt user for which various options.
+ */
+
+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Mon Aug 8 09:38:48 2022 -0500
+
+    Version 2
+    
+    Added version 2 codes
+
+diff --git a/manipulating.c b/manipulating.c
+index 9bde2d2..953e516 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+ #include "manipulating.h" 
+ /* Contains function prototypes and library declarations */
+ 
++// V1
+ void manipulating(void) {
+ /* Purpose: This function concatenates 2 input strings */
+ 
+@@ -19,16 +20,40 @@ void manipulating(void) {
+ 
+ 	do {
+ 		printf("Type the 1st string (q - to quit):\n");
+-		fgets(string1, BUFFER_SIZE, stdin);
+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 
+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+ 			printf("Type the 2nd string:\n");
+-			fgets(string2, BUFFER_SIZE, stdin);
++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 			strcat(string1, string2);
+ 			printf("Concatenated string is \'%s\'\n", string1);
+ 		}
+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+ 
+ 	printf("*** End of Concatenating Strings Demo ***\n");
++
++//V2
++	printf("*** Start of Comparing Strings Demo ***\n");
++	char compare1[BUFFER_SIZE];
++	char compare2[BUFFER_SIZE];
++	int result;
++	do {
++		printf("Type the 1st string to compare (q - to quit):\n");
++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++			printf("Type the 2nd string to compare:\n");
++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++			if (result < 0)
++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++			else if (result == 0)
++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++			else
++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++		}
++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Comparing Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Thu Aug 4 15:34:34 2022 -0500
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 748c895..9bde2d2 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+
+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 16:30:00 2022 -0400
+
+    Version 1
+
+diff --git a/Programming Comments.docx b/Programming Comments.docx
+new file mode 100644
+index 0000000..07d1cd7
+--- /dev/null
++++ b/Programming Comments.docx	
+@@ -0,0 +1,110 @@
++                        Commenting Program Source Code
++--------------------------------------------------------------------------------
++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++--------------------------------------------------------------------------------
++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++Comments are for programmers who will maintain the code in the future. 
++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++--------------------------------------------------------------------------------
++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++--------------------------------------------------------------------------------
++
++Organisation of Comments
++Program comments 
++ -  appear at the beginning of a source file.
++/* 
++Author: Name, email, ID, Date written, Course, Project
++[executable filename] : [title of program]
++Purpose: [what this program does, what problem does it solve?]
++*/
++
++Function comments
++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++/*
++Purpose: [what this function does, what problem does it solve?]
++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++*/
++
++Inline code comments
++Your comment must say something different than explaining the code itself. 
++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++c = a + b;  // c stores total of assignment and test marks respectively.
++
++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++cryptic = C + code; 		// explain this line's purpose in the program
++crypticly = C + moreCode;	// explain this line's purpose in the program
++
++Longer code comments
++Sometimes comments need more space than would fit inline. 
++cryptic = C + code;
++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++moreCrypticly = C + moreCode;	
++
++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++// this comment explains the purpose of the next line of code  
++cryptic = C + code;
++ 		
++// this comment explains the purpose of the next line of code  
++moreCrypticly = C + moreCode;	
++		
++
++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++
++Structures
++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++// [what the structure accomplishes]
++e.g. 
++// compute factorial	
++// prompt user until value within range 1  -  100 is input
++Code Samples
++printf("Type a few words separated by space(q - to quit):\n");
++gets(words);
++while (strcmp(words, "q") != 0) 
++{
++    word = strtok(words, " ");
++    w_counter = 1;
++    while (word) 
++    {
++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++        word = strtok(NULL, " ");
++    }
++    printf("Type a few words separated by space(q - to quit):\n");
++    gets(words);
++}
++
++ the first while continues until the 'words' variable is equal to "q". What is it for?
++ there is another while {structure} ... what does it do?
++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++ // keep looping until pointer is NULL
++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++ This technique is even more important at the end of a series nested structures, e.g.
++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++
++
++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++
++while (TRUE) // a comment explains why there is no exit condition here
++{
++ 	. . .
++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++. . .
++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++   // --------- *****      make it visually obvious that this is an exit from the structure
++. . .
++}
+diff --git a/converting.c b/converting.c
+new file mode 100644
+index 0000000..c5a0775
+--- /dev/null
++++ b/converting.c
+@@ -0,0 +1,43 @@
++// CONVERTING MODULE SOURCE
++/*
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++converting.c : CONVERTING
++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++*/
++
++#define	_CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++// strings and convert a string to an integer value.
++#include "converting.h"
++
++// V1
++void converting(void) {
++	// Display beginning message
++	printf("*** Start of Converting Strings to int Demo ***\n");
++
++	// Declare variables
++	char	intString[BUFFER_SIZE];
++	int		intNumber;
++
++	do {
++		// Prompt user for entry
++		printf("Type an int numeric string (q - to quit):\n");
++		fgets(intString, BUFFER_SIZE, stdin);
++		intString[strlen(intString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.
++		if (strcmp(intString, "q") != 0) {
++
++			// Convert user entry from string to integer value.
++			intNumber = atoi(intString);
++
++			// Display converted number.
++			printf("Converted number is %d\n", intNumber);
++		}
++	} while (strcmp(intString, "q") != 0);
++
++	// Display ending message and exit module.
++	printf("*** End of Converting Strings to int Demo ***\n\n");
++}
+diff --git a/converting.h b/converting.h
+new file mode 100644
+index 0000000..03c62a3
+--- /dev/null
++++ b/converting.h
+@@ -0,0 +1,18 @@
++// CONVERTING MODULE HEADER
++#ifndef _CONVERTING_H_
++#define _CONVERTING_H_
++
++// Libraries
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++
++
++/////////////////////////
++// Prototype  Function //
++/////////////////////////
++
++// Function used to apply conversions
++void converting(void);
++
++#endif
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..95c9f23
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,43 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void fundamentals(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++}
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..0433660
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void fundamentals(void);
++
++#endif
+\ No newline at end of file
+diff --git a/main.c b/main.c
+new file mode 100644
+index 0000000..755b397
+--- /dev/null
++++ b/main.c
+@@ -0,0 +1,58 @@
++// MAIN 
++/*
++Author: BB01, 03/08/2022, CPR101, Final Project V1
++main.c : MAIN
++Purpose: Main Function used to prompt user for which various options.
++*/
++
++// Include all necessary modules
++#define _CRT_SECURE_NO_WARNINGS
++#include "fundamentals.h"
++#include "manipulating.h"
++#include "converting.h"
++#include "tokenizing.h"
++
++int main(void) {
++	// Declare variables
++	char buff[10];
++
++	// Open menu for user
++	do {
++		// Display menu options
++		printf("1 - Fundamentals\n");
++		printf("2 - Manipulation\n");
++		printf("3 - Converting\n");
++		printf("4 - Tokenizing\n");
++		printf("0 - Exit\n");
++		
++		// Prompt user for input
++		printf("Which module to run? \n");
++		fgets(buff, 10, stdin);
++
++		// Analyze user entry and match selection
++		switch (buff[0])
++		{
++		case '1': 
++			// Call for fundamentals module
++			fundamentals();
++			break;
++
++		case '2': 
++			// Call for manipulating module
++			manipulating();
++			break;
++
++		case '3': 
++			// Call for converting module
++			converting();
++			break;
++
++		case '4': 
++			// Call for tokenizing module
++			tokenizing();
++			break;
++		}
++	} while (buff[0] != '0');
++	
++	return 0;
++}
+\ No newline at end of file
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..748c895
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,34 @@
++/*
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++manipulating.c : Manipulating
++Purpose: This program manipulates input strings
++*/
++
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++#include "manipulating.h" 
++/* Contains function prototypes and library declarations */
++
++void manipulating(void) {
++/* Purpose: This function concatenates 2 input strings */
++
++	printf("*** Start of Concatenating Strings Demo ***\n");
++	char string1[BUFFER_SIZE];
++	char string2[BUFFER_SIZE];
++
++	do {
++		printf("Type the 1st string (q - to quit):\n");
++		fgets(string1, BUFFER_SIZE, stdin);
++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++
++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++			printf("Type the 2nd string:\n");
++			fgets(string2, BUFFER_SIZE, stdin);
++			strcat(string1, string2);
++			printf("Concatenated string is \'%s\'\n", string1);
++		}
++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++
++	printf("*** End of Concatenating Strings Demo ***\n");
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..8a8f926
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,11 @@
++//MANIPULATING MODULE HEADER
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>		// For input/output and printing
++#include <string.h>		// For string manipulation functions
++
++void manipulating(void);
++/* Purpose: This function concatenates 2 input strings */
++
++#endif
+diff --git a/tokenizing.c b/tokenizing.c
+new file mode 100644
+index 0000000..65d1c20
+--- /dev/null
++++ b/tokenizing.c
+@@ -0,0 +1,42 @@
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+new file mode 100644
+index 0000000..c00f3cb
+--- /dev/null
++++ b/tokenizing.h
+@@ -0,0 +1,10 @@
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
++#endif
+\ No newline at end of file
+
+commit f914d3afae4107c77728b3df4d39502c962ba74b
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 15:48:50 2022 -0400
+
+    Initial commit
+
+diff --git a/.gitattributes b/.gitattributes
+new file mode 100644
+index 0000000..dfe0770
+--- /dev/null
++++ b/.gitattributes
+@@ -0,0 +1,2 @@
++# Auto detect text files and perform LF normalization
++* text=auto
diff --git a/tokenizing-git-log.txt b/tokenizing-git-log.txt
new file mode 100644
index 0000000..7bb5209
--- /dev/null
+++ b/tokenizing-git-log.txt
@@ -0,0 +1,1345 @@
+commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
+Merge: 6361388 c3a8316
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:49:17 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit 63613886b8f1ecccb62538d6d4b7905425a16358
+Merge: 0626d2e c0f7dc8
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Tue Aug 9 22:47:37 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c3a831696d320ac9100ed65017dacd96abb6c7c0
+Merge: 9d98950 c0f7dc8
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 22:46:28 2022 -0400
+
+    Merge branch 'main' of https://github.com/kiararina/CPR101_Project
+
+commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
+Merge: fd97b97 a2a1bf4
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:47 2022 -0400
+
+    Merge pull request #1 from kiararina/converting
+    
+    Recovering lost commits up to converting.c
+
+commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
+Merge: cee497d fd97b97
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Tue Aug 9 22:44:00 2022 -0400
+
+    Merge branch 'main' into converting
+
+commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:23:44 2022 -0400
+
+    tokenizing.c v2 corrected
+    
+    Corrected a previous error, now both v1 and v2 are within the same function name
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 6332b6d..ae26066 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+ 
+ 
++void tokenizing(void) {
+ 
+-/*
+-// V1
+-//void tokenizing(void) {
+-
++    // V1
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+     char* nextWord = NULL;
+@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+     do {
+         printf("Type a few words seperated by space (q - to quit):\n");
+ 
+-        fgets(words, BUFFER_SIZE, stdin); 
++        fgets(words, BUFFER_SIZE, stdin);
+         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+ 
+         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ 
+     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-       }
++        }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+ 
+ 
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
++    // V2
++    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char phrases[BUFFER_SIZE];
+     char* nextPhrase = NULL;
+
+commit 23f162166b815502c16ac1456d8f9be87b799f26
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:09:02 2022 -0400
+
+    Update tokenizing.c to V2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index edc3184..6332b6d 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+ [tokenizing.c] : [tokenizing]
+ Purpose: [This function takes a user inputted string and tokenizes it]
+ */
+@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
+ #include "tokenizing.h"
+ 
+ 
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+ 
+ 
++/*
+ // V1
+-void tokenizing(void) {
++//void tokenizing(void) {
+ 
+     printf("*** Start of Tokenizing Words Demo ***\n");
+     char words[BUFFER_SIZE];
+@@ -34,16 +31,46 @@ void tokenizing(void) {
+             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+ 
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+             while (nextWord) {
+                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+             }
+-        }
++       }
+     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+ 
+     printf("*** End of Tokenizing Words Demo ***\n\n");
+ }
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
+ 
+ 
+
+commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 19:06:55 2022 -0400
+
+    V1
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 417d34a..edc3184 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,80 +1,49 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-
+-int main(void) {
+-    tokenizing();
+-    return 0;
+-}
+-
+-
+-/*
+-// V1
+-//void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-       }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-*/
+-
+-
+-// V2
+-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char phrases[BUFFER_SIZE];
+-    char* nextPhrase = NULL;
+-    int phrasesCounter;
+-    do {
+-        printf("Type a few words seperated by comma (q - to quit):\n");
+-
+-        fgets(phrases, BUFFER_SIZE, stdin); 
+-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+-            while (nextPhrase) {
+-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+-            }
+-        }
+-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+
+commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
+Author: CRYPTO43 <singharshjot07@gmail.com>
+Date:   Tue Aug 9 17:12:27 2022 -0400
+
+    first commit
+
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..cd7cd9f
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,63 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void main(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++
++
++
++    // V2 
++    printf("*** Start of Measuring Strings Demo ***\n"); 
++    char buffer2[BUFFER_SIZE]; 
++    do { 
++        printf("Type a string (q - to quit):\n"); 
++        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
++        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp(buffer2, "q") != 0) 
++            printf("The length of \'%s\' is %d characters\n", 
++            buffer2, (int)strlen(buffer2)); 
++        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
++        
++        printf("*** End of Measuring Strings Demo ***\n\n");
++}
++
++ 
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..383cccc
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void main(void);
++
++#endif
+\ No newline at end of file
+
+commit 425a7ac33f432099cac3faa3a90bb69daf84067f
+Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
+Date:   Tue Aug 9 16:17:34 2022 -0400
+
+    Add files via upload
+    
+    Version 2
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 65d1c20..417d34a 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,42 +1,80 @@
+-/*
+-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+-[tokenizing.c] : [tokenizing]
+-Purpose: [This function takes a user inputted string and tokenizes it]
+-*/
+-
+-
+-// TOKENIZING MODULE SOURCE
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+-#include "tokenizing.h"
+-
+-// V1
+-void tokenizing(void) {
+-
+-    printf("*** Start of Tokenizing Words Demo ***\n");
+-    char words[BUFFER_SIZE];
+-    char* nextWord = NULL;
+-    int wordsCounter;
+-    do {
+-        printf("Type a few words seperated by space (q - to quit):\n");
+-
+-        fgets(words, BUFFER_SIZE, stdin); 
+-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+-
+-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+-
+-        
+-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+-            while (nextWord) {
+-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+-            }
+-        }
+-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+-
+-    printf("*** End of Tokenizing Words Demo ***\n\n");
+-}
+-
+-
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++
++int main(void) {
++    tokenizing();
++    return 0;
++}
++
++
++/*
++// V1
++//void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++       }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++*/
++
++
++// V2
++/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few words seperated by comma (q - to quit):\n");
++
++        fgets(phrases, BUFFER_SIZE, stdin); 
++        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
++            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
++            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
++            while (nextPhrase) {
++                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
++                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
++            }
++        }
++    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+index c00f3cb..7899cc2 100644
+--- a/tokenizing.h
++++ b/tokenizing.h
+@@ -1,10 +1,10 @@
+-// Tokenization header file
+-#ifndef _TOKENIZING_H_
+-#define _TOKENIZING_H_
+-
+-#include <stdio.h>
+-#include <string.h>
+-
+-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+-
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
+ #endif
+\ No newline at end of file
+
+commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 15:47:34 2022 -0400
+
+    Version 2
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit e25ade313038da86c407f85f5c00586ba6b37a1b
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:05:20 2022 -0400
+
+    Update README.md
+
+diff --git a/README.md b/README.md
+index 28e7c31..f1ff45d 100644
+--- a/README.md
++++ b/README.md
+@@ -1,5 +1,8 @@
+ # CPR101_Project
+ CPR101 Final Project
++
+ Section: NAA
++
+ Group 1
++
+ Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit a3e1e5ae394af27b186e61562b7167819c90ea13
+Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
+Date:   Mon Aug 8 15:01:47 2022 -0400
+
+    Create README.md
+
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..28e7c31
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,5 @@
++# CPR101_Project
++CPR101 Final Project
++Section: NAA
++Group 1
++Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh
+
+commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
+Author: rsaguros <rsaguros1@myseneca.ca>
+Date:   Mon Aug 8 13:58:05 2022 -0400
+
+    Update converting.c
+    
+    Version 2
+
+diff --git a/converting.c b/converting.c
+index c5a0775..df23173 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,6 @@
+ // CONVERTING MODULE SOURCE
+ /*
+-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
+ converting.c : CONVERTING
+ Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+ */
+@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
+ // strings and convert a string to an integer value.
+ #include "converting.h"
+ 
+-// V1
+ void converting(void) {
++	// V1
+ 	// Display beginning message
+ 	printf("*** Start of Converting Strings to int Demo ***\n");
+ 
+@@ -38,6 +38,30 @@ void converting(void) {
+ 		}
+ 	} while (strcmp(intString, "q") != 0);
+ 
+-	// Display ending message and exit module.
++	// Display ending message for int demo
+ 	printf("*** End of Converting Strings to int Demo ***\n\n");
++
++	// V2
++	printf("*** Start of Converting Strings to double Demo ***\n");
++
++	char	doubleString[BUFFER_SIZE];
++	double	doubleNumber;
++
++	do {
++		// Prompt user for entry, replacing the new line read by 
++		// fgets with a null terminator
++		printf("Type an double numeric string (q - to quit):\n");
++		fgets(doubleString, BUFFER_SIZE, stdin);
++		doubleString[strlen(doubleString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.  
++		if ((strcmp(doubleString, "q") != 0)) {
++
++			// Convert user entry from numeric string to a double, then display it
++			doubleNumber = atof(doubleString);
++			printf("Converted number is %f\n", doubleNumber);
++		}
++	} while (strcmp(doubleString, "q") != 0);
++
++	printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+
+commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 13:43:58 2022 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 953e516..9193243 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -41,7 +41,7 @@ void manipulating(void) {
+ 	do {
+ 		printf("Type the 1st string to compare (q - to quit):\n");
+ 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+ 			printf("Type the 2nd string to compare:\n");
+ 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+
+commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
+Author: krpm <mungcalrina@gmail.com>
+Date:   Mon Aug 8 12:51:35 2022 -0400
+
+    Version 2
+    
+    Updated main for version 2
+
+diff --git a/main.c b/main.c
+index 755b397..70aeeb7 100644
+--- a/main.c
++++ b/main.c
+@@ -1,6 +1,6 @@
+ // MAIN 
+ /*
+-Author: BB01, 03/08/2022, CPR101, Final Project V1
++Author: BB01, 03/08/2022, CPR101, Final Project
+ main.c : MAIN
+ Purpose: Main Function used to prompt user for which various options.
+ */
+
+commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Mon Aug 8 09:38:48 2022 -0500
+
+    Version 2
+    
+    Added version 2 codes
+
+diff --git a/manipulating.c b/manipulating.c
+index 9bde2d2..953e516 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
+ #include "manipulating.h" 
+ /* Contains function prototypes and library declarations */
+ 
++// V1
+ void manipulating(void) {
+ /* Purpose: This function concatenates 2 input strings */
+ 
+@@ -19,16 +20,40 @@ void manipulating(void) {
+ 
+ 	do {
+ 		printf("Type the 1st string (q - to quit):\n");
+-		fgets(string1, BUFFER_SIZE, stdin);
+-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
++		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
+ 
+ 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+ 			printf("Type the 2nd string:\n");
+-			fgets(string2, BUFFER_SIZE, stdin);
++			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+ 			strcat(string1, string2);
+ 			printf("Concatenated string is \'%s\'\n", string1);
+ 		}
+ 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+ 
+ 	printf("*** End of Concatenating Strings Demo ***\n");
++
++//V2
++	printf("*** Start of Comparing Strings Demo ***\n");
++	char compare1[BUFFER_SIZE];
++	char compare2[BUFFER_SIZE];
++	int result;
++	do {
++		printf("Type the 1st string to compare (q - to quit):\n");
++		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
++		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
++		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
++			printf("Type the 2nd string to compare:\n");
++			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
++			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
++			result = strcmp(compare1, compare2);	// Compare the 2 strings
++			if (result < 0)
++				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
++			else if (result == 0)
++				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
++			else
++				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
++		}
++	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
++	printf("*** End of Comparing Strings Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
+Author: kiararina <kiararina.pelenio@upou.edu.ph>
+Date:   Thu Aug 4 15:34:34 2022 -0500
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 748c895..9bde2d2 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,5 +1,5 @@
+ /*
+-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+ manipulating.c : Manipulating
+ Purpose: This program manipulates input strings
+ */
+
+commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 16:30:00 2022 -0400
+
+    Version 1
+
+diff --git a/Programming Comments.docx b/Programming Comments.docx
+new file mode 100644
+index 0000000..07d1cd7
+--- /dev/null
++++ b/Programming Comments.docx	
+@@ -0,0 +1,110 @@
++                        Commenting Program Source Code
++--------------------------------------------------------------------------------
++Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
++--------------------------------------------------------------------------------
++In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
++Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
++Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
++Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
++Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
++You know you have good comments if you delete all the code and what's left still makes sense as a program.
++Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
++75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
++Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
++Comments are for programmers who will maintain the code in the future. 
++Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
++Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
++--------------------------------------------------------------------------------
++Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
++--------------------------------------------------------------------------------
++
++Organisation of Comments
++Program comments 
++ -  appear at the beginning of a source file.
++/* 
++Author: Name, email, ID, Date written, Course, Project
++[executable filename] : [title of program]
++Purpose: [what this program does, what problem does it solve?]
++*/
++
++Function comments
++The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
++/*
++Purpose: [what this function does, what problem does it solve?]
++Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
++Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
++Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
++*/
++
++Inline code comments
++Your comment must say something different than explaining the code itself. 
++c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
++Ideally, variable names should be self-explanatory. When they are not, comments are required.
++c = a + b;  // c stores total of assignment and test marks respectively.
++
++Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
++cryptic = C + code; 		// explain this line's purpose in the program
++crypticly = C + moreCode;	// explain this line's purpose in the program
++
++Longer code comments
++Sometimes comments need more space than would fit inline. 
++cryptic = C + code;
++// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
++moreCrypticly = C + moreCode;	
++
++Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
++// this comment explains the purpose of the next line of code  
++cryptic = C + code;
++ 		
++// this comment explains the purpose of the next line of code  
++moreCrypticly = C + moreCode;	
++		
++
++Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
++
++Structures
++Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
++// [what the structure accomplishes]
++e.g. 
++// compute factorial	
++// prompt user until value within range 1  -  100 is input
++Code Samples
++printf("Type a few words separated by space(q - to quit):\n");
++gets(words);
++while (strcmp(words, "q") != 0) 
++{
++    word = strtok(words, " ");
++    w_counter = 1;
++    while (word) 
++    {
++        printf("Word #%d is \'%s\'\n", w_counter++, word);
++        word = strtok(NULL, " ");
++    }
++    printf("Type a few words separated by space(q - to quit):\n");
++    gets(words);
++}
++
++ the first while continues until the 'words' variable is equal to "q". What is it for?
++ there is another while {structure} ... what does it do?
++ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
++ // keep looping until pointer is NULL
++This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
++ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
++ This technique is even more important at the end of a series nested structures, e.g.
++      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
++   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
++} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
++
++
++Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
++
++while (TRUE) // a comment explains why there is no exit condition here
++{
++ 	. . .
++   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
++   // --------- ********   make it visually obvious that this causes another iteration of the structure
++. . .
++   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
++   // --------- *****      make it visually obvious that this is an exit from the structure
++. . .
++}
+diff --git a/converting.c b/converting.c
+new file mode 100644
+index 0000000..c5a0775
+--- /dev/null
++++ b/converting.c
+@@ -0,0 +1,43 @@
++// CONVERTING MODULE SOURCE
++/*
++Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
++converting.c : CONVERTING
++Purpose: This program converts integer numeric strings inputted by the user to an integer value.
++*/
++
++#define	_CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
++// strings and convert a string to an integer value.
++#include "converting.h"
++
++// V1
++void converting(void) {
++	// Display beginning message
++	printf("*** Start of Converting Strings to int Demo ***\n");
++
++	// Declare variables
++	char	intString[BUFFER_SIZE];
++	int		intNumber;
++
++	do {
++		// Prompt user for entry
++		printf("Type an int numeric string (q - to quit):\n");
++		fgets(intString, BUFFER_SIZE, stdin);
++		intString[strlen(intString) - 1] = '\0';
++
++		// Check user input, exit if 'q' was entered.
++		if (strcmp(intString, "q") != 0) {
++
++			// Convert user entry from string to integer value.
++			intNumber = atoi(intString);
++
++			// Display converted number.
++			printf("Converted number is %d\n", intNumber);
++		}
++	} while (strcmp(intString, "q") != 0);
++
++	// Display ending message and exit module.
++	printf("*** End of Converting Strings to int Demo ***\n\n");
++}
+diff --git a/converting.h b/converting.h
+new file mode 100644
+index 0000000..03c62a3
+--- /dev/null
++++ b/converting.h
+@@ -0,0 +1,18 @@
++// CONVERTING MODULE HEADER
++#ifndef _CONVERTING_H_
++#define _CONVERTING_H_
++
++// Libraries
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++
++
++/////////////////////////
++// Prototype  Function //
++/////////////////////////
++
++// Function used to apply conversions
++void converting(void);
++
++#endif
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..95c9f23
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,43 @@
++/*
++Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
++fundamentals.c : indexing
++Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
++*/
++
++
++// FUNDAMENTALS MODULE SOURCE 
++#define _CRT_SECURE_NO_WARNINGS 
++#define BUFFER_SIZE 80
++#define NUM_INPUT_SIZE 10 
++#include "fundamentals.h"
++
++
++void fundamentals(void) {
++
++// V1
++    printf("*** start of Indexing Strings Demo ***\n"); 
++    char buffer1[BUFFER_SIZE]; 
++    char numInput[NUM_INPUT_SIZE]; 
++    size_t position; 
++    do {
++        printf("Type not empty string (q - to quit): \n"); 
++        fgets (buffer1, BUFFER_SIZE, stdin); 
++        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
++
++        // checks if entered string is not equals to 'q'.
++        if (strcmp (buffer1, "q") != 0) { 
++            printf("Type the character position within the string: \n"); 
++            fgets (numInput, NUM_INPUT_SIZE, stdin); 
++            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
++            position = atoi (numInput); // Converts entered string to integer.
++
++            // Checks if converted integer is larger then string length and assigns max position if true.
++            if (position >= strlen (buffer1)) { 
++                position = strlen (buffer1) - 1; 
++                printf("Too big... Position reduced to max. availbale\n");
++            }
++            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
++        }
++    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
++    printf("*** End of Indexing Strings Demo ***\n\n");
++}
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..0433660
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,12 @@
++// FUNDAMENTALS MODULE HEADER 
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++
++#include <stdio.h> 
++#include <stdlib.h> 
++#include <string.h>
++
++//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
++void fundamentals(void);
++
++#endif
+\ No newline at end of file
+diff --git a/main.c b/main.c
+new file mode 100644
+index 0000000..755b397
+--- /dev/null
++++ b/main.c
+@@ -0,0 +1,58 @@
++// MAIN 
++/*
++Author: BB01, 03/08/2022, CPR101, Final Project V1
++main.c : MAIN
++Purpose: Main Function used to prompt user for which various options.
++*/
++
++// Include all necessary modules
++#define _CRT_SECURE_NO_WARNINGS
++#include "fundamentals.h"
++#include "manipulating.h"
++#include "converting.h"
++#include "tokenizing.h"
++
++int main(void) {
++	// Declare variables
++	char buff[10];
++
++	// Open menu for user
++	do {
++		// Display menu options
++		printf("1 - Fundamentals\n");
++		printf("2 - Manipulation\n");
++		printf("3 - Converting\n");
++		printf("4 - Tokenizing\n");
++		printf("0 - Exit\n");
++		
++		// Prompt user for input
++		printf("Which module to run? \n");
++		fgets(buff, 10, stdin);
++
++		// Analyze user entry and match selection
++		switch (buff[0])
++		{
++		case '1': 
++			// Call for fundamentals module
++			fundamentals();
++			break;
++
++		case '2': 
++			// Call for manipulating module
++			manipulating();
++			break;
++
++		case '3': 
++			// Call for converting module
++			converting();
++			break;
++
++		case '4': 
++			// Call for tokenizing module
++			tokenizing();
++			break;
++		}
++	} while (buff[0] != '0');
++	
++	return 0;
++}
+\ No newline at end of file
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..748c895
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,34 @@
++/*
++Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
++manipulating.c : Manipulating
++Purpose: This program manipulates input strings
++*/
++
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
++
++#include "manipulating.h" 
++/* Contains function prototypes and library declarations */
++
++void manipulating(void) {
++/* Purpose: This function concatenates 2 input strings */
++
++	printf("*** Start of Concatenating Strings Demo ***\n");
++	char string1[BUFFER_SIZE];
++	char string2[BUFFER_SIZE];
++
++	do {
++		printf("Type the 1st string (q - to quit):\n");
++		fgets(string1, BUFFER_SIZE, stdin);
++		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
++
++		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
++			printf("Type the 2nd string:\n");
++			fgets(string2, BUFFER_SIZE, stdin);
++			strcat(string1, string2);
++			printf("Concatenated string is \'%s\'\n", string1);
++		}
++	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
++
++	printf("*** End of Concatenating Strings Demo ***\n");
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..8a8f926
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,11 @@
++//MANIPULATING MODULE HEADER
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>		// For input/output and printing
++#include <string.h>		// For string manipulation functions
++
++void manipulating(void);
++/* Purpose: This function concatenates 2 input strings */
++
++#endif
+diff --git a/tokenizing.c b/tokenizing.c
+new file mode 100644
+index 0000000..65d1c20
+--- /dev/null
++++ b/tokenizing.c
+@@ -0,0 +1,42 @@
++/*
++Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
++[tokenizing.c] : [tokenizing]
++Purpose: [This function takes a user inputted string and tokenizes it]
++*/
++
++
++// TOKENIZING MODULE SOURCE
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
++#include "tokenizing.h"
++
++// V1
++void tokenizing(void) {
++
++    printf("*** Start of Tokenizing Words Demo ***\n");
++    char words[BUFFER_SIZE];
++    char* nextWord = NULL;
++    int wordsCounter;
++    do {
++        printf("Type a few words seperated by space (q - to quit):\n");
++
++        fgets(words, BUFFER_SIZE, stdin); 
++        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
++
++        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
++            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
++            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
++
++        
++    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
++            while (nextWord) {
++                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
++                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
++            }
++        }
++    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
++
++    printf("*** End of Tokenizing Words Demo ***\n\n");
++}
++
++
+diff --git a/tokenizing.h b/tokenizing.h
+new file mode 100644
+index 0000000..c00f3cb
+--- /dev/null
++++ b/tokenizing.h
+@@ -0,0 +1,10 @@
++// Tokenization header file
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h>
++#include <string.h>
++
++void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
++
++#endif
+\ No newline at end of file
+
+commit f914d3afae4107c77728b3df4d39502c962ba74b
+Author: krpm <mungcalrina@gmail.com>
+Date:   Thu Aug 4 15:48:50 2022 -0400
+
+    Initial commit
+
+diff --git a/.gitattributes b/.gitattributes
+new file mode 100644
+index 0000000..dfe0770
+--- /dev/null
++++ b/.gitattributes
+@@ -0,0 +1,2 @@
++# Auto detect text files and perform LF normalization
++* text=auto

commit 2c1a196520fc9a4a0769be50a5cb584c9c68eef3
Merge: 6361388 c3a8316
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Tue Aug 9 22:49:17 2022 -0400

    Merge branch 'main' of https://github.com/kiararina/CPR101_Project

commit 63613886b8f1ecccb62538d6d4b7905425a16358
Merge: 0626d2e c0f7dc8
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Tue Aug 9 22:47:37 2022 -0400

    Merge branch 'main' of https://github.com/kiararina/CPR101_Project

commit c3a831696d320ac9100ed65017dacd96abb6c7c0
Merge: 9d98950 c0f7dc8
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Tue Aug 9 22:46:28 2022 -0400

    Merge branch 'main' of https://github.com/kiararina/CPR101_Project

commit c0f7dc86b8b8eff844c9d6f812b182ace16375c5
Merge: fd97b97 a2a1bf4
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Tue Aug 9 22:44:47 2022 -0400

    Merge pull request #1 from kiararina/converting
    
    Recovering lost commits up to converting.c

commit a2a1bf49068ea4694c4a882a94fd723be1f44f5f
Merge: cee497d fd97b97
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Tue Aug 9 22:44:00 2022 -0400

    Merge branch 'main' into converting

commit 9d989506a3dcbcf51ca68b5f2cf4f0096b4b705e
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Tue Aug 9 19:23:44 2022 -0400

    tokenizing.c v2 corrected
    
    Corrected a previous error, now both v1 and v2 are within the same function name

diff --git a/tokenizing.c b/tokenizing.c
index 6332b6d..ae26066 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -12,11 +12,9 @@ Purpose: [This function takes a user inputted string and tokenizes it]
 
 
 
+void tokenizing(void) {
 
-/*
-// V1
-//void tokenizing(void) {
-
+    // V1
     printf("*** Start of Tokenizing Words Demo ***\n");
     char words[BUFFER_SIZE];
     char* nextWord = NULL;
@@ -24,7 +22,7 @@ Purpose: [This function takes a user inputted string and tokenizes it]
     do {
         printf("Type a few words seperated by space (q - to quit):\n");
 
-        fgets(words, BUFFER_SIZE, stdin); 
+        fgets(words, BUFFER_SIZE, stdin);
         words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
 
         if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
@@ -33,21 +31,17 @@ Purpose: [This function takes a user inputted string and tokenizes it]
 
     //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
             while (nextWord) {
-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord);
                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
             }
-       }
+        }
     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
 
     printf("*** End of Tokenizing Words Demo ***\n\n");
-}
-*/
 
 
-// V2
-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-void tokenizing(void) {
-
+    // V2
+    /* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
     printf("*** Start of Tokenizing Words Demo ***\n");
     char phrases[BUFFER_SIZE];
     char* nextPhrase = NULL;

commit 23f162166b815502c16ac1456d8f9be87b799f26
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Tue Aug 9 19:09:02 2022 -0400

    Update tokenizing.c to V2

diff --git a/tokenizing.c b/tokenizing.c
index edc3184..6332b6d 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,5 +1,5 @@
 /*
-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
 [tokenizing.c] : [tokenizing]
 Purpose: [This function takes a user inputted string and tokenizes it]
 */
@@ -11,14 +11,11 @@ Purpose: [This function takes a user inputted string and tokenizes it]
 #include "tokenizing.h"
 
 
-int main(void) {
-    tokenizing();
-    return 0;
-}
 
 
+/*
 // V1
-void tokenizing(void) {
+//void tokenizing(void) {
 
     printf("*** Start of Tokenizing Words Demo ***\n");
     char words[BUFFER_SIZE];
@@ -34,16 +31,46 @@ void tokenizing(void) {
             nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
             wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
 
-        
-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
             while (nextWord) {
                 printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
                 nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
             }
-        }
+       }
     } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
 
     printf("*** End of Tokenizing Words Demo ***\n\n");
 }
+*/
+
+
+// V2
+/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+void tokenizing(void) {
+
+    printf("*** Start of Tokenizing Words Demo ***\n");
+    char phrases[BUFFER_SIZE];
+    char* nextPhrase = NULL;
+    int phrasesCounter;
+    do {
+        printf("Type a few words seperated by comma (q - to quit):\n");
+
+        fgets(phrases, BUFFER_SIZE, stdin); 
+        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+
+        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+
+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+            while (nextPhrase) {
+                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+            }
+        }
+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+
+    printf("*** End of Tokenizing Words Demo ***\n\n");
+}
 
 

commit 836f1b849b1e87ed0e15532ad59d88e090ea8384
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Tue Aug 9 19:06:55 2022 -0400

    V1

diff --git a/tokenizing.c b/tokenizing.c
index 417d34a..edc3184 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,80 +1,49 @@
-/*
-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
-[tokenizing.c] : [tokenizing]
-Purpose: [This function takes a user inputted string and tokenizes it]
-*/
-
-
-// TOKENIZING MODULE SOURCE
-#define _CRT_SECURE_NO_WARNINGS
-#define BUFFER_SIZE 300
-#include "tokenizing.h"
-
-
-int main(void) {
-    tokenizing();
-    return 0;
-}
-
-
-/*
-// V1
-//void tokenizing(void) {
-
-    printf("*** Start of Tokenizing Words Demo ***\n");
-    char words[BUFFER_SIZE];
-    char* nextWord = NULL;
-    int wordsCounter;
-    do {
-        printf("Type a few words seperated by space (q - to quit):\n");
-
-        fgets(words, BUFFER_SIZE, stdin); 
-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-
-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-
-    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
-            while (nextWord) {
-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-            }
-       }
-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-
-    printf("*** End of Tokenizing Words Demo ***\n\n");
-}
-*/
-
-
-// V2
-/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
-void tokenizing(void) {
-
-    printf("*** Start of Tokenizing Words Demo ***\n");
-    char phrases[BUFFER_SIZE];
-    char* nextPhrase = NULL;
-    int phrasesCounter;
-    do {
-        printf("Type a few words seperated by comma (q - to quit):\n");
-
-        fgets(phrases, BUFFER_SIZE, stdin); 
-        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-
-        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
-            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
-            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-
-    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
-            while (nextPhrase) {
-                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
-                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
-            }
-        }
-    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-
-    printf("*** End of Tokenizing Words Demo ***\n\n");
-}
-
-
+/*
+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+[tokenizing.c] : [tokenizing]
+Purpose: [This function takes a user inputted string and tokenizes it]
+*/
+
+
+// TOKENIZING MODULE SOURCE
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 300
+#include "tokenizing.h"
+
+
+int main(void) {
+    tokenizing();
+    return 0;
+}
+
+
+// V1
+void tokenizing(void) {
+
+    printf("*** Start of Tokenizing Words Demo ***\n");
+    char words[BUFFER_SIZE];
+    char* nextWord = NULL;
+    int wordsCounter;
+    do {
+        printf("Type a few words seperated by space (q - to quit):\n");
+
+        fgets(words, BUFFER_SIZE, stdin); 
+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+
+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+
+        
+    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+            while (nextWord) {
+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+            }
+        }
+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+
+    printf("*** End of Tokenizing Words Demo ***\n\n");
+}
+
+

commit fd97b97f1b60eb40a7fe8fdc9d503c2654a4c41e
Author: CRYPTO43 <singharshjot07@gmail.com>
Date:   Tue Aug 9 17:12:27 2022 -0400

    first commit

diff --git a/fundamentals.c b/fundamentals.c
new file mode 100644
index 0000000..cd7cd9f
--- /dev/null
+++ b/fundamentals.c
@@ -0,0 +1,63 @@
+/*
+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+fundamentals.c : indexing
+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+*/
+
+
+// FUNDAMENTALS MODULE SOURCE 
+#define _CRT_SECURE_NO_WARNINGS 
+#define BUFFER_SIZE 80
+#define NUM_INPUT_SIZE 10 
+#include "fundamentals.h"
+
+
+void main(void) {
+
+// V1
+    printf("*** start of Indexing Strings Demo ***\n"); 
+    char buffer1[BUFFER_SIZE]; 
+    char numInput[NUM_INPUT_SIZE]; 
+    size_t position; 
+    do {
+        printf("Type not empty string (q - to quit): \n"); 
+        fgets (buffer1, BUFFER_SIZE, stdin); 
+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+
+        // checks if entered string is not equals to 'q'.
+        if (strcmp (buffer1, "q") != 0) { 
+            printf("Type the character position within the string: \n"); 
+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+            position = atoi (numInput); // Converts entered string to integer.
+
+            // Checks if converted integer is larger then string length and assigns max position if true.
+            if (position >= strlen (buffer1)) { 
+                position = strlen (buffer1) - 1; 
+                printf("Too big... Position reduced to max. availbale\n");
+            }
+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+        }
+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+    printf("*** End of Indexing Strings Demo ***\n\n");
+
+
+
+    // V2 
+    printf("*** Start of Measuring Strings Demo ***\n"); 
+    char buffer2[BUFFER_SIZE]; 
+    do { 
+        printf("Type a string (q - to quit):\n"); 
+        fgets(buffer2, BUFFER_SIZE, stdin); //Gets the user entered string
+        buffer2[strlen(buffer2) - 1] = '\0'; // Replaces user entered newline with null terminator 
+
+        // checks if entered string is not equals to 'q'.
+        if (strcmp(buffer2, "q") != 0) 
+            printf("The length of \'%s\' is %d characters\n", 
+            buffer2, (int)strlen(buffer2)); 
+        } while (strcmp(buffer2, "q") != 0); //Loops till user enters 'q'
+        
+        printf("*** End of Measuring Strings Demo ***\n\n");
+}
+
+ 
\ No newline at end of file
diff --git a/fundamentals.h b/fundamentals.h
new file mode 100644
index 0000000..383cccc
--- /dev/null
+++ b/fundamentals.h
@@ -0,0 +1,12 @@
+// FUNDAMENTALS MODULE HEADER 
+#ifndef _FUNDAMENTALS_H_
+#define _FUNDAMENTALS_H_
+
+#include <stdio.h> 
+#include <stdlib.h> 
+#include <string.h>
+
+//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+void main(void);
+
+#endif
\ No newline at end of file

commit 425a7ac33f432099cac3faa3a90bb69daf84067f
Author: jt-tn <105021616+jt-tn@users.noreply.github.com>
Date:   Tue Aug 9 16:17:34 2022 -0400

    Add files via upload
    
    Version 2

diff --git a/tokenizing.c b/tokenizing.c
index 65d1c20..417d34a 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,42 +1,80 @@
-/*
-Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
-[tokenizing.c] : [tokenizing]
-Purpose: [This function takes a user inputted string and tokenizes it]
-*/
-
-
-// TOKENIZING MODULE SOURCE
-#define _CRT_SECURE_NO_WARNINGS
-#define BUFFER_SIZE 300
-#include "tokenizing.h"
-
-// V1
-void tokenizing(void) {
-
-    printf("*** Start of Tokenizing Words Demo ***\n");
-    char words[BUFFER_SIZE];
-    char* nextWord = NULL;
-    int wordsCounter;
-    do {
-        printf("Type a few words seperated by space (q - to quit):\n");
-
-        fgets(words, BUFFER_SIZE, stdin); 
-        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
-
-        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
-            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
-            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
-
-        
-    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
-            while (nextWord) {
-                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
-                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
-            }
-        }
-    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
-
-    printf("*** End of Tokenizing Words Demo ***\n\n");
-}
-
-
+/*
+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 9/08/2022, CPR101, Final Project V2
+[tokenizing.c] : [tokenizing]
+Purpose: [This function takes a user inputted string and tokenizes it]
+*/
+
+
+// TOKENIZING MODULE SOURCE
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 300
+#include "tokenizing.h"
+
+
+int main(void) {
+    tokenizing();
+    return 0;
+}
+
+
+/*
+// V1
+//void tokenizing(void) {
+
+    printf("*** Start of Tokenizing Words Demo ***\n");
+    char words[BUFFER_SIZE];
+    char* nextWord = NULL;
+    int wordsCounter;
+    do {
+        printf("Type a few words seperated by space (q - to quit):\n");
+
+        fgets(words, BUFFER_SIZE, stdin); 
+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+
+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+
+    //  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized 
+            while (nextWord) {
+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+            }
+       }
+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+
+    printf("*** End of Tokenizing Words Demo ***\n\n");
+}
+*/
+
+
+// V2
+/* Did not modify the logic, but changed the delimiter from a single empty space(" ") to a single comma(",") */
+void tokenizing(void) {
+
+    printf("*** Start of Tokenizing Words Demo ***\n");
+    char phrases[BUFFER_SIZE];
+    char* nextPhrase = NULL;
+    int phrasesCounter;
+    do {
+        printf("Type a few words seperated by comma (q - to quit):\n");
+
+        fgets(phrases, BUFFER_SIZE, stdin); 
+        phrases[strlen(phrases) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+
+        if ((strcmp(phrases, "q") != 0)) { // only executes if user did not input 'q'
+            nextPhrase = strtok(phrases, ","); // use a commas as the delimiter to know when to split the string into tokens
+            phrasesCounter = 1; // intialize phrasesCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+
+    //  use a loop to print out the string, while incrementing phrasesCounter to keep track of the number of words being tokenized 
+            while (nextPhrase) {
+                printf("Word #%d is \'%s\'\n", phrasesCounter++, nextPhrase); 
+                nextPhrase = strtok(NULL, ","); // when the next value of the string reads as null, we break out of the loop
+            }
+        }
+    } while (strcmp(phrases, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+
+    printf("*** End of Tokenizing Words Demo ***\n\n");
+}
+
+
diff --git a/tokenizing.h b/tokenizing.h
index c00f3cb..7899cc2 100644
--- a/tokenizing.h
+++ b/tokenizing.h
@@ -1,10 +1,10 @@
-// Tokenization header file
-#ifndef _TOKENIZING_H_
-#define _TOKENIZING_H_
-
-#include <stdio.h>
-#include <string.h>
-
-void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
-
+// Tokenization header file
+#ifndef _TOKENIZING_H_
+#define _TOKENIZING_H_
+
+#include <stdio.h>
+#include <string.h>
+
+void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+
 #endif
\ No newline at end of file

commit 0626d2ea0c7c6b63fac1af1faa4ad7cde4e9d547
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Mon Aug 8 15:47:34 2022 -0400

    Version 2
    
    Version 2

diff --git a/converting.c b/converting.c
index c5a0775..df23173 100644
--- a/converting.c
+++ b/converting.c
@@ -1,6 +1,6 @@
 // CONVERTING MODULE SOURCE
 /*
-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
 converting.c : CONVERTING
 Purpose: This program converts integer numeric strings inputted by the user to an integer value.
 */
@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
 // strings and convert a string to an integer value.
 #include "converting.h"
 
-// V1
 void converting(void) {
+	// V1
 	// Display beginning message
 	printf("*** Start of Converting Strings to int Demo ***\n");
 
@@ -38,6 +38,30 @@ void converting(void) {
 		}
 	} while (strcmp(intString, "q") != 0);
 
-	// Display ending message and exit module.
+	// Display ending message for int demo
 	printf("*** End of Converting Strings to int Demo ***\n\n");
+
+	// V2
+	printf("*** Start of Converting Strings to double Demo ***\n");
+
+	char	doubleString[BUFFER_SIZE];
+	double	doubleNumber;
+
+	do {
+		// Prompt user for entry, replacing the new line read by 
+		// fgets with a null terminator
+		printf("Type an double numeric string (q - to quit):\n");
+		fgets(doubleString, BUFFER_SIZE, stdin);
+		doubleString[strlen(doubleString) - 1] = '\0';
+
+		// Check user input, exit if 'q' was entered.  
+		if ((strcmp(doubleString, "q") != 0)) {
+
+			// Convert user entry from numeric string to a double, then display it
+			doubleNumber = atof(doubleString);
+			printf("Converted number is %f\n", doubleNumber);
+		}
+	} while (strcmp(doubleString, "q") != 0);
+
+	printf("*** End of Converting Strings to double Demo ***\n\n");
 }

commit e25ade313038da86c407f85f5c00586ba6b37a1b
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Mon Aug 8 15:05:20 2022 -0400

    Update README.md

diff --git a/README.md b/README.md
index 28e7c31..f1ff45d 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,8 @@
 # CPR101_Project
 CPR101 Final Project
+
 Section: NAA
+
 Group 1
+
 Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh

commit a3e1e5ae394af27b186e61562b7167819c90ea13
Author: rsaguros <104941715+rsaguros@users.noreply.github.com>
Date:   Mon Aug 8 15:01:47 2022 -0400

    Create README.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..28e7c31
--- /dev/null
+++ b/README.md
@@ -0,0 +1,5 @@
+# CPR101_Project
+CPR101 Final Project
+Section: NAA
+Group 1
+Group Members: Kiara Rina Pelenio, Ron Austin Saguros, Jason Tan, Arshjot Singh

commit cee497d0e93443968d5e6e63929dfa5d1dc418cf
Author: rsaguros <rsaguros1@myseneca.ca>
Date:   Mon Aug 8 13:58:05 2022 -0400

    Update converting.c
    
    Version 2

diff --git a/converting.c b/converting.c
index c5a0775..df23173 100644
--- a/converting.c
+++ b/converting.c
@@ -1,6 +1,6 @@
 // CONVERTING MODULE SOURCE
 /*
-Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 06/08/2022, CPR101, Final Project V2
 converting.c : CONVERTING
 Purpose: This program converts integer numeric strings inputted by the user to an integer value.
 */
@@ -12,8 +12,8 @@ Purpose: This program converts integer numeric strings inputted by the user to a
 // strings and convert a string to an integer value.
 #include "converting.h"
 
-// V1
 void converting(void) {
+	// V1
 	// Display beginning message
 	printf("*** Start of Converting Strings to int Demo ***\n");
 
@@ -38,6 +38,30 @@ void converting(void) {
 		}
 	} while (strcmp(intString, "q") != 0);
 
-	// Display ending message and exit module.
+	// Display ending message for int demo
 	printf("*** End of Converting Strings to int Demo ***\n\n");
+
+	// V2
+	printf("*** Start of Converting Strings to double Demo ***\n");
+
+	char	doubleString[BUFFER_SIZE];
+	double	doubleNumber;
+
+	do {
+		// Prompt user for entry, replacing the new line read by 
+		// fgets with a null terminator
+		printf("Type an double numeric string (q - to quit):\n");
+		fgets(doubleString, BUFFER_SIZE, stdin);
+		doubleString[strlen(doubleString) - 1] = '\0';
+
+		// Check user input, exit if 'q' was entered.  
+		if ((strcmp(doubleString, "q") != 0)) {
+
+			// Convert user entry from numeric string to a double, then display it
+			doubleNumber = atof(doubleString);
+			printf("Converted number is %f\n", doubleNumber);
+		}
+	} while (strcmp(doubleString, "q") != 0);
+
+	printf("*** End of Converting Strings to double Demo ***\n\n");
 }

commit bcd42d971ce8c73fc109ae1a4a3f43d46b92b2e2
Author: krpm <mungcalrina@gmail.com>
Date:   Mon Aug 8 13:43:58 2022 -0400

    Update manipulating.c

diff --git a/manipulating.c b/manipulating.c
index 953e516..9193243 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -41,7 +41,7 @@ void manipulating(void) {
 	do {
 		printf("Type the 1st string to compare (q - to quit):\n");
 		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
-		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+		compare1[strlen(compare1) - 1] = '\0';	// Add the null terminator in the end of the string
 		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
 			printf("Type the 2nd string to compare:\n");
 			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input

commit bdfce84a3dcecabd20cf1fdf8642f01dcda0eab7
Author: krpm <mungcalrina@gmail.com>
Date:   Mon Aug 8 12:51:35 2022 -0400

    Version 2
    
    Updated main for version 2

diff --git a/main.c b/main.c
index 755b397..70aeeb7 100644
--- a/main.c
+++ b/main.c
@@ -1,6 +1,6 @@
 // MAIN 
 /*
-Author: BB01, 03/08/2022, CPR101, Final Project V1
+Author: BB01, 03/08/2022, CPR101, Final Project
 main.c : MAIN
 Purpose: Main Function used to prompt user for which various options.
 */

commit df4fbfd427a0f9afa49aed2d8b6221050bcc65d4
Author: kiararina <kiararina.pelenio@upou.edu.ph>
Date:   Mon Aug 8 09:38:48 2022 -0500

    Version 2
    
    Added version 2 codes

diff --git a/manipulating.c b/manipulating.c
index 9bde2d2..953e516 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -1,5 +1,5 @@
 /*
-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/03/2022, CPR101, Final Project
 manipulating.c : Manipulating
 Purpose: This program manipulates input strings
 */
@@ -10,6 +10,7 @@ Purpose: This program manipulates input strings
 #include "manipulating.h" 
 /* Contains function prototypes and library declarations */
 
+// V1
 void manipulating(void) {
 /* Purpose: This function concatenates 2 input strings */
 
@@ -19,16 +20,40 @@ void manipulating(void) {
 
 	do {
 		printf("Type the 1st string (q - to quit):\n");
-		fgets(string1, BUFFER_SIZE, stdin);
-		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+		fgets(string1, BUFFER_SIZE, stdin);		// Get the 1st string input
+		string1[strlen(string1) - 1] = '\0';	// Add the null terminator in the end of the string
 
 		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
 			printf("Type the 2nd string:\n");
-			fgets(string2, BUFFER_SIZE, stdin);
+			fgets(string2, BUFFER_SIZE, stdin);	// Get the 2nd string input
 			strcat(string1, string2);
 			printf("Concatenated string is \'%s\'\n", string1);
 		}
 	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
 
 	printf("*** End of Concatenating Strings Demo ***\n");
+
+//V2
+	printf("*** Start of Comparing Strings Demo ***\n");
+	char compare1[BUFFER_SIZE];
+	char compare2[BUFFER_SIZE];
+	int result;
+	do {
+		printf("Type the 1st string to compare (q - to quit):\n");
+		fgets(compare1, BUFFER_SIZE, stdin);	// Get the 1st string input
+		compare1(strlen(compare1) - 1) = '\0';	// Add the null terminator in the end of the string
+		if (strcmp(compare1, "q") != 0) {		// Check if the user wants to exit the program
+			printf("Type the 2nd string to compare:\n");
+			fgets(compare2, BUFFER_SIZE, stdin);	// Get the 2nd string input
+			compare2[strlen(compare2) - 1] = '\0';	// Add the null terminator in the end of the string
+			result = strcmp(compare1, compare2);	// Compare the 2 strings
+			if (result < 0)
+				printf("\'%s\' string is less than '%s\'\n", compare1, compare2);
+			else if (result == 0)
+				printf("\'%s\' string is equal to '%s\'\n", compare1, compare2);
+			else
+				printf("\'%s\' string is greater than '%s\'\n", compare1, compare2);
+		}
+	} while (strcmp(compare1, "q") != 0);			// Continue while user doesn't want to quit
+	printf("*** End of Comparing Strings Demo ***\n\n");
 }
\ No newline at end of file

commit 72dc811e3e9f74b76928858d87f9c5e0180b6b44
Author: kiararina <kiararina.pelenio@upou.edu.ph>
Date:   Thu Aug 4 15:34:34 2022 -0500

    Update manipulating.c

diff --git a/manipulating.c b/manipulating.c
index 748c895..9bde2d2 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -1,5 +1,5 @@
 /*
-Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 08/01/2022, CPR101, Final Project
 manipulating.c : Manipulating
 Purpose: This program manipulates input strings
 */

commit 9d2fec108e0c3a1218f114f632f0a0999cb35e15
Author: krpm <mungcalrina@gmail.com>
Date:   Thu Aug 4 16:30:00 2022 -0400

    Version 1

diff --git a/Programming Comments.docx b/Programming Comments.docx
new file mode 100644
index 0000000..07d1cd7
--- /dev/null
+++ b/Programming Comments.docx	
@@ -0,0 +1,110 @@
+                        Commenting Program Source Code
+--------------------------------------------------------------------------------
+Custom .h files deserve comments to remind us what the library/constant/etc. is, why it is used here, and why a programmer went to the trouble of creating a .h file instead of putting it all in the .c source file.
+--------------------------------------------------------------------------------
+In the .c source code file, on the #include custom.h statement, give a summary of the .h file so the reader knows why it is there...without having to open and look inside the .h file.
+Comment the program, not the code. Anyone reading a source file will be a programmer  -  they don't need individual lines of code explained! If they want to know how the code works, they will read the code. The reader wants to know the relationship this line of code has to the rest of the program.
+Comment on the purpose: Why was this program, function, structure, or line of code written in the first place? What does it do in service of the needs, goals, or intent of the user? It may help to consider "What part of the story will this line of code tell?"
+Comment on the relationship this line of code has to the rest of the program. (E.g. it stores a value that comes from the user, or that the program calculates), the mechanism that controls looping (e.g. describe how the loop/program knows when to stop), and/or if a line of code changes the state of the program [HYPERLINK: https://en.wikipedia.org/wiki/State_(computer_science)] (e.g. any assignment = statement). It may help to consider what would happen if the line was removed from the program.
+Do describe program operation in terms of how it interacts with the user (the user is the input source and output target outside the system boundary). In what way does the program process / transform the input to satisfy the user's purpose and meet the user's objective?
+You know you have good comments if you delete all the code and what's left still makes sense as a program.
+Spelling counts. Clarity in communication and respect for the reader shows your attention to detail. Mist stakes imply acyurasee does nt madder to you  -  wy shud the reeder trist your coed? If the code is as well written as the comments, things are likely to be good, or very very bad.
+75% of IT coding budgets are spent on maintenance. During new programming development (the remaining 25% of coding budgets), comments are often extensive; they explain the intent of the code to be written, its purpose, the reasoning behind the logic to be implemented. Yes, the comments are written before the code. Development comments should satisfy the mythical DoWIM compiler: the "Do What I Mean" compiler ignores code and compiles comments.
+Comments are for your future self at 4am when you've been called out of bed to fix a program crash.
+Comments are for programmers who will maintain the code in the future. 
+Comments are read only by IT professionals who may very well know the language better than you. You don't need to explain the code. If they want to know how the code works, they will read the code. Most of the time, they want to know IF this is the source file they should be working on, the purpose of the program in general, what service that a function provides, and in the case of individual structures (a loop, a series of nested IF  -  ELSE), what the structure accomplishes.
+Comments should be brief and informative. One or two phrases takes one or two seconds to read. A few lines of code can take minutes to analyse, compile in one's head, imagine a walkthrough, check the results, and still not be understand completely.
+--------------------------------------------------------------------------------
+Without good comments, the code is neither acceptable nor economically maintainable in a professional environment.
+--------------------------------------------------------------------------------
+
+Organisation of Comments
+Program comments 
+ -  appear at the beginning of a source file.
+/* 
+Author: Name, email, ID, Date written, Course, Project
+[executable filename] : [title of program]
+Purpose: [what this program does, what problem does it solve?]
+*/
+
+Function comments
+The function's name should serve as the title / purpose of the function. The following comment(s) appear after the function() declaration and above the function's code.
+/*
+Purpose: [what this function does, what problem does it solve?]
+Parameters: Include only if needed to explain values passed when called. Ideally, parameter names are self-explanatory.
+Returns: Include and explain if not void. Nobody wants to read through your code to discover all the different values for int that the function returns or what those values mean.
+Modifies: Include and explain if values in global variables or variables with pointers (pass by reference) are changed. This is a critical comment for future maintenance. Everyone does not notice that a variable modified in the body of the function is not in the parameter list (global variable), nor do they scour the function's parameter list for an *asterisk (pointer). Information hiding [HYPERLINK: https://en.wikipedia.org/wiki/Information_hiding] is assumed in functions: the function is expected to be a "black box [HYPERLINK: https://en.wikipedia.org/wiki/Black_box]" which does not change the state of anything outside the function. If that is not the case, the function has "side effects [HYPERLINK: https://en.wikipedia.org/wiki/Side_effect_(computer_science)]" and that must be clearly documented.
+*/
+
+Inline code comments
+Your comment must say something different than explaining the code itself. 
+c = a + b;   // that c is the sum of a and b is obvious. That is what the code says; it does not need to be explained to a C programmer. 
+Ideally, variable names should be self-explanatory. When they are not, comments are required.
+c = a + b;  // c stores total of assignment and test marks respectively.
+
+Inline comments are placed on the same line as the code, tabbed to stand apart from the code. This format makes it easy to see the code and the comments, separately (vertically) or together (horizontally).
+cryptic = C + code; 		// explain this line's purpose in the program
+crypticly = C + moreCode;	// explain this line's purpose in the program
+
+Longer code comments
+Sometimes comments need more space than would fit inline. 
+cryptic = C + code;
+// Does this comment relate to the line above or below? We cannot know without analysing both lines of code which defeats the purpose of commenting.   
+moreCrypticly = C + moreCode;	
+
+Use vertical spacing to group the code and comments together. Be consistent in placing your whole line comment immediately above the related code which is the preferred style.
+// this comment explains the purpose of the next line of code  
+cryptic = C + code;
+ 		
+// this comment explains the purpose of the next line of code  
+moreCrypticly = C + moreCode;	
+		
+
+Never reference a line number in source comments. One inserted/deleted newline at the top of the source file and your comments are all broken.
+
+Structures
+Commenting of a { structure } states its purpose, so the reader does not have to analyse multiple lines of code to see how they work together to accomplish something.
+// [what the structure accomplishes]
+e.g. 
+// compute factorial	
+// prompt user until value within range 1  -  100 is input
+Code Samples
+printf("Type a few words separated by space(q - to quit):\n");
+gets(words);
+while (strcmp(words, "q") != 0) 
+{
+    word = strtok(words, " ");
+    w_counter = 1;
+    while (word) 
+    {
+        printf("Word #%d is \'%s\'\n", w_counter++, word);
+        word = strtok(NULL, " ");
+    }
+    printf("Type a few words separated by space(q - to quit):\n");
+    gets(words);
+}
+
+ the first while continues until the 'words' variable is equal to "q". What is it for?
+ there is another while {structure} ... what does it do?
+ How does it know when to stop looping? 'word' does not seem like a self-explanatory boolean.
+ // keep looping until pointer is NULL
+This just says what the code says. It should explain what work the while loop accomplishes -- think in terms of a specification/instruction an analyst would write to tell a programmer what code to create.
+ }   This is the end of scope for which structure? If the code above it scrolls off the screen and all the programmer sees is } (a right brace), they either must remember the previous screen (not likely), or page up to see the preceding code (too much bother), or you could enter a comment (which they will appreciate).
+ This technique is even more important at the end of a series nested structures, e.g.
+      } // I know what you're thinking: "Is the end of the IF structure or one of the nested loops?"
+   } // Well, to tell you the truth, in all this excitement, I've kinda lost track myself.
+} // But being this is C, the most powerful programming language in the world, which could blow up your weekend, you've got to ask yourself one question: `Do I feel lucky?' Well, do ya?
+
+
+Unusually written code must be commented. A structure such as  while (TRUE)  { ... } is unconventional. It is obviously intended as an infinite loop. What is its exit condition? There must be a break within its scope. But where?
+
+while (TRUE) // a comment explains why there is no exit condition here
+{
+ 	. . .
+   if ( . . . ) continue; // don't explain the code. Tell why the program repeats the structure here.
+   // --------- ********   make it visually obvious that this causes another iteration of the structure
+. . .
+   if ( . . . ) break;    // don't explain the code. Tell why the program exits the structure here.
+   // --------- *****      make it visually obvious that this is an exit from the structure
+. . .
+}
diff --git a/converting.c b/converting.c
new file mode 100644
index 0000000..c5a0775
--- /dev/null
+++ b/converting.c
@@ -0,0 +1,43 @@
+// CONVERTING MODULE SOURCE
+/*
+Author: Ron Austin Saguros, rsaguros1@myseneca.ca, 111045225, 31/07/2022, CPR101, Final Project V1
+converting.c : CONVERTING
+Purpose: This program converts integer numeric strings inputted by the user to an integer value.
+*/
+
+#define	_CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 80
+
+// Includes all the necessary functions from stdio.h, string.h, and stdlib.h needed to manipulate
+// strings and convert a string to an integer value.
+#include "converting.h"
+
+// V1
+void converting(void) {
+	// Display beginning message
+	printf("*** Start of Converting Strings to int Demo ***\n");
+
+	// Declare variables
+	char	intString[BUFFER_SIZE];
+	int		intNumber;
+
+	do {
+		// Prompt user for entry
+		printf("Type an int numeric string (q - to quit):\n");
+		fgets(intString, BUFFER_SIZE, stdin);
+		intString[strlen(intString) - 1] = '\0';
+
+		// Check user input, exit if 'q' was entered.
+		if (strcmp(intString, "q") != 0) {
+
+			// Convert user entry from string to integer value.
+			intNumber = atoi(intString);
+
+			// Display converted number.
+			printf("Converted number is %d\n", intNumber);
+		}
+	} while (strcmp(intString, "q") != 0);
+
+	// Display ending message and exit module.
+	printf("*** End of Converting Strings to int Demo ***\n\n");
+}
diff --git a/converting.h b/converting.h
new file mode 100644
index 0000000..03c62a3
--- /dev/null
+++ b/converting.h
@@ -0,0 +1,18 @@
+// CONVERTING MODULE HEADER
+#ifndef _CONVERTING_H_
+#define _CONVERTING_H_
+
+// Libraries
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+
+/////////////////////////
+// Prototype  Function //
+/////////////////////////
+
+// Function used to apply conversions
+void converting(void);
+
+#endif
diff --git a/fundamentals.c b/fundamentals.c
new file mode 100644
index 0000000..95c9f23
--- /dev/null
+++ b/fundamentals.c
@@ -0,0 +1,43 @@
+/*
+Author: Arshjot Singh, asingh1185@myseneca.ca, #164126211, 02/08/2022, CPR101, Final Project V1
+fundamentals.c : indexing
+Purpose: Takes non-empty string and a number as input and gives the character at that number(index) as output.
+*/
+
+
+// FUNDAMENTALS MODULE SOURCE 
+#define _CRT_SECURE_NO_WARNINGS 
+#define BUFFER_SIZE 80
+#define NUM_INPUT_SIZE 10 
+#include "fundamentals.h"
+
+
+void fundamentals(void) {
+
+// V1
+    printf("*** start of Indexing Strings Demo ***\n"); 
+    char buffer1[BUFFER_SIZE]; 
+    char numInput[NUM_INPUT_SIZE]; 
+    size_t position; 
+    do {
+        printf("Type not empty string (q - to quit): \n"); 
+        fgets (buffer1, BUFFER_SIZE, stdin); 
+        buffer1[strlen (buffer1) - 1] = '\0'; // Replaces user entered newline with null terminator
+
+        // checks if entered string is not equals to 'q'.
+        if (strcmp (buffer1, "q") != 0) { 
+            printf("Type the character position within the string: \n"); 
+            fgets (numInput, NUM_INPUT_SIZE, stdin); 
+            numInput[strlen (numInput) - 1] = '\0'; // Replaces user entered newline with null terminator
+            position = atoi (numInput); // Converts entered string to integer.
+
+            // Checks if converted integer is larger then string length and assigns max position if true.
+            if (position >= strlen (buffer1)) { 
+                position = strlen (buffer1) - 1; 
+                printf("Too big... Position reduced to max. availbale\n");
+            }
+            printf("The character found at %d position is '%c\'\n",(int)position, buffer1[position]);
+        }
+    } while (strcmp (buffer1, "q") != 0); //Loops till user enters 'q'
+    printf("*** End of Indexing Strings Demo ***\n\n");
+}
\ No newline at end of file
diff --git a/fundamentals.h b/fundamentals.h
new file mode 100644
index 0000000..0433660
--- /dev/null
+++ b/fundamentals.h
@@ -0,0 +1,12 @@
+// FUNDAMENTALS MODULE HEADER 
+#ifndef _FUNDAMENTALS_H_
+#define _FUNDAMENTALS_H_
+
+#include <stdio.h> 
+#include <stdlib.h> 
+#include <string.h>
+
+//Takes non-empty string and a number as input and gives the character at that number(index) as output. 
+void fundamentals(void);
+
+#endif
\ No newline at end of file
diff --git a/main.c b/main.c
new file mode 100644
index 0000000..755b397
--- /dev/null
+++ b/main.c
@@ -0,0 +1,58 @@
+// MAIN 
+/*
+Author: BB01, 03/08/2022, CPR101, Final Project V1
+main.c : MAIN
+Purpose: Main Function used to prompt user for which various options.
+*/
+
+// Include all necessary modules
+#define _CRT_SECURE_NO_WARNINGS
+#include "fundamentals.h"
+#include "manipulating.h"
+#include "converting.h"
+#include "tokenizing.h"
+
+int main(void) {
+	// Declare variables
+	char buff[10];
+
+	// Open menu for user
+	do {
+		// Display menu options
+		printf("1 - Fundamentals\n");
+		printf("2 - Manipulation\n");
+		printf("3 - Converting\n");
+		printf("4 - Tokenizing\n");
+		printf("0 - Exit\n");
+		
+		// Prompt user for input
+		printf("Which module to run? \n");
+		fgets(buff, 10, stdin);
+
+		// Analyze user entry and match selection
+		switch (buff[0])
+		{
+		case '1': 
+			// Call for fundamentals module
+			fundamentals();
+			break;
+
+		case '2': 
+			// Call for manipulating module
+			manipulating();
+			break;
+
+		case '3': 
+			// Call for converting module
+			converting();
+			break;
+
+		case '4': 
+			// Call for tokenizing module
+			tokenizing();
+			break;
+		}
+	} while (buff[0] != '0');
+	
+	return 0;
+}
\ No newline at end of file
diff --git a/manipulating.c b/manipulating.c
new file mode 100644
index 0000000..748c895
--- /dev/null
+++ b/manipulating.c
@@ -0,0 +1,34 @@
+/*
+Author: Kiara Rina Pelenio, krpelenio@myseneca.ca, #12636121, 01/08/2022, CPR101, Final Project
+manipulating.c : Manipulating
+Purpose: This program manipulates input strings
+*/
+
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 80
+
+#include "manipulating.h" 
+/* Contains function prototypes and library declarations */
+
+void manipulating(void) {
+/* Purpose: This function concatenates 2 input strings */
+
+	printf("*** Start of Concatenating Strings Demo ***\n");
+	char string1[BUFFER_SIZE];
+	char string2[BUFFER_SIZE];
+
+	do {
+		printf("Type the 1st string (q - to quit):\n");
+		fgets(string1, BUFFER_SIZE, stdin);
+		string1[strlen(string1) - 1] = '\0';	// Replace trailing '\n' witn string null terminator
+
+		if ((strcmp(string1, "q") != 0)) {		// If the input is not equal to "quit"
+			printf("Type the 2nd string:\n");
+			fgets(string2, BUFFER_SIZE, stdin);
+			strcat(string1, string2);
+			printf("Concatenated string is \'%s\'\n", string1);
+		}
+	} while (strcmp(string1, "q") != 0);		// Repeat input as long as input is not equal to "quit"
+
+	printf("*** End of Concatenating Strings Demo ***\n");
+}
\ No newline at end of file
diff --git a/manipulating.h b/manipulating.h
new file mode 100644
index 0000000..8a8f926
--- /dev/null
+++ b/manipulating.h
@@ -0,0 +1,11 @@
+//MANIPULATING MODULE HEADER
+#ifndef _MANIPULATING_H_
+#define _MANIPULATING_H_
+
+#include <stdio.h>		// For input/output and printing
+#include <string.h>		// For string manipulation functions
+
+void manipulating(void);
+/* Purpose: This function concatenates 2 input strings */
+
+#endif
diff --git a/tokenizing.c b/tokenizing.c
new file mode 100644
index 0000000..65d1c20
--- /dev/null
+++ b/tokenizing.c
@@ -0,0 +1,42 @@
+/*
+Author: Jason Tan, jtan26@myseneca.ca, #026325100, 01/08/2022, CPR101, Final Project V1
+[tokenizing.c] : [tokenizing]
+Purpose: [This function takes a user inputted string and tokenizes it]
+*/
+
+
+// TOKENIZING MODULE SOURCE
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 300
+#include "tokenizing.h"
+
+// V1
+void tokenizing(void) {
+
+    printf("*** Start of Tokenizing Words Demo ***\n");
+    char words[BUFFER_SIZE];
+    char* nextWord = NULL;
+    int wordsCounter;
+    do {
+        printf("Type a few words seperated by space (q - to quit):\n");
+
+        fgets(words, BUFFER_SIZE, stdin); 
+        words[strlen(words) - 1] = '\0'; // replaces the new line at the end of the string with null to indicate when the string ends
+
+        if (strcmp(words, "q") != 0) { // only executes if user did not input 'q'
+            nextWord = strtok(words, " "); // use an empty space as the delimiter to know when to split the string into tokens
+            wordsCounter = 1; // intialize wordsCounter to 1, and start counting from 1 to keep track of how many words are being tokenized
+
+        
+    /*  use a loop to print out the string, while incrementing wordsCounter to keep track of the number of words being tokenized */
+            while (nextWord) {
+                printf("Word #%d is \'%s\'\n", wordsCounter++, nextWord); 
+                nextWord = strtok(NULL, " "); // when the next value of the string reads as null, we break out of the loop* /
+            }
+        }
+    } while (strcmp(words, "q") != 0); // breaks the loop if user inputs 'q' as the only character
+
+    printf("*** End of Tokenizing Words Demo ***\n\n");
+}
+
+
diff --git a/tokenizing.h b/tokenizing.h
new file mode 100644
index 0000000..c00f3cb
--- /dev/null
+++ b/tokenizing.h
@@ -0,0 +1,10 @@
+// Tokenization header file
+#ifndef _TOKENIZING_H_
+#define _TOKENIZING_H_
+
+#include <stdio.h>
+#include <string.h>
+
+void tokenizing(void); // Purpose: This function takes a user inputted string and tokenizes it
+
+#endif
\ No newline at end of file

commit f914d3afae4107c77728b3df4d39502c962ba74b
Author: krpm <mungcalrina@gmail.com>
Date:   Thu Aug 4 15:48:50 2022 -0400

    Initial commit

diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..dfe0770
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,2 @@
+# Auto detect text files and perform LF normalization
+* text=auto
